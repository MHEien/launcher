This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  launcher/
    .vscode/
      extensions.json
    ai_context/
      01_project_vision.md
      02_business_model.md
      03_architecture_rules.md
      04_phase_1_tasks.md
      05_plugin_system.md
      06_roadmap.md
      tech_stack.md
    examples/
      hello-plugin/
        src/
          lib.rs
        build.sh
        Cargo.toml
        hello_plugin.wasm
        install.sh
        manifest.json
    public/
      tauri.svg
      vite.svg
    src/
      assets/
        react.svg
      components/
        CalculatorResult.tsx
        Launcher.tsx
        ResultItem.tsx
        ResultsList.tsx
        SearchInput.tsx
        Settings.tsx
      lib/
        utils.ts
      stores/
        auth.ts
        launcher.ts
      types/
        index.ts
      App.tsx
      index.css
      main.tsx
      vite-env.d.ts
    src-tauri/
      capabilities/
        default.json
      icons/
        128x128.png
        128x128@2x.png
        32x32.png
        icon.icns
        icon.ico
        icon.png
        Square107x107Logo.png
        Square142x142Logo.png
        Square150x150Logo.png
        Square284x284Logo.png
        Square30x30Logo.png
        Square310x310Logo.png
        Square44x44Logo.png
        Square71x71Logo.png
        Square89x89Logo.png
        StoreLogo.png
      src/
        indexer/
          config.rs
          file_index.rs
          mod.rs
          watcher.rs
        oauth/
          callback.rs
          flow.rs
          mod.rs
          providers.rs
          storage.rs
        plugins/
          host_api.rs
          loader.rs
          manifest.rs
          mod.rs
          registry.rs
          runtime.rs
        providers/
          apps.rs
          calculator.rs
          files.rs
          github.rs
          google_calendar.rs
          google_drive.rs
          mod.rs
          notion.rs
          plugins.rs
          slack.rs
        auth.rs
        config.rs
        frecency.rs
        lib.rs
        main.rs
        theme.rs
      .gitignore
      build.rs
      Cargo.toml
      tauri.conf.json
    .env
    .env.example
    index.html
    launcher-handler.desktop
    package.json
    PROGRESS.md
    README.md
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
  server/
    src/
      index.ts
    package.json
    tsconfig.json
  web/
    .git/
      hooks/
        applypatch-msg.sample
        commit-msg.sample
        fsmonitor-watchman.sample
        post-update.sample
        pre-applypatch.sample
        pre-commit.sample
        pre-merge-commit.sample
        pre-push.sample
        pre-rebase.sample
        pre-receive.sample
        prepare-commit-msg.sample
        push-to-checkout.sample
        sendemail-validate.sample
        update.sample
      info/
        exclude
      objects/
        00/
          4145cddf3f9db91b57b9cb596683c8eb420862
        02/
          2b149c364ea583cc695722c09bee4e90148da9
        05/
          e726d1b4201bc8c7716d2b058279676582e8c0
        10/
          200986df06234fd66cdeb5024788913bf1e7a1
        11/
          f323f858aa96015d7c7dc2aa05293f24f0127d
        25/
          699aff6e01851ecc864d81b49504bb287784d7
        29/
          5f8fdf14fcfe6cccaa832133037157521b1890
        3b/
          f9c2952b07f10e32ff965229d3efd69a43fe1b
        3d/
          bbe2ae9490a3d292814f50c2f484a50cede871
        3f/
          bc0d6964407fbe4bd2d16d220a585c8a15473f
        51/
          74b28c565c285e3e312ec5178be64fbeca8398
        55/
          2deeb0596521c1fad8128b30abcaa460844d47
        56/
          7f17b0d7c7fb662c16d4357dd74830caf2dccb
        57/
          939ae9a24dc072b682ef7b2cdbee3009f9a216
        5e/
          64c8b17234dbbb6ca50766ed10cb7f81475756
          f6a520780202a1d6addd833d800ccb1ecac0bb
        5f/
          75778d6ee02b76d9a9ae427d45344fac4e3406
        61/
          e36849cf7cfa9f1f71b4a3964a4953e3e243d3
        64/
          088db3d6d9b192b9e9b8093ebd834c156dba7d
        65/
          ad1dc08f785059c0b80f344b09deca07b9e37c
        68/
          0e2c09aa6b8035cda33ca724357069cbeab94c
        71/
          8d6fea4835ec2d246af9800eddb7ffb276240c
        77/
          053960334e2e34dc584dea8019925c3b4ccca9
        78/
          2f7b1c66fe632a33c9e9ff72f4f20709c72b0a
        7a/
          179e56f7b60999c44f58e882d6e25833385e8e
        7d/
          dec7be96f9f4e0778a17d12e1cad847c11d3dc
        7e/
          1310f9b751964e3d5f2510db4b0ae8ac215071
        89/
          bde4f1b54d2efe29ca5fb230900fd073cc966e
        8c/
          b98472d4539c2f3269a48164f9077bf7f4dabf
        9e/
          02ee29a0509f98f17fff2e9a6f84cfae4bfe40
        a0/
          3b15188f33f348cdb62227a79cd66a9b92089d
        a2/
          dc41ecee5ec435200fe7cba2bde4107f823774
        aa/
          ad6f9e6e9b2262b043340091540f96d909e849
        ac/
          afde3bf07fec7d610138ef58fc5a3dfe8b17c1
        ae/
          809b4e38da6144522632032513e0c802213f00
        b0/
          f3ed76fd66b5bccb3dbfcabdb7110dba89ff00
        b2/
          b2a44f6ebc70c450043c05a002e7a93ba5d651
        b3/
          6cbd4bcb3c63befa4530af086fe4380c833894
        bf/
          e9db16103c27accf833ab3cc4b2e5e611196a3
        c0/
          d1a5f14e7ce8e3c451ff4a417f62e76a79d5d4
        c1/
          ef3df121009fc063a835bec2d9375d7186a2d0
        c8/
          8f389de09f418da376598c42e8788d4fb6d172
        cf/
          9c65d3e0676a0169374d827f7abb97497789ef
        dd/
          9cccb89e26ffa6db434ff2cbc005c9c8157cfc
        e2/
          15bc4ccf138bbc38ad58ad57e92135484b3c0f
        e6/
          9de29bb2d1d6434b8b29ae775ad8c2e48c5391
        e7/
          2b4d6a488ccacb6296f0db7c609e15ff3bac14
        e8/
          7db5d2ebdee212f483322279894f18492739b3
        e9/
          ffa3083ad279ecf95fd8eae59cb253e9a539c4
        ee/
          102a9c120a8e691b20d4260ce92aff4d088a93
        f6/
          5cac0bead4acec3774a3b03892b7b7e42075a9
        f7/
          fa87eb875260ed98651bc419c8139b5119e554
        fb/
          cc5e82b8b9a21e709e60e99d676e7cbe631619
      refs/
        heads/
          main
      COMMIT_EDITMSG
      config
      description
      FETCH_HEAD
      HEAD
      index
    public/
      file.svg
      globe.svg
      next.svg
      vercel.svg
      window.svg
    src/
      app/
        api/
          auth/
            desktop/
              exchange/
                route.ts
              refresh/
                route.ts
          keys/
            [id]/
              route.ts
            route.ts
          plugins/
            submit/
              route.ts
          stripe/
            checkout/
              route.ts
            portal/
              route.ts
            webhook/
              route.ts
          usage/
            route.ts
        auth/
          desktop/
            page.tsx
        dashboard/
          api-keys/
            api-key-manager.tsx
            page.tsx
          subscription/
            page.tsx
          page.tsx
        handler/
          [...stack]/
            page.tsx
        plugins/
          [id]/
            page.tsx
          submit/
            page.tsx
        pricing/
          page.tsx
        search/
          page.tsx
        favicon.ico
        globals.css
        layout.tsx
        page.tsx
      components/
        auth-provider.tsx
        category-filter.tsx
        header.tsx
        plugin-grid.tsx
        search-bar.tsx
      lib/
        auth/
          client.ts
        db/
          index.ts
          schema.ts
        desktop-auth.ts
        stripe.ts
        usage.ts
      stack-client.ts
      stack.ts
    .env.example
    .gitignore
    eslint.config.mjs
    next.config.ts
    package.json
    postcss.config.mjs
    README.md
    tsconfig.json
packages/
  cache/
    src/
      index.ts
      redis.ts
      vector.ts
    package.json
    tsconfig.json
  db/
    src/
      index.js
      index.ts
      schema.js
      schema.ts
    .env
    .env.example
    drizzle.config.js
    drizzle.config.ts
    package.json
    tsconfig.json
  shared/
    src/
      index.ts
    package.json
    tsconfig.json
.gitignore
package.json
README.md
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/launcher/.vscode/extensions.json">
{
  "recommendations": ["tauri-apps.tauri-vscode", "rust-lang.rust-analyzer"]
}
</file>

<file path="apps/launcher/ai_context/01_project_vision.md">
# Project Vision: The Next-Gen Cross-Platform Launcher

## Core Identity
A **more powerful, cross-platform Raycast alternative** that surpasses PowerToys CmdPal. 
Built with Rust backend + React frontend for native performance with web-like flexibility.
**Cross-platform first:** Windows, Linux, macOSâ€”blending seamlessly into each desktop environment.

## The "North Star" Features

### 1. Instant Search & Inline Tools
- **Hotkey activation** â†’ Immediately ready to type
- **Inline calculations:** Type `2+2` â†’ Answer appears instantly above results (no Enter needed)
- **Smart search:** Powerful indexer for files, apps, commandsâ€”context-aware and fast

### 2. Seamless AI Integration
- Type a query â†’ Press Enter â†’ **Morphs into AI chat** with query already sent
- **Agentic AI:** Not just chatâ€”AI has powerful tools to:
  - Interact with your device (files, apps, system)
  - Connect to third-party services via installed plugins
  - Execute complex multi-step workflows

### 3. Chameleon Theming
- Auto-detect user's OS theme (GTK/KDE on Linux, Windows accent colors, macOS)
- **Theme marketplace** for full customization
- Premium aesthetics: glassmorphism, smooth animations, minimalist typography

### 4. Plugin Ecosystem & Marketplace
- **In-app marketplace:** Browse, install, update plugins directly from the launcher
- **OAuth-ready:** First-class support for SaaS integrations (Google, GitHub, Notion, etc.)
- Community-driven: Developers can publish plugins to the marketplace

### 5. Extensibility & Scalability
- Clean plugin architecture for easy extension
- Robust sandboxing for security
- Designed to scale with features and community contributions

## Business Model
- **Open Source "Community Edition":** Core launcher, plugin system, themingâ€”fully open
- **Proprietary Premium Features:** AI capabilities, certain advanced toolsâ€”paid services with closed source
- **Plugin Marketplace:** Potential for paid plugins from third-party developers

## Target User
Power users, developers, and productivity enthusiasts who want:
- Keyboard-first workflow
- Cross-platform consistency
- AI-augmented productivity
- Extensibility without compromise
</file>

<file path="apps/launcher/ai_context/02_business_model.md">
# Business Model: Open Core Strategy

## Overview
The launcher follows an **Open Core** modelâ€”a fully functional open-source "Community Edition" with proprietary premium features for monetization.

## Open Source (Community Edition)
Everything in this repository is open source under a permissive license:

- **Core Launcher:** Window management, hotkey activation, search UI
- **Search & Indexing:** File, app, and command indexing
- **Inline Tools:** Calculator, unit conversions, quick actions
- **Plugin System:** Full plugin API, sandboxing, lifecycle management
- **Theme Engine:** OS theme detection, CSS variable injection, custom themes
- **Theme Marketplace:** Community themes (free)
- **Plugin Marketplace Client:** Browse, install, update plugins

## Proprietary (Premium/Paid)
Closed-source services requiring subscription or one-time purchase:

### AI Features (Subscription)
- Agentic AI chat with tool use
- AI-powered search and context understanding
- Natural language commands
- Multi-step workflow automation
- AI integration with plugins

### Premium Plugins & Tools
- Advanced integrations (enterprise SaaS)
- Premium productivity tools
- Priority support

### Marketplace Backend
- Plugin hosting and distribution infrastructure
- Developer accounts and publishing tools
- Payment processing for paid plugins

## Revenue Streams
1. **AI Subscription:** Monthly/yearly plans for AI features
2. **Paid Plugins:** Revenue share with plugin developers (e.g., 70/30)
3. **Premium Themes:** Optional paid themes from designers
4. **Enterprise Licensing:** Custom deployments, support contracts

## Philosophy
- Community Edition must be **genuinely useful** standaloneâ€”not crippled
- Premium features add power, not unlock basics
- Open source builds trust and community contributions
- Proprietary AI covers API costs and funds development
</file>

<file path="apps/launcher/ai_context/03_architecture_rules.md">
# Architectural Guidelines

## 1. The "Thin Client" Principle
The React frontend should be dumb. It sends a user query string to Rust, and Rust returns a `Vector<ResultItem>`. 
* **Bad:** React filtering a list of 50,000 files.
* **Good:** Rust filtering files and sending the top 20 to React.

## 2. Powerful Indexer Architecture
Fast search requires a robust indexing system:
* **Background indexing:** Continuously index files, apps, commands on startup and file changes
* **Incremental updates:** Watch filesystem for changes, update index without full rebuild
* **Fuzzy matching:** Typo-tolerant search with ranking by relevance and recency
* **Context for AI:** Indexed data provides rich context for AI features
* **Key crates:** `tantivy` (full-text search), `notify` (file watching)

## 3. The Plugin System
Structure core functionality as "Providers" that plugins can extend:

### Provider Trait
```rust
trait SearchProvider {
    fn id(&self) -> &str;
    fn search(&self, query: &str) -> Vec<SearchResult>;
    fn execute(&self, result: &SearchResult) -> Result<()>;
}
```

### Core Providers (Built-in)
* `AppProvider` - Installed applications
* `FileProvider` - File search via indexer
* `CalculatorProvider` - Inline math evaluation
* `CommandProvider` - System commands, shell access

### Plugin Providers (Extensible)
* Loaded via WASM for sandboxing and cross-platform compatibility
* Can register new providers, actions, and UI components
* Access to controlled APIs (network, storage, OAuth tokens)

## 4. OAuth & Third-Party Integration
Plugins connecting to SaaS services need secure auth:
* **OAuth flow:** Rust handles OAuth dance, stores tokens securely in OS keychain
* **Token management:** Automatic refresh, secure storage per-plugin
* **Permission model:** User grants specific scopes to plugins
* **Supported patterns:** OAuth 2.0, API keys, custom auth via plugin config

## 5. Plugin Marketplace Architecture
* **Client (Open Source):** Browse, search, install, update plugins from within launcher
* **Backend (Proprietary):** Plugin hosting, versioning, reviews, developer accounts
* **Installation:** Download plugin WASM bundle â†’ verify signature â†’ install to local plugin dir
* **Updates:** Check for updates on launch, notify user, one-click update

## 6. The "Chameleon" Theme Engine
On startup, Rust must query the OS for:
* Accent Color (GTK, KDE, Windows registry, macOS)
* Dark/Light Mode
* Window blur capability (Mica on Windows, blur on Linux compositors)

This data is passed to React to inject into CSS Variables (`--accent`, `--bg-opacity`).

### Theme Marketplace
* Themes are CSS variable bundles + optional assets
* Users can browse/install themes from marketplace
* Custom themes override OS detection

## 7. AI Integration Points (Premium)
* **Chat interface:** Separate view that morphs from search bar
* **Tool system:** AI can call registered tools (file ops, app launch, plugin actions)
* **Context injection:** Indexer provides relevant context to AI
* **Plugin tools:** Plugins can register tools the AI can invoke
* **Streaming:** Real-time response streaming for chat UX
</file>

<file path="apps/launcher/ai_context/04_phase_1_tasks.md">
# Phase 1: Core Shell & Instant Search

## Goal
Build the foundational launcher: hotkey-activated window with instant search, inline calculator, and OS theme integration.

## Tasks

### 1. Window & Hotkey Foundation
- [ ] Clean Tauri/React boilerplate
- [ ] Configure `tauri.conf.json`: transparent, borderless, always-on-top
- [ ] Global hotkey registration (configurable, default `Alt+Space`)
- [ ] Window toggle: show/hide with hotkey
- [ ] Auto-focus input on window show
- [ ] Click-outside or Escape to dismiss

### 2. Theme Engine (Chameleon)
- [ ] Rust: `get_system_theme` command
  - Linux: Read GTK/KDE theme, accent color
  - Windows: Registry accent color, dark/light mode
  - macOS: System preferences
- [ ] React: `useTheme` hook consuming Rust theme data
- [ ] CSS variables injection (`--accent`, `--bg`, `--text`, etc.)
- [ ] Window blur/vibrancy where supported

### 3. Search UI
- [ ] Centered search bar (Shadcn/UI style)
- [ ] Results list below search bar
- [ ] Keyboard navigation (arrow keys, Enter to execute)
- [ ] Result item component (icon, title, subtitle, shortcut hint)

### 4. Inline Calculator
- [ ] Detect math expressions in query (e.g., `2+2`, `sqrt(16)`)
- [ ] Evaluate and display result **above** search results instantly
- [ ] Copy result to clipboard on Enter or click

### 5. Basic Search Providers
- [ ] `CalculatorProvider` - Math evaluation
- [ ] `AppProvider` - List installed applications (platform-specific)
- [ ] Provider trait foundation for future extensibility

## Success Criteria
- Hotkey opens launcher instantly
- Typing `2+2` shows `4` immediately
- Typing app name shows matching apps
- Enter launches selected app
- Looks native on user's desktop (theme colors match)
</file>

<file path="apps/launcher/ai_context/05_plugin_system.md">
# Plugin System Architecture

## Overview
The plugin system is a core differentiatorâ€”enabling community extensions while maintaining security and cross-platform compatibility.

## Plugin Types

### 1. Search Providers
Add new searchable sources:
- **Examples:** Bookmarks, browser history, Notion pages, GitHub repos, Spotify tracks
- **Interface:** Implement `SearchProvider` trait
- **Behavior:** Results appear in main search alongside core providers

### 2. Actions
Add executable commands:
- **Examples:** "Create Jira ticket", "Start Pomodoro timer", "Toggle VPN"
- **Interface:** Implement `Action` trait
- **Behavior:** Appear as actionable results, may have sub-menus

### 3. Views (Advanced)
Custom UI panels:
- **Examples:** Calendar widget, clipboard history, snippet manager
- **Interface:** Provide React component via plugin manifest
- **Behavior:** Opened via command or shortcut, renders in launcher window

### 4. AI Tools (Premium Integration)
Tools the AI agent can invoke:
- **Examples:** "Search my emails", "Create calendar event", "Query database"
- **Interface:** JSON schema defining tool parameters and behavior
- **Behavior:** AI calls tool, plugin executes, returns result to AI

## Plugin Manifest
Every plugin includes a `manifest.json`:
```json
{
  "id": "com.example.github-search",
  "name": "GitHub Search",
  "version": "1.0.0",
  "author": "Developer Name",
  "description": "Search GitHub repos, issues, and PRs",
  "permissions": ["network", "oauth:github"],
  "entry": "plugin.wasm",
  "provides": {
    "providers": ["github-repos", "github-issues"],
    "actions": ["create-issue", "create-pr"],
    "ai_tools": ["search-repos", "get-issue-details"]
  },
  "oauth": {
    "github": {
      "scopes": ["repo", "read:user"]
    }
  }
}
```

## Security Model

### WASM Sandboxing
- Plugins run in WASM sandbox via `wasmtime`
- No direct filesystem/network accessâ€”must use provided APIs
- Memory isolated per plugin

### Permission System
| Permission | Description | User Prompt |
|------------|-------------|-------------|
| `network` | Make HTTP requests | "Allow network access?" |
| `filesystem:read` | Read files (scoped paths) | "Allow reading files in X?" |
| `filesystem:write` | Write files (scoped paths) | "Allow writing files in X?" |
| `clipboard` | Read/write clipboard | "Allow clipboard access?" |
| `oauth:<provider>` | OAuth token for provider | OAuth consent screen |
| `notifications` | Show system notifications | "Allow notifications?" |

### Code Signing
- Marketplace plugins are signed
- Unsigned plugins show warning
- Enterprise can enforce signed-only policy

## Plugin APIs

### Host Functions (Rust â†’ WASM)
```rust
// Available to plugins via WASM imports
fn http_request(url: &str, method: &str, body: &[u8]) -> Response;
fn read_file(path: &str) -> Result<Vec<u8>, Error>;
fn write_file(path: &str, data: &[u8]) -> Result<(), Error>;
fn get_oauth_token(provider: &str) -> Result<String, Error>;
fn show_notification(title: &str, body: &str);
fn log(level: LogLevel, message: &str);
fn get_config() -> PluginConfig;
fn set_config(config: PluginConfig);
```

### Plugin Exports (WASM â†’ Rust)
```rust
// Plugins must export these
fn init() -> PluginInfo;
fn search(query: &str) -> Vec<SearchResult>;
fn execute(action_id: &str, params: &str) -> Result<(), Error>;
fn shutdown();
```

## Marketplace Integration

### Publishing Flow
1. Developer creates plugin, tests locally
2. Submit to marketplace (requires developer account)
3. Automated security scan + review
4. Published to marketplace with version history

### Installation Flow
1. User browses marketplace in launcher
2. Clicks "Install" â†’ sees permission prompt
3. Plugin downloaded, verified, installed
4. Appears in settings, can be configured/disabled

### Update Flow
1. Launcher checks for updates on startup (configurable)
2. User notified of available updates
3. One-click update or auto-update (user preference)

## Local Development
```bash
# Create new plugin from template
launcher plugin new my-plugin

# Build plugin
launcher plugin build

# Test locally (sideload)
launcher plugin dev

# Package for submission
launcher plugin package
```

## Configuration & Storage
- Each plugin gets isolated storage directory
- Config stored as JSON, accessible via API
- Secrets (API keys) stored in OS keychain via host API

## Example: GitHub Plugin

### Search Provider
```rust
fn search(query: &str) -> Vec<SearchResult> {
    let token = get_oauth_token("github")?;
    let repos = github_api::search_repos(&token, query)?;
    
    repos.iter().map(|r| SearchResult {
        id: r.full_name.clone(),
        title: r.name.clone(),
        subtitle: r.description.clone(),
        icon: Icon::Url(r.owner.avatar_url.clone()),
        action: Action::OpenUrl(r.html_url.clone()),
    }).collect()
}
```

### AI Tool
```json
{
  "name": "search_github_repos",
  "description": "Search GitHub repositories",
  "parameters": {
    "query": { "type": "string", "description": "Search query" },
    "language": { "type": "string", "optional": true }
  }
}
```
</file>

<file path="apps/launcher/ai_context/06_roadmap.md">
# Development Roadmap

## Phase 1: Core Shell & Instant Search âœ¦ Current
**Goal:** Functional launcher with hotkey, search, and theming

- [ ] Window management (transparent, borderless, hotkey toggle)
- [ ] OS theme detection (Linux GTK/KDE, Windows, macOS)
- [ ] Search bar UI with keyboard navigation
- [ ] Inline calculator (instant math evaluation)
- [ ] App provider (list/launch installed apps)
- [ ] Basic file search

**Deliverable:** Usable launcher that opens with hotkey, searches apps, does math

---

## Phase 2: Indexer & Advanced Search
**Goal:** Fast, comprehensive search across files and content

- [ ] Background file indexer using Tantivy
- [ ] Incremental index updates via filesystem watching
- [ ] Fuzzy matching with relevance ranking
- [ ] File content search (text files, PDFs, etc.)
- [ ] Search history and frecency boosting
- [ ] Settings UI for index configuration

**Deliverable:** Sub-100ms search across thousands of files

---

## Phase 3: Plugin Foundation
**Goal:** Extensible architecture with first plugins

- [ ] WASM runtime integration (wasmtime)
- [ ] Plugin manifest format and loader
- [ ] Permission system and sandboxing
- [ ] Host API for plugins (HTTP, storage, config)
- [ ] Plugin settings UI
- [ ] First-party plugins: Clipboard history, Snippets

**Deliverable:** Working plugin system with example plugins

---

## Phase 4: OAuth & SaaS Integrations
**Goal:** Secure third-party service connections

- [ ] OAuth flow handling in Rust
- [ ] Secure token storage (OS keychain)
- [ ] Token refresh and management
- [ ] First OAuth plugins: Google, GitHub, Notion
- [ ] Plugin permission prompts for OAuth scopes

**Deliverable:** Plugins can securely connect to SaaS services

---

## Phase 5: Plugin Marketplace
**Goal:** In-app plugin discovery and installation

- [ ] Marketplace UI in launcher
- [ ] Plugin search, categories, ratings
- [ ] One-click install/update/uninstall
- [ ] Plugin signing and verification
- [ ] Developer submission portal (separate project)

**Deliverable:** Users can browse and install plugins from marketplace

---

## Phase 6: Theme Marketplace
**Goal:** Customizable appearance with community themes

- [ ] Theme format specification (CSS variables + assets)
- [ ] Theme preview and installation
- [ ] Theme editor/creator tool
- [ ] Community theme submissions

**Deliverable:** Users can fully customize launcher appearance

---

## Phase 7: AI Integration (Premium)
**Goal:** Agentic AI assistant with tool use

- [ ] Chat UI (morphs from search bar)
- [ ] AI backend service (closed source)
- [ ] Streaming response rendering
- [ ] Tool system for AI actions
- [ ] Context injection from indexer
- [ ] Plugin-provided AI tools
- [ ] Subscription/auth for premium features

**Deliverable:** AI assistant that can search, execute actions, use plugins

---

## Phase 8: Polish & Launch
**Goal:** Production-ready release

- [ ] Performance optimization
- [ ] Accessibility audit
- [ ] Onboarding flow
- [ ] Documentation site
- [ ] Auto-updater
- [ ] Crash reporting and telemetry (opt-in)
- [ ] Marketing site and launch

**Deliverable:** Public release of Community Edition

---

## Future Ideas
- **Workflows:** Chain actions together (like Shortcuts/Automator)
- **Widgets:** Dashboard view with customizable widgets
- **Team features:** Shared snippets, plugins, configs
- **Mobile companion:** View/trigger actions from phone
- **Voice input:** Speak commands
- **Screen context:** AI understands what's on screen
- **Browser extension:** Search browser tabs, bookmarks, history
</file>

<file path="apps/launcher/ai_context/tech_stack.md">
# Technology Stack & Constraints

## Core Backend (Rust)
* **Language:** Rust (Edition 2021)
* **Framework:** Tauri v2 (Stable)
* **Async Runtime:** Tokio
* **Responsibilities:**
  - System IO, Window Management, Global Hotkeys
  - File/App Indexing and Search
  - Plugin Sandbox (WASM runtime)
  - OAuth token management
  - OS theme detection

### Key Crates
| Crate | Purpose |
|-------|---------|
| `tauri` | App framework, IPC, window management |
| `tokio` | Async runtime |
| `serde` / `serde_json` | Serialization |
| `tantivy` | Full-text search indexing |
| `notify` | Filesystem watching |
| `window-vibrancy` | Window blur effects |
| `wasmtime` | WASM plugin runtime |
| `keyring` | Secure credential storage |
| `meval` or `fasteval` | Math expression evaluation |
| `freedesktop-desktop-entry` | Linux app discovery |
| `windows` | Windows API access |

## Frontend (React)
* **Framework:** React 18+ (TypeScript)
* **Build Tool:** Vite
* **Styling:** Tailwind CSS v4
* **UI Library:** Shadcn/UI (Radix Primitives)
* **State Management:** Zustand
* **Icons:** Lucide React
* **Animations:** Framer Motion

## Integration Rules
* **IPC:** All heavy lifting in Rust. React only renders data received via Tauri commands.
* **Type Safety:** `ts-rs` or `specta` for auto-generating TypeScript types from Rust structs.
* **Events:** Tauri events for Rust â†’ React push updates (theme changes, index updates).

## Plugin System
* **Runtime:** WASM (via `wasmtime`) for sandboxed, cross-platform plugins
* **Plugin API:** Defined traits/interfaces plugins must implement
* **Capabilities:** Plugins request permissions (network, filesystem, OAuth scopes)

## AI Integration (Premium - Closed Source)
* **Backend:** Separate service handling AI requests
* **Protocol:** Streaming responses via SSE or WebSocket
* **Tool System:** JSON-RPC style tool definitions AI can invoke
* **Context:** Indexer provides relevant file/app context to AI

## Platform-Specific Notes
| Platform | Theme Detection | App Discovery | Window Effects |
|----------|-----------------|---------------|----------------|
| Linux | GTK/KDE configs, `gsettings` | `.desktop` files, XDG dirs | Compositor-dependent blur |
| Windows | Registry, `dwmapi` | Start menu, `shell32` | Mica, Acrylic |
| macOS | `NSAppearance`, system prefs | `/Applications`, Spotlight | Vibrancy |
</file>

<file path="apps/launcher/examples/hello-plugin/src/lib.rs">
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

extern "C" {
    fn host_log(ptr: *const u8, len: i32);
}

fn log(message: &str) {
    unsafe {
        host_log(message.as_ptr(), message.len() as i32);
    }
}

static mut HEAP: [u8; 4096] = [0; 4096];
static mut HEAP_PTR: usize = 0;

#[no_mangle]
pub extern "C" fn alloc(size: i32) -> i32 {
    unsafe {
        let ptr = HEAP_PTR;
        HEAP_PTR += size as usize;
        if HEAP_PTR > HEAP.len() {
            return 0;
        }
        HEAP.as_ptr().add(ptr) as i32
    }
}

#[no_mangle]
pub extern "C" fn init() {
    log("Hello Plugin initialized!");
}

#[no_mangle]
pub extern "C" fn shutdown() {
    log("Hello Plugin shutting down...");
}

#[no_mangle]
pub extern "C" fn search(query_ptr: i32, query_len: i32) -> i32 {
    unsafe {
        HEAP_PTR = 0;
    }
    
    let _query = unsafe {
        core::slice::from_raw_parts(query_ptr as *const u8, query_len as usize)
    };
    
    log("Hello Plugin received search query");
    
    0
}
</file>

<file path="apps/launcher/examples/hello-plugin/build.sh">
#!/bin/bash
set -e

echo "Building hello-plugin for wasm32-unknown-unknown..."
cargo build --release --target wasm32-unknown-unknown

echo "Copying WASM file..."
cp target/wasm32-unknown-unknown/release/hello_plugin.wasm .

echo "Build complete! Files:"
ls -la hello_plugin.wasm manifest.json

echo ""
echo "To install the plugin, run:"
echo "  ./install.sh"
</file>

<file path="apps/launcher/examples/hello-plugin/Cargo.toml">
[package]
name = "hello-plugin"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
opt-level = "s"
lto = true
</file>

<file path="apps/launcher/examples/hello-plugin/install.sh">
#!/bin/bash
set -e

PLUGINS_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/launcher/plugins/hello-plugin"

echo "Installing hello-plugin to $PLUGINS_DIR..."
mkdir -p "$PLUGINS_DIR"
cp manifest.json "$PLUGINS_DIR/"
cp hello_plugin.wasm "$PLUGINS_DIR/"

echo "Plugin installed successfully!"
echo ""
echo "Restart the launcher to load the plugin."
</file>

<file path="apps/launcher/examples/hello-plugin/manifest.json">
{
  "id": "hello-plugin",
  "name": "Hello Plugin",
  "version": "0.1.0",
  "author": "Launcher Team",
  "description": "A simple example plugin that demonstrates the plugin system",
  "permissions": [],
  "entry": "hello_plugin.wasm",
  "provides": {
    "providers": ["hello"],
    "actions": [],
    "ai_tools": []
  }
}
</file>

<file path="apps/launcher/public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="apps/launcher/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="apps/launcher/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="apps/launcher/src/components/CalculatorResult.tsx">
import { motion, AnimatePresence } from "framer-motion";
import { Copy, Check } from "lucide-react";
import { useState } from "react";
import { useLauncherStore } from "@/stores/launcher";
import { cn } from "@/lib/utils";

export function CalculatorResult() {
  const [copied, setCopied] = useState(false);
  const { results } = useLauncherStore();

  const calcResult = results.find((r) => r.category === "Calculator");

  if (!calcResult) return null;

  const handleCopy = async () => {
    await navigator.clipboard.writeText(calcResult.title);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, height: 0 }}
        animate={{ opacity: 1, height: "auto" }}
        exit={{ opacity: 0, height: 0 }}
        className="border-b border-border/50"
      >
        <div
          onClick={handleCopy}
          className={cn(
            "flex items-center justify-between px-4 py-3",
            "cursor-pointer hover:bg-accent/30 transition-colors"
          )}
        >
          <div className="flex items-center gap-3">
            <span className="text-2xl">ðŸ”¢</span>
            <div>
              <div className="text-2xl font-semibold text-foreground">
                {calcResult.title}
              </div>
              <div className="text-sm text-muted-foreground">
                {calcResult.subtitle}
              </div>
            </div>
          </div>

          <button
            onClick={(e) => {
              e.stopPropagation();
              handleCopy();
            }}
            className={cn(
              "flex items-center gap-1.5 px-2 py-1 rounded-md",
              "text-sm text-muted-foreground",
              "hover:bg-accent hover:text-accent-foreground",
              "transition-colors"
            )}
          >
            {copied ? (
              <>
                <Check className="h-4 w-4" />
                <span>Copied</span>
              </>
            ) : (
              <>
                <Copy className="h-4 w-4" />
                <span>Copy</span>
              </>
            )}
          </button>
        </div>
      </motion.div>
    </AnimatePresence>
  );
}
</file>

<file path="apps/launcher/src/components/Launcher.tsx">
import { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { Loader2, Settings as SettingsIcon } from "lucide-react";
import { useLauncherStore } from "@/stores/launcher";
import { useAuthStore } from "@/stores/auth";
import { SearchInput } from "./SearchInput";
import { CalculatorResult } from "./CalculatorResult";
import { ResultsList } from "./ResultsList";
import { Settings } from "./Settings";
import { cn } from "@/lib/utils";

export function Launcher() {
  const { loadTheme, hideWindow, results, indexingStatus, setupIndexingListener } =
    useLauncherStore();
  const { initialize: initAuth, setupAuthListener } = useAuthStore();
  const [settingsOpen, setSettingsOpen] = useState(false);

  useEffect(() => {
    loadTheme();
    setupIndexingListener();
    initAuth();
    
    // Set up auth callback listener for deep links
    let unlistenAuth: (() => void) | undefined;
    setupAuthListener().then((unlisten) => {
      unlistenAuth = unlisten;
    });

    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (!target.closest(".launcher-container") && !settingsOpen) {
        hideWindow();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      if (unlistenAuth) unlistenAuth();
    };
  }, [loadTheme, hideWindow, setupIndexingListener, settingsOpen, initAuth, setupAuthListener]);

  const hasResults = results.length > 0;
  const hasCalcResult = results.some((r) => r.category === "Calculator");
  const hasOtherResults = results.some((r) => r.category !== "Calculator");
  const isIndexing = indexingStatus?.is_indexing;

  return (
    <div className="h-screen w-screen flex items-start justify-center pt-[15vh]">
      <motion.div
        initial={{ opacity: 0, scale: 0.96, y: -10 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        transition={{ duration: 0.2, ease: "easeOut" }}
        className={cn(
          "launcher-container w-full max-w-[680px]",
          "bg-(--launcher-bg) backdrop-blur-(--launcher-blur)",
          "border border-(--launcher-border)",
          "rounded-xl shadow-(--launcher-shadow)",
          "overflow-hidden"
        )}
      >
        <SearchInput />

        {isIndexing && (
          <div className="flex items-center gap-2 px-4 py-2 text-sm text-muted-foreground border-t border-border/30">
            <Loader2 className="h-4 w-4 animate-spin" />
            <span>{indexingStatus?.message || "Indexing files..."}</span>
          </div>
        )}

        {hasResults && (
          <div className="border-t border-border/30">
            {hasCalcResult && <CalculatorResult />}
            {hasOtherResults && <ResultsList />}
          </div>
        )}

        <div className="flex items-center justify-end px-3 py-2 border-t border-border/30">
          <button
            onClick={() => setSettingsOpen(true)}
            className="p-1.5 rounded-md hover:bg-muted/50 transition-colors text-muted-foreground hover:text-foreground"
            title="Settings"
          >
            <SettingsIcon className="h-4 w-4" />
          </button>
        </div>
      </motion.div>

      <Settings isOpen={settingsOpen} onClose={() => setSettingsOpen(false)} />
    </div>
  );
}
</file>

<file path="apps/launcher/src/components/ResultItem.tsx">
import { motion } from "framer-motion";
import { Calculator, AppWindow, File, Terminal, Puzzle } from "lucide-react";
import type { SearchResult, ResultCategory } from "@/types";
import { cn } from "@/lib/utils";

interface ResultItemProps {
  result: SearchResult;
  isSelected: boolean;
  index: number;
  onSelect: () => void;
  onExecute: () => void;
}

function getCategoryIcon(category: ResultCategory) {
  switch (category) {
    case "Calculator":
      return Calculator;
    case "Application":
      return AppWindow;
    case "File":
      return File;
    case "Command":
      return Terminal;
    case "Plugin":
      return Puzzle;
    default:
      return AppWindow;
  }
}

function renderIcon(result: SearchResult) {
  const { icon, category } = result;

  if (icon.type === "Emoji") {
    return <span className="text-xl">{icon.value}</span>;
  }

  if (icon.type === "Text") {
    return <span className="text-sm font-medium truncate max-w-[24px]">{icon.value}</span>;
  }

  const IconComponent = getCategoryIcon(category);
  return <IconComponent className="h-5 w-5" />;
}

export function ResultItem({
  result,
  isSelected,
  index,
  onSelect,
  onExecute,
}: ResultItemProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 5 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.15, delay: index * 0.02 }}
      onClick={onExecute}
      onMouseEnter={onSelect}
      className={cn(
        "flex items-center gap-3 px-4 py-2.5 cursor-pointer transition-colors",
        "rounded-lg mx-2",
        isSelected
          ? "bg-accent text-accent-foreground"
          : "hover:bg-accent/50"
      )}
    >
      <div
        className={cn(
          "flex items-center justify-center w-8 h-8 rounded-md",
          "bg-secondary/50",
          isSelected && "bg-background/20"
        )}
      >
        {renderIcon(result)}
      </div>

      <div className="flex-1 min-w-0">
        <div className="font-medium truncate">{result.title}</div>
        {result.subtitle && (
          <div className="text-sm text-muted-foreground truncate">
            {result.subtitle}
          </div>
        )}
      </div>

      {isSelected && (
        <div className="flex items-center gap-1 text-xs text-muted-foreground">
          <kbd className="px-1.5 py-0.5 bg-background/30 rounded text-[10px]">
            â†µ
          </kbd>
        </div>
      )}
    </motion.div>
  );
}
</file>

<file path="apps/launcher/src/components/ResultsList.tsx">
import { useRef, useEffect } from "react";
import { AnimatePresence } from "framer-motion";
import { useLauncherStore } from "@/stores/launcher";
import { ResultItem } from "./ResultItem";

export function ResultsList() {
  const listRef = useRef<HTMLDivElement>(null);
  const { results, selectedIndex, setSelectedIndex, executeSelected } =
    useLauncherStore();

  useEffect(() => {
    if (listRef.current && results.length > 0) {
      const selectedElement = listRef.current.children[selectedIndex] as HTMLElement;
      if (selectedElement) {
        selectedElement.scrollIntoView({ block: "nearest", behavior: "smooth" });
      }
    }
  }, [selectedIndex, results.length]);

  if (results.length === 0) {
    return null;
  }

  return (
    <div
      ref={listRef}
      className="flex flex-col py-2 max-h-[360px] overflow-y-auto"
    >
      <AnimatePresence mode="popLayout">
        {results.map((result, index) => (
          <ResultItem
            key={result.id}
            result={result}
            isSelected={index === selectedIndex}
            index={index}
            onSelect={() => setSelectedIndex(index)}
            onExecute={executeSelected}
          />
        ))}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="apps/launcher/src/components/SearchInput.tsx">
import { useRef, useEffect } from "react";
import { Search } from "lucide-react";
import { useLauncherStore } from "@/stores/launcher";
import { cn } from "@/lib/utils";

export function SearchInput() {
  const inputRef = useRef<HTMLInputElement>(null);
  const { query, setQuery, moveSelection, executeSelected, hideWindow } =
    useLauncherStore();

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        moveSelection("up");
        break;
      case "ArrowDown":
        e.preventDefault();
        moveSelection("down");
        break;
      case "Enter":
        e.preventDefault();
        executeSelected();
        break;
      case "Escape":
        e.preventDefault();
        hideWindow();
        break;
    }
  };

  return (
    <div className="relative flex items-center px-4 py-3">
      <Search
        className={cn(
          "absolute left-6 h-5 w-5 text-muted-foreground transition-colors",
          query && "text-foreground"
        )}
      />
      <input
        ref={inputRef}
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Search apps, files, or type a calculation..."
        className={cn(
          "w-full bg-transparent pl-10 pr-4 py-2 text-lg",
          "placeholder:text-muted-foreground/60",
          "focus:outline-none",
          "text-foreground"
        )}
        autoFocus
        spellCheck={false}
        autoComplete="off"
        autoCorrect="off"
        autoCapitalize="off"
      />
    </div>
  );
}
</file>

<file path="apps/launcher/src/components/Settings.tsx">
import { useState, useEffect } from "react";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { openUrl } from "@tauri-apps/plugin-opener";
import { Settings as SettingsIcon, X, FolderOpen, Plug, HardDrive, Link2, ExternalLink, Check, Loader2, ChevronDown, ChevronUp, Save, Plus, Trash2, RefreshCw, Store, Download, Star, Search } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import type { IndexConfig, PluginManifest, OAuthProviderInfo, OAuthCredentials, RegistryPlugin, PluginUpdate } from "@/types";
import { cn } from "@/lib/utils";

interface SettingsProps {
  isOpen: boolean;
  onClose: () => void;
}

export function Settings({ isOpen, onClose }: SettingsProps) {
  const [activeTab, setActiveTab] = useState<"index" | "plugins" | "marketplace" | "accounts">("index");
  const [indexConfig, setIndexConfig] = useState<IndexConfig | null>(null);
  const [plugins, setPlugins] = useState<PluginManifest[]>([]);
  const [pluginsDir, setPluginsDir] = useState<string>("");
  const [oauthProviders, setOauthProviders] = useState<OAuthProviderInfo[]>([]);

  useEffect(() => {
    if (isOpen) {
      loadSettings();
    }
  }, [isOpen]);

  const loadSettings = async () => {
    try {
      const [config, pluginList, dir, providers] = await Promise.all([
        invoke<IndexConfig>("get_index_config"),
        invoke<PluginManifest[]>("list_plugins"),
        invoke<string>("get_plugins_dir"),
        invoke<OAuthProviderInfo[]>("list_oauth_providers"),
      ]);
      setIndexConfig(config);
      setPlugins(pluginList);
      setPluginsDir(dir);
      setOauthProviders(providers);
    } catch (error) {
      console.error("Failed to load settings:", error);
    }
  };

  const tabs = [
    { id: "index" as const, label: "File Index", icon: HardDrive },
    { id: "plugins" as const, label: "Plugins", icon: Plug },
    { id: "marketplace" as const, label: "Marketplace", icon: Store },
    { id: "accounts" as const, label: "Accounts", icon: Link2 },
  ];

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-center justify-center bg-black/50"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            onClick={(e) => e.stopPropagation()}
            className={cn(
              "w-full max-w-2xl max-h-[80vh]",
              "bg-(--launcher-bg) backdrop-blur-(--launcher-blur)",
              "border border-(--launcher-border)",
              "rounded-xl shadow-2xl overflow-hidden"
            )}
          >
            <div className="flex items-center justify-between px-4 py-3 border-b border-border/30">
              <div className="flex items-center gap-2">
                <SettingsIcon className="h-5 w-5 text-muted-foreground" />
                <h2 className="text-lg font-semibold">Settings</h2>
              </div>
              <button
                onClick={onClose}
                className="p-1 rounded-md hover:bg-muted/50 transition-colors"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            <div className="flex">
              <div className="w-48 border-r border-border/30 p-2">
                {tabs.map((tab) => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={cn(
                      "w-full flex items-center gap-2 px-3 py-2 rounded-md text-sm transition-colors",
                      activeTab === tab.id
                        ? "bg-primary/10 text-primary"
                        : "hover:bg-muted/50 text-muted-foreground"
                    )}
                  >
                    <tab.icon className="h-4 w-4" />
                    {tab.label}
                  </button>
                ))}
              </div>

              <div className="flex-1 p-4 overflow-y-auto max-h-[60vh]">
                {activeTab === "index" && indexConfig && (
                  <IndexSettings config={indexConfig} onConfigChange={setIndexConfig} />
                )}
                {activeTab === "plugins" && (
                  <PluginSettings plugins={plugins} pluginsDir={pluginsDir} onRefresh={loadSettings} />
                )}
                {activeTab === "marketplace" && (
                  <MarketplaceSettings installedPlugins={plugins} onRefresh={loadSettings} />
                )}
                {activeTab === "accounts" && (
                  <AccountsSettings providers={oauthProviders} onRefresh={loadSettings} />
                )}
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

function IndexSettings({ config, onConfigChange }: { config: IndexConfig; onConfigChange: (config: IndexConfig) => void }) {
  const [newPath, setNewPath] = useState("");
  const [newPattern, setNewPattern] = useState("");
  const [newExtension, setNewExtension] = useState("");
  const [saving, setSaving] = useState(false);
  const [reindexing, setReindexing] = useState(false);

  const handleAddPath = () => {
    if (newPath.trim() && !config.index_paths.includes(newPath.trim())) {
      onConfigChange({
        ...config,
        index_paths: [...config.index_paths, newPath.trim()],
      });
      setNewPath("");
    }
  };

  const handleRemovePath = (index: number) => {
    onConfigChange({
      ...config,
      index_paths: config.index_paths.filter((_, i) => i !== index),
    });
  };

  const handleAddPattern = () => {
    if (newPattern.trim() && !config.exclude_patterns.includes(newPattern.trim())) {
      onConfigChange({
        ...config,
        exclude_patterns: [...config.exclude_patterns, newPattern.trim()],
      });
      setNewPattern("");
    }
  };

  const handleRemovePattern = (index: number) => {
    onConfigChange({
      ...config,
      exclude_patterns: config.exclude_patterns.filter((_, i) => i !== index),
    });
  };

  const handleAddExtension = () => {
    const ext = newExtension.trim().replace(/^\./, "");
    if (ext && !config.content_extensions.includes(ext)) {
      onConfigChange({
        ...config,
        content_extensions: [...config.content_extensions, ext],
      });
      setNewExtension("");
    }
  };

  const handleRemoveExtension = (index: number) => {
    onConfigChange({
      ...config,
      content_extensions: config.content_extensions.filter((_, i) => i !== index),
    });
  };

  const handleToggle = (field: "exclude_hidden" | "index_content") => {
    onConfigChange({
      ...config,
      [field]: !config[field],
    });
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      await invoke("set_index_config", { config });
    } catch (error) {
      console.error("Failed to save config:", error);
    } finally {
      setSaving(false);
    }
  };

  const handleReindex = async () => {
    setReindexing(true);
    try {
      await invoke("start_indexing");
    } catch (error) {
      console.error("Failed to start reindexing:", error);
    } finally {
      setReindexing(false);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-sm font-medium mb-2 flex items-center gap-2">
          <FolderOpen className="h-4 w-4" />
          Indexed Directories
        </h3>
        <div className="space-y-1">
          {config.index_paths.map((path, i) => (
            <div
              key={i}
              className="flex items-center justify-between px-3 py-2 bg-muted/30 rounded-md text-sm font-mono group"
            >
              <span className="truncate">{path}</span>
              <button
                onClick={() => handleRemovePath(i)}
                className="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-500/20 rounded transition-all"
              >
                <Trash2 className="h-3 w-3 text-red-400" />
              </button>
            </div>
          ))}
          <div className="flex gap-2 mt-2">
            <input
              type="text"
              value={newPath}
              onChange={(e) => setNewPath(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleAddPath()}
              placeholder="/path/to/directory"
              className="flex-1 px-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50 font-mono"
            />
            <button
              onClick={handleAddPath}
              className="px-3 py-2 bg-primary/10 text-primary rounded-md hover:bg-primary/20 transition-colors"
            >
              <Plus className="h-4 w-4" />
            </button>
          </div>
        </div>
      </div>

      <div>
        <h3 className="text-sm font-medium mb-2">Excluded Patterns</h3>
        <div className="flex flex-wrap gap-1">
          {config.exclude_patterns.map((pattern, i) => (
            <span
              key={i}
              className="px-2 py-1 bg-muted/30 rounded text-xs font-mono flex items-center gap-1 group"
            >
              {pattern}
              <button
                onClick={() => handleRemovePattern(i)}
                className="opacity-0 group-hover:opacity-100 hover:text-red-400 transition-all"
              >
                <X className="h-3 w-3" />
              </button>
            </span>
          ))}
        </div>
        <div className="flex gap-2 mt-2">
          <input
            type="text"
            value={newPattern}
            onChange={(e) => setNewPattern(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && handleAddPattern()}
            placeholder="node_modules"
            className="flex-1 px-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50 font-mono"
          />
          <button
            onClick={handleAddPattern}
            className="px-3 py-2 bg-primary/10 text-primary rounded-md hover:bg-primary/20 transition-colors"
          >
            <Plus className="h-4 w-4" />
          </button>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <button
          onClick={() => handleToggle("exclude_hidden")}
          className="flex items-center justify-between p-3 bg-muted/20 rounded-md hover:bg-muted/30 transition-colors"
        >
          <span className="text-sm">Exclude hidden files</span>
          <span className={cn(
            "text-xs px-2 py-0.5 rounded",
            config.exclude_hidden ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"
          )}>
            {config.exclude_hidden ? "Yes" : "No"}
          </span>
        </button>
        <button
          onClick={() => handleToggle("index_content")}
          className="flex items-center justify-between p-3 bg-muted/20 rounded-md hover:bg-muted/30 transition-colors"
        >
          <span className="text-sm">Index content</span>
          <span className={cn(
            "text-xs px-2 py-0.5 rounded",
            config.index_content ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"
          )}>
            {config.index_content ? "Yes" : "No"}
          </span>
        </button>
        <div className="flex items-center justify-between p-3 bg-muted/20 rounded-md col-span-2">
          <span className="text-sm">Max file size</span>
          <span className="text-xs font-mono">{config.max_file_size_mb} MB</span>
        </div>
      </div>

      <div>
        <h3 className="text-sm font-medium mb-2">Content-indexed extensions</h3>
        <div className="flex flex-wrap gap-1">
          {config.content_extensions.map((ext, i) => (
            <span
              key={i}
              className="px-2 py-1 bg-primary/10 text-primary rounded text-xs font-mono flex items-center gap-1 group"
            >
              .{ext}
              <button
                onClick={() => handleRemoveExtension(i)}
                className="opacity-0 group-hover:opacity-100 hover:text-red-400 transition-all"
              >
                <X className="h-3 w-3" />
              </button>
            </span>
          ))}
        </div>
        <div className="flex gap-2 mt-2">
          <input
            type="text"
            value={newExtension}
            onChange={(e) => setNewExtension(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && handleAddExtension()}
            placeholder=".json"
            className="flex-1 px-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50 font-mono"
          />
          <button
            onClick={handleAddExtension}
            className="px-3 py-2 bg-primary/10 text-primary rounded-md hover:bg-primary/20 transition-colors"
          >
            <Plus className="h-4 w-4" />
          </button>
        </div>
      </div>

      <div className="flex gap-2 pt-2 border-t border-border/20">
        <button
          onClick={handleSave}
          disabled={saving}
          className={cn(
            "flex-1 px-4 py-2 rounded-md transition-colors flex items-center justify-center gap-2",
            "bg-green-500/10 text-green-400 hover:bg-green-500/20",
            saving && "opacity-50 cursor-not-allowed"
          )}
        >
          {saving ? <Loader2 className="h-4 w-4 animate-spin" /> : <Save className="h-4 w-4" />}
          Save Changes
        </button>
        <button
          onClick={handleReindex}
          disabled={reindexing}
          className={cn(
            "px-4 py-2 rounded-md transition-colors flex items-center gap-2",
            "bg-primary/10 text-primary hover:bg-primary/20",
            reindexing && "opacity-50 cursor-not-allowed"
          )}
        >
          {reindexing ? <Loader2 className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
          Reindex
        </button>
      </div>
    </div>
  );
}

function PluginSettings({ plugins, pluginsDir, onRefresh }: { plugins: PluginManifest[]; pluginsDir: string; onRefresh: () => void }) {
  const [toggling, setToggling] = useState<string | null>(null);
  const [updates, setUpdates] = useState<PluginUpdate[]>([]);
  const [checkingUpdates, setCheckingUpdates] = useState(false);
  const [updating, setUpdating] = useState<string | null>(null);

  useEffect(() => {
    checkForUpdates();
  }, [plugins]);

  const checkForUpdates = async () => {
    setCheckingUpdates(true);
    try {
      const availableUpdates = await invoke<PluginUpdate[]>("check_plugin_updates");
      setUpdates(availableUpdates);
    } catch (error) {
      console.error("Failed to check for updates:", error);
    } finally {
      setCheckingUpdates(false);
    }
  };

  const handleUpdate = async (pluginId: string) => {
    setUpdating(pluginId);
    try {
      await invoke("update_plugin", { id: pluginId });
      onRefresh();
      checkForUpdates();
    } catch (error) {
      console.error("Failed to update plugin:", error);
    } finally {
      setUpdating(null);
    }
  };

  const getUpdateForPlugin = (pluginId: string) => updates.find(u => u.id === pluginId);

  const handleToggle = async (pluginId: string, currentEnabled: boolean) => {
    setToggling(pluginId);
    try {
      if (currentEnabled) {
        await invoke("disable_plugin", { id: pluginId });
      } else {
        await invoke("enable_plugin", { id: pluginId });
      }
      onRefresh();
    } catch (error) {
      console.error("Failed to toggle plugin:", error);
    } finally {
      setToggling(null);
    }
  };

  return (
    <div className="space-y-4">
      <div className="text-xs text-muted-foreground font-mono bg-muted/20 px-3 py-2 rounded">
        {pluginsDir}
      </div>

      {plugins.length === 0 ? (
        <div className="text-center py-8 text-muted-foreground">
          <Plug className="h-8 w-8 mx-auto mb-2 opacity-50" />
          <p>No plugins installed</p>
          <p className="text-xs mt-1">
            Place plugin folders in the directory above
          </p>
        </div>
      ) : (
        <div className="space-y-2">
          {plugins.map((plugin) => (
            <div
              key={plugin.id}
              className={cn(
                "p-3 rounded-md transition-colors",
                plugin.enabled ? "bg-muted/20" : "bg-muted/10 opacity-60"
              )}
            >
              <div className="flex items-center justify-between">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <h4 className="font-medium">{plugin.name}</h4>
                    <span className="text-xs font-mono text-muted-foreground">
                      v{plugin.version}
                    </span>
                    {getUpdateForPlugin(plugin.id) && (
                      <span className="text-xs px-1.5 py-0.5 bg-yellow-500/20 text-yellow-400 rounded">
                        Update: v{getUpdateForPlugin(plugin.id)?.latest_version}
                      </span>
                    )}
                  </div>
                  <p className="text-xs text-muted-foreground truncate">
                    {plugin.description || "No description"}
                  </p>
                  {plugin.author && (
                    <p className="text-xs text-muted-foreground mt-0.5">
                      by {plugin.author}
                    </p>
                  )}
                </div>
                <div className="flex items-center gap-2 ml-3">
                  {getUpdateForPlugin(plugin.id) && (
                    <button
                      onClick={() => handleUpdate(plugin.id)}
                      disabled={updating === plugin.id}
                      className={cn(
                        "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                        "bg-yellow-500/10 text-yellow-400 hover:bg-yellow-500/20",
                        updating === plugin.id && "opacity-50 cursor-not-allowed"
                      )}
                    >
                      {updating === plugin.id ? (
                        <Loader2 className="h-3 w-3 animate-spin" />
                      ) : (
                        <Download className="h-3 w-3" />
                      )}
                      Update
                    </button>
                  )}
                  <button
                    onClick={() => handleToggle(plugin.id, plugin.enabled)}
                    disabled={toggling === plugin.id}
                    className={cn(
                      "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                      plugin.enabled
                        ? "bg-green-500/10 text-green-400 hover:bg-green-500/20"
                        : "bg-muted/30 text-muted-foreground hover:bg-muted/50",
                      toggling === plugin.id && "opacity-50 cursor-not-allowed"
                    )}
                  >
                    {toggling === plugin.id ? (
                      <Loader2 className="h-3 w-3 animate-spin" />
                    ) : plugin.enabled ? (
                      <Check className="h-3 w-3" />
                    ) : null}
                    {plugin.enabled ? "Enabled" : "Disabled"}
                  </button>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function AccountsSettings({ providers, onRefresh }: { providers: OAuthProviderInfo[]; onRefresh: () => void }) {
  const [connecting, setConnecting] = useState<string | null>(null);
  const [expandedProvider, setExpandedProvider] = useState<string | null>(null);
  const [credentials, setCredentials] = useState<Record<string, OAuthCredentials>>({});
  const [saving, setSaving] = useState<string | null>(null);
  
  // Web auth state
  const [webAuthState, setWebAuthState] = useState<{ is_authenticated: boolean; user: { id: string; email: string | null; name: string | null; avatar: string | null } | null } | null>(null);
  const [webAuthLoading, setWebAuthLoading] = useState(false);

  useEffect(() => {
    loadWebAuthState();
    
    // Listen for auth callback to refresh state immediately
    let unlisten: (() => void) | undefined;
    listen<string>("auth-callback", () => {
      // Small delay to ensure the backend has processed the token
      setTimeout(() => {
        loadWebAuthState();
      }, 500);
    }).then((fn) => {
      unlisten = fn;
    });
    
    return () => {
      if (unlisten) unlisten();
    };
  }, []);

  const loadWebAuthState = async () => {
    try {
      const state = await invoke<{ is_authenticated: boolean; user: { id: string; email: string | null; name: string | null; avatar: string | null } | null }>("get_auth_state");
      setWebAuthState(state);
    } catch (error) {
      console.error("Failed to load web auth state:", error);
    }
  };

  const handleWebLogin = async () => {
    setWebAuthLoading(true);
    try {
      await invoke("open_login");
      // Auth completion happens via deep link callback
    } catch (error) {
      console.error("Failed to open login:", error);
    } finally {
      setWebAuthLoading(false);
    }
  };

  const handleWebLogout = async () => {
    setWebAuthLoading(true);
    try {
      const state = await invoke<{ is_authenticated: boolean; user: { id: string; email: string | null; name: string | null; avatar: string | null } | null }>("logout");
      setWebAuthState(state);
    } catch (error) {
      console.error("Failed to logout:", error);
    } finally {
      setWebAuthLoading(false);
    }
  };

  const loadCredentials = async (providerId: string) => {
    try {
      const creds = await invoke<OAuthCredentials>("get_oauth_credentials", { providerId });
      setCredentials(prev => ({ ...prev, [providerId]: creds }));
    } catch (error) {
      console.error("Failed to load credentials:", error);
    }
  };

  const handleToggleExpand = async (providerId: string) => {
    if (expandedProvider === providerId) {
      setExpandedProvider(null);
    } else {
      setExpandedProvider(providerId);
      if (!credentials[providerId]) {
        await loadCredentials(providerId);
      }
    }
  };

  const handleSaveCredentials = async (providerId: string) => {
    setSaving(providerId);
    try {
      const creds = credentials[providerId];
      await invoke("set_oauth_credentials", {
        providerId,
        clientId: creds?.client_id || null,
        clientSecret: creds?.client_secret || null,
      });
      onRefresh();
    } catch (error) {
      console.error("Failed to save credentials:", error);
    } finally {
      setSaving(null);
    }
  };

  const handleConnect = async (providerId: string) => {
    setConnecting(providerId);
    try {
      const authUrl = await invoke<string>("start_oauth", { providerId });
      await openUrl(authUrl);
    } catch (error) {
      console.error("Failed to start OAuth:", error);
    } finally {
      setConnecting(null);
    }
  };

  const handleDisconnect = async (providerId: string) => {
    try {
      await invoke("disconnect_oauth", { providerId });
      onRefresh();
    } catch (error) {
      console.error("Failed to disconnect:", error);
    }
  };

  const providerIcons: Record<string, string> = {
    github: "ðŸ™",
    google: "ðŸ”µ",
    notion: "ðŸ“",
    slack: "ðŸ’¬",
  };

  const providerDocs: Record<string, string> = {
    github: "https://github.com/settings/developers",
    google: "https://console.cloud.google.com/apis/credentials",
    notion: "https://www.notion.so/my-integrations",
    slack: "https://api.slack.com/apps",
  };

  return (
    <div className="space-y-4">
      {/* Launcher Account Section */}
      <div className="bg-muted/20 rounded-md p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-full bg-primary/20 flex items-center justify-center">
              {webAuthState?.user?.avatar ? (
                <img src={webAuthState.user.avatar} alt="" className="w-10 h-10 rounded-full" />
              ) : (
                <span className="text-xl">ðŸš€</span>
              )}
            </div>
            <div>
              <h4 className="font-medium">Launcher Account</h4>
              {webAuthState?.is_authenticated ? (
                <p className="text-xs text-muted-foreground">
                  <span className="flex items-center gap-1 text-green-400">
                    <Check className="h-3 w-3" /> {webAuthState.user?.email || webAuthState.user?.name || "Connected"}
                  </span>
                </p>
              ) : (
                <p className="text-xs text-muted-foreground">Sign in to sync settings and plugins</p>
              )}
            </div>
          </div>
          <div>
            {webAuthState?.is_authenticated ? (
              <button
                onClick={handleWebLogout}
                disabled={webAuthLoading}
                className="px-3 py-1.5 text-xs rounded-md bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-colors flex items-center gap-1"
              >
                {webAuthLoading ? <Loader2 className="h-3 w-3 animate-spin" /> : null}
                Sign Out
              </button>
            ) : (
              <button
                onClick={handleWebLogin}
                disabled={webAuthLoading}
                className="px-3 py-1.5 text-xs rounded-md bg-primary/10 text-primary hover:bg-primary/20 transition-colors flex items-center gap-1"
              >
                {webAuthLoading ? <Loader2 className="h-3 w-3 animate-spin" /> : <ExternalLink className="h-3 w-3" />}
                Sign In
              </button>
            )}
          </div>
        </div>
      </div>

      <div className="border-t border-border/30 pt-4">
        <p className="text-sm text-muted-foreground mb-3">
          Connect external services for search integrations.
        </p>
      </div>

      <div className="space-y-2">
        {providers.map((provider) => {
          const isExpanded = expandedProvider === provider.id;
          const creds = credentials[provider.id];
          const hasCredentials = creds?.client_id && creds.client_id.length > 0;

          return (
            <div
              key={provider.id}
              className="bg-muted/20 rounded-md overflow-hidden"
            >
              <div className="flex items-center justify-between p-3">
                <div className="flex items-center gap-3">
                  <span className="text-2xl">{providerIcons[provider.id] || "ðŸ”—"}</span>
                  <div>
                    <h4 className="font-medium">{provider.name}</h4>
                    <p className="text-xs text-muted-foreground">
                      {provider.connected ? (
                        <span className="flex items-center gap-1 text-green-400">
                          <Check className="h-3 w-3" /> Connected
                        </span>
                      ) : hasCredentials ? (
                        "Ready to connect"
                      ) : (
                        "Credentials required"
                      )}
                    </p>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  {provider.connected ? (
                    <button
                      onClick={() => handleDisconnect(provider.id)}
                      className="px-3 py-1.5 text-xs rounded-md bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-colors"
                    >
                      Disconnect
                    </button>
                  ) : hasCredentials ? (
                    <button
                      onClick={() => handleConnect(provider.id)}
                      disabled={connecting === provider.id}
                      className={cn(
                        "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                        "bg-primary/10 text-primary hover:bg-primary/20",
                        connecting === provider.id && "opacity-50 cursor-not-allowed"
                      )}
                    >
                      {connecting === provider.id ? (
                        <>
                          <Loader2 className="h-3 w-3 animate-spin" />
                          Connecting...
                        </>
                      ) : (
                        <>
                          <ExternalLink className="h-3 w-3" />
                          Connect
                        </>
                      )}
                    </button>
                  ) : null}
                  <button
                    onClick={() => handleToggleExpand(provider.id)}
                    className="p-1.5 rounded-md hover:bg-muted/50 transition-colors"
                  >
                    {isExpanded ? (
                      <ChevronUp className="h-4 w-4" />
                    ) : (
                      <ChevronDown className="h-4 w-4" />
                    )}
                  </button>
                </div>
              </div>

              {isExpanded && (
                <div className="px-3 pb-3 pt-1 border-t border-border/20">
                  <div className="space-y-3">
                    <div>
                      <label className="text-xs text-muted-foreground block mb-1">
                        Client ID
                      </label>
                      <input
                        type="text"
                        value={creds?.client_id || ""}
                        onChange={(e) => setCredentials(prev => ({
                          ...prev,
                          [provider.id]: { ...prev[provider.id], client_id: e.target.value || null }
                        }))}
                        placeholder="Enter client ID"
                        className="w-full px-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50"
                      />
                    </div>
                    <div>
                      <label className="text-xs text-muted-foreground block mb-1">
                        Client Secret (optional for PKCE)
                      </label>
                      <input
                        type="password"
                        value={creds?.client_secret || ""}
                        onChange={(e) => setCredentials(prev => ({
                          ...prev,
                          [provider.id]: { ...prev[provider.id], client_secret: e.target.value || null }
                        }))}
                        placeholder="Enter client secret"
                        className="w-full px-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50"
                      />
                    </div>
                    <div className="flex items-center justify-between pt-1">
                      <a
                        href={providerDocs[provider.id]}
                        onClick={(e) => {
                          e.preventDefault();
                          openUrl(providerDocs[provider.id]);
                        }}
                        className="text-xs text-primary hover:underline flex items-center gap-1"
                      >
                        <ExternalLink className="h-3 w-3" />
                        Get credentials
                      </a>
                      <button
                        onClick={() => handleSaveCredentials(provider.id)}
                        disabled={saving === provider.id}
                        className={cn(
                          "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                          "bg-green-500/10 text-green-400 hover:bg-green-500/20",
                          saving === provider.id && "opacity-50 cursor-not-allowed"
                        )}
                      >
                        {saving === provider.id ? (
                          <Loader2 className="h-3 w-3 animate-spin" />
                        ) : (
                          <Save className="h-3 w-3" />
                        )}
                        Save
                      </button>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Redirect URI: <code className="bg-muted/30 px-1 rounded">http://localhost:19284/oauth/callback</code>
                    </p>
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {providers.length === 0 && (
        <div className="text-center py-8 text-muted-foreground">
          <Link2 className="h-8 w-8 mx-auto mb-2 opacity-50" />
          <p>No OAuth providers available</p>
        </div>
      )}
    </div>
  );
}

function MarketplaceSettings({ installedPlugins, onRefresh }: { installedPlugins: PluginManifest[]; onRefresh: () => void }) {
  const [marketplacePlugins, setMarketplacePlugins] = useState<RegistryPlugin[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [installing, setInstalling] = useState<string | null>(null);
  const [uninstalling, setUninstalling] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const installedIds = new Set(installedPlugins.map(p => p.id));

  useEffect(() => {
    loadMarketplace();
  }, []);

  const loadMarketplace = async () => {
    setLoading(true);
    try {
      const [plugins, cats] = await Promise.all([
        invoke<RegistryPlugin[]>("list_marketplace_plugins"),
        invoke<string[]>("get_marketplace_categories"),
      ]);
      setMarketplacePlugins(plugins);
      setCategories(cats);
    } catch (error) {
      console.error("Failed to load marketplace:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await invoke("refresh_marketplace");
      await loadMarketplace();
    } catch (error) {
      console.error("Failed to refresh marketplace:", error);
    } finally {
      setRefreshing(false);
    }
  };

  const handleSearch = async () => {
    if (!searchQuery.trim()) {
      loadMarketplace();
      return;
    }
    try {
      const results = await invoke<RegistryPlugin[]>("search_marketplace", { query: searchQuery });
      setMarketplacePlugins(results);
    } catch (error) {
      console.error("Failed to search marketplace:", error);
    }
  };

  const handleInstall = async (pluginId: string) => {
    setInstalling(pluginId);
    try {
      await invoke("install_plugin", { id: pluginId });
      onRefresh();
    } catch (error) {
      console.error("Failed to install plugin:", error);
    } finally {
      setInstalling(null);
    }
  };

  const handleUninstall = async (pluginId: string) => {
    setUninstalling(pluginId);
    try {
      await invoke("uninstall_plugin", { id: pluginId });
      onRefresh();
    } catch (error) {
      console.error("Failed to uninstall plugin:", error);
    } finally {
      setUninstalling(null);
    }
  };

  const filteredPlugins = selectedCategory
    ? marketplacePlugins.filter(p => p.categories.includes(selectedCategory))
    : marketplacePlugins;

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex gap-2">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && handleSearch()}
            placeholder="Search plugins..."
            className="w-full pl-9 pr-3 py-2 text-sm bg-background/50 border border-border/30 rounded-md focus:outline-none focus:ring-1 focus:ring-primary/50"
          />
        </div>
        <button
          onClick={handleSearch}
          className="px-3 py-2 bg-primary/10 text-primary rounded-md hover:bg-primary/20 transition-colors"
        >
          <Search className="h-4 w-4" />
        </button>
        <button
          onClick={handleRefresh}
          disabled={refreshing}
          className={cn(
            "px-3 py-2 bg-muted/30 text-muted-foreground rounded-md hover:bg-muted/50 transition-colors",
            refreshing && "opacity-50 cursor-not-allowed"
          )}
          title="Refresh from server"
        >
          {refreshing ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="h-4 w-4" />
          )}
        </button>
      </div>

      <div className="flex gap-1 flex-wrap">
        <button
          onClick={() => setSelectedCategory(null)}
          className={cn(
            "px-2 py-1 text-xs rounded-md transition-colors",
            selectedCategory === null
              ? "bg-primary/20 text-primary"
              : "bg-muted/30 text-muted-foreground hover:bg-muted/50"
          )}
        >
          All
        </button>
        {categories.map((cat) => (
          <button
            key={cat}
            onClick={() => setSelectedCategory(cat)}
            className={cn(
              "px-2 py-1 text-xs rounded-md transition-colors",
              selectedCategory === cat
                ? "bg-primary/20 text-primary"
                : "bg-muted/30 text-muted-foreground hover:bg-muted/50"
            )}
          >
            {cat}
          </button>
        ))}
      </div>

      {filteredPlugins.length === 0 ? (
        <div className="text-center py-8 text-muted-foreground">
          <Store className="h-8 w-8 mx-auto mb-2 opacity-50" />
          <p>No plugins found</p>
        </div>
      ) : (
        <div className="space-y-2">
          {filteredPlugins.map((plugin) => {
            const isInstalled = installedIds.has(plugin.id);
            return (
              <div
                key={plugin.id}
                className="p-3 bg-muted/20 rounded-md"
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <h4 className="font-medium">{plugin.name}</h4>
                      <span className="text-xs font-mono text-muted-foreground">
                        v{plugin.version}
                      </span>
                      {isInstalled && (
                        <span className="text-xs px-1.5 py-0.5 bg-green-500/20 text-green-400 rounded">
                          Installed
                        </span>
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground mt-0.5">
                      {plugin.description || "No description"}
                    </p>
                    <div className="flex items-center gap-3 mt-1.5 text-xs text-muted-foreground">
                      {plugin.author && (
                        <span>by {plugin.author}</span>
                      )}
                      {plugin.rating && (
                        <span className="flex items-center gap-0.5">
                          <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
                          {plugin.rating.toFixed(1)}
                        </span>
                      )}
                      {plugin.downloads > 0 && (
                        <span className="flex items-center gap-0.5">
                          <Download className="h-3 w-3" />
                          {plugin.downloads.toLocaleString()}
                        </span>
                      )}
                    </div>
                    {plugin.categories.length > 0 && (
                      <div className="flex gap-1 mt-1.5">
                        {plugin.categories.map((cat) => (
                          <span
                            key={cat}
                            className="px-1.5 py-0.5 text-[10px] bg-muted/40 rounded"
                          >
                            {cat}
                          </span>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="ml-3">
                    {isInstalled ? (
                      <button
                        onClick={() => handleUninstall(plugin.id)}
                        disabled={uninstalling === plugin.id}
                        className={cn(
                          "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                          "bg-red-500/10 text-red-400 hover:bg-red-500/20",
                          uninstalling === plugin.id && "opacity-50 cursor-not-allowed"
                        )}
                      >
                        {uninstalling === plugin.id ? (
                          <Loader2 className="h-3 w-3 animate-spin" />
                        ) : (
                          <Trash2 className="h-3 w-3" />
                        )}
                        Uninstall
                      </button>
                    ) : (
                      <button
                        onClick={() => handleInstall(plugin.id)}
                        disabled={installing === plugin.id}
                        className={cn(
                          "px-3 py-1.5 text-xs rounded-md transition-colors flex items-center gap-1",
                          "bg-primary/10 text-primary hover:bg-primary/20",
                          installing === plugin.id && "opacity-50 cursor-not-allowed"
                        )}
                      >
                        {installing === plugin.id ? (
                          <Loader2 className="h-3 w-3 animate-spin" />
                        ) : (
                          <Download className="h-3 w-3" />
                        )}
                        Install
                      </button>
                    )}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}
</file>

<file path="apps/launcher/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="apps/launcher/src/stores/auth.ts">
import { create } from "zustand";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";

interface User {
  id: string;
  email: string | null;
  name: string | null;
  avatar: string | null;
}

interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  isLoading: boolean;
  error: string | null;

  initialize: () => Promise<void>;
  login: () => Promise<void>;
  logout: () => Promise<void>;
  setupAuthListener: () => Promise<() => void>;
}

interface TauriAuthState {
  is_authenticated: boolean;
  user: {
    id: string;
    email: string | null;
    name: string | null;
    avatar: string | null;
  } | null;
}

export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  user: null,
  isLoading: true,
  error: null,

  initialize: async () => {
    set({ isLoading: true, error: null });
    try {
      const authState = await invoke<TauriAuthState>("get_auth_state");
      set({
        isAuthenticated: authState.is_authenticated,
        user: authState.user,
        isLoading: false,
      });
    } catch (error) {
      console.error("Failed to initialize auth:", error);
      set({ isLoading: false, error: String(error) });
    }
  },

  login: async () => {
    set({ isLoading: true, error: null });
    try {
      await invoke("open_login");
      // The actual auth completion happens via deep link callback
      // which triggers the auth-callback event
    } catch (error) {
      console.error("Failed to open login:", error);
      set({ isLoading: false, error: String(error) });
    }
  },

  logout: async () => {
    set({ isLoading: true, error: null });
    try {
      const authState = await invoke<TauriAuthState>("logout");
      set({
        isAuthenticated: authState.is_authenticated,
        user: authState.user,
        isLoading: false,
      });
    } catch (error) {
      console.error("Failed to logout:", error);
      set({ isLoading: false, error: String(error) });
    }
  },

  setupAuthListener: async () => {
    // Listen for auth callback from deep link
    const unlisten = await listen<string>("auth-callback", async (event) => {
      const token = event.payload;
      console.log("Received auth callback with token");
      
      set({ isLoading: true, error: null });
      try {
        const authState = await invoke<TauriAuthState>("handle_auth_callback", { token });
        set({
          isAuthenticated: authState.is_authenticated,
          user: authState.user,
          isLoading: false,
        });
      } catch (error) {
        console.error("Failed to handle auth callback:", error);
        set({ isLoading: false, error: String(error) });
      }
    });

    return unlisten;
  },
}));
</file>

<file path="apps/launcher/src/stores/launcher.ts">
import { create } from "zustand";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import type { SearchResult, SystemTheme, IndexingStatus } from "@/types";

interface LauncherState {
  query: string;
  results: SearchResult[];
  selectedIndex: number;
  isLoading: boolean;
  theme: SystemTheme | null;
  indexingStatus: IndexingStatus | null;

  setQuery: (query: string) => void;
  search: (query: string) => Promise<void>;
  setSelectedIndex: (index: number) => void;
  moveSelection: (direction: "up" | "down") => void;
  executeSelected: () => Promise<void>;
  hideWindow: () => Promise<void>;
  loadTheme: () => Promise<void>;
  setupIndexingListener: () => Promise<void>;
  reset: () => void;
}

export const useLauncherStore = create<LauncherState>((set, get) => ({
  query: "",
  results: [],
  selectedIndex: 0,
  isLoading: false,
  theme: null,
  indexingStatus: null,

  setQuery: (query) => {
    set({ query });
    get().search(query);
  },

  search: async (query) => {
    if (!query.trim()) {
      set({ results: [], selectedIndex: 0 });
      return;
    }

    set({ isLoading: true });
    try {
      const results = await invoke<SearchResult[]>("search", { query });
      set({ results, selectedIndex: 0, isLoading: false });
    } catch (error) {
      console.error("Search error:", error);
      set({ results: [], isLoading: false });
    }
  },

  setSelectedIndex: (index) => set({ selectedIndex: index }),

  moveSelection: (direction) => {
    const { results, selectedIndex } = get();
    if (results.length === 0) return;

    let newIndex: number;
    if (direction === "up") {
      newIndex = selectedIndex <= 0 ? results.length - 1 : selectedIndex - 1;
    } else {
      newIndex = selectedIndex >= results.length - 1 ? 0 : selectedIndex + 1;
    }
    set({ selectedIndex: newIndex });
  },

  executeSelected: async () => {
    const { results, selectedIndex } = get();
    if (results.length === 0) return;

    const selected = results[selectedIndex];
    try {
      await invoke("execute_result", { resultId: selected.id });
      get().hideWindow();
    } catch (error) {
      console.error("Execute error:", error);
    }
  },

  hideWindow: async () => {
    try {
      await invoke("hide_window");
      get().reset();
    } catch (error) {
      console.error("Hide window error:", error);
    }
  },

  loadTheme: async () => {
    try {
      const theme = await invoke<SystemTheme>("get_system_theme");
      set({ theme });

      if (theme.accent_color) {
        document.documentElement.style.setProperty(
          "--system-accent",
          theme.accent_color
        );
      }
    } catch (error) {
      console.error("Load theme error:", error);
    }
  },

  setupIndexingListener: async () => {
    await listen<IndexingStatus>("indexing-status", (event) => {
      set({ indexingStatus: event.payload });
    });
  },

  reset: () => set({ query: "", results: [], selectedIndex: 0 }),
}));
</file>

<file path="apps/launcher/src/types/index.ts">
export interface SearchResult {
  id: string;
  title: string;
  subtitle: string | null;
  icon: ResultIcon;
  category: ResultCategory;
  score: number;
}

export type ResultIcon =
  | { type: "Text"; value: string }
  | { type: "Path"; value: string }
  | { type: "Emoji"; value: string };

export type ResultCategory =
  | "Calculator"
  | "Application"
  | "File"
  | "Command"
  | "Plugin"
  | "GitHub";

export interface SystemTheme {
  is_dark: boolean;
  accent_color: string | null;
  window_blur_supported: boolean;
}

export interface IndexingStatus {
  is_indexing: boolean;
  files_indexed: number;
  message: string;
}

export interface IndexConfig {
  index_paths: string[];
  exclude_patterns: string[];
  exclude_hidden: boolean;
  max_file_size_mb: number;
  index_content: boolean;
  content_extensions: string[];
}

export interface PluginInfo {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  permissions: string[];
  entry: string;
  enabled: boolean;
}

export type PluginManifest = PluginInfo;

export interface OAuthProviderInfo {
  id: string;
  name: string;
  connected: boolean;
}

export interface OAuthCredentials {
  client_id: string | null;
  client_secret: string | null;
}

export interface RegistryPlugin {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  homepage: string | null;
  repository: string | null;
  download_url: string;
  checksum: string | null;
  permissions: string[];
  categories: string[];
  downloads: number;
  rating: number | null;
}

export interface PluginUpdate {
  id: string;
  name: string;
  current_version: string;
  latest_version: string;
}
</file>

<file path="apps/launcher/src/App.tsx">
import { Launcher } from "@/components/Launcher";

function App() {
  return <Launcher />;
}

export default App;
</file>

<file path="apps/launcher/src/index.css">
@import "tailwindcss";

@theme {
  --color-background: oklch(0.145 0 0);
  --color-foreground: oklch(0.985 0 0);
  --color-card: oklch(0.145 0 0);
  --color-card-foreground: oklch(0.985 0 0);
  --color-popover: oklch(0.145 0 0);
  --color-popover-foreground: oklch(0.985 0 0);
  --color-primary: oklch(0.985 0 0);
  --color-primary-foreground: oklch(0.205 0 0);
  --color-secondary: oklch(0.269 0 0);
  --color-secondary-foreground: oklch(0.985 0 0);
  --color-muted: oklch(0.269 0 0);
  --color-muted-foreground: oklch(0.708 0 0);
  --color-accent: oklch(0.269 0 0);
  --color-accent-foreground: oklch(0.985 0 0);
  --color-destructive: oklch(0.396 0.141 25.723);
  --color-destructive-foreground: oklch(0.985 0 0);
  --color-border: oklch(0.269 0 0);
  --color-input: oklch(0.269 0 0);
  --color-ring: oklch(0.556 0 0);
  --radius: 0.625rem;

  /* Launcher-specific theme variables */
  --launcher-bg: oklch(0.12 0 0 / 0.85);
  --launcher-border: oklch(0.3 0 0 / 0.5);
  --launcher-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.5);
  --launcher-blur: 20px;
  
  /* System accent color (will be overridden by Rust) */
  --system-accent: oklch(0.6 0.15 250);
  --system-accent-foreground: oklch(0.98 0 0);
}

/* Base styles */
html {
  color-scheme: dark;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: transparent;
  margin: 0;
  padding: 0;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Prevent text selection in launcher UI */
.no-select {
  user-select: none;
  -webkit-user-select: none;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: oklch(0.4 0 0 / 0.5);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: oklch(0.5 0 0 / 0.7);
}
</file>

<file path="apps/launcher/src/main.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="apps/launcher/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="apps/launcher/src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default"
  ]
}
</file>

<file path="apps/launcher/src-tauri/src/indexer/config.rs">
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexConfig {
    pub index_paths: Vec<PathBuf>,
    pub exclude_patterns: Vec<String>,
    pub exclude_hidden: bool,
    pub max_file_size_mb: u64,
    pub index_content: bool,
    pub content_extensions: Vec<String>,
}

impl Default for IndexConfig {
    fn default() -> Self {
        let mut index_paths = Vec::new();

        if let Some(home) = dirs::home_dir() {
            index_paths.push(home.join("Documents"));
            index_paths.push(home.join("Downloads"));
            index_paths.push(home.join("Desktop"));
            index_paths.push(home.join("Projects"));
            index_paths.push(home.join("Development"));
        }

        Self {
            index_paths,
            exclude_patterns: vec![
                "node_modules".to_string(),
                ".git".to_string(),
                ".cache".to_string(),
                "__pycache__".to_string(),
                "target".to_string(),
                ".venv".to_string(),
                "venv".to_string(),
                ".npm".to_string(),
                "dist".to_string(),
                "build".to_string(),
                ".cargo".to_string(),
                ".rustup".to_string(),
            ],
            exclude_hidden: true,
            max_file_size_mb: 10,
            index_content: true,
            content_extensions: vec![
                "txt".to_string(),
                "md".to_string(),
                "rs".to_string(),
                "py".to_string(),
                "js".to_string(),
                "ts".to_string(),
                "tsx".to_string(),
                "jsx".to_string(),
                "json".to_string(),
                "yaml".to_string(),
                "yml".to_string(),
                "toml".to_string(),
                "html".to_string(),
                "css".to_string(),
                "sh".to_string(),
                "bash".to_string(),
                "zsh".to_string(),
            ],
        }
    }
}

impl IndexConfig {
    /// Returns the path to the config file
    fn config_path() -> PathBuf {
        dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("launcher")
            .join("index_config.json")
    }

    /// Load config from disk, or return default if not found
    pub fn load() -> Self {
        let path = Self::config_path();
        if path.exists() {
            match fs::read_to_string(&path) {
                Ok(contents) => {
                    match serde_json::from_str(&contents) {
                        Ok(config) => return config,
                        Err(e) => eprintln!("Failed to parse index config: {}", e),
                    }
                }
                Err(e) => eprintln!("Failed to read index config: {}", e),
            }
        }
        Self::default()
    }

    /// Save config to disk
    pub fn save(&self) -> Result<(), String> {
        let path = Self::config_path();
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).map_err(|e| e.to_string())?;
        }
        
        let contents = serde_json::to_string_pretty(self)
            .map_err(|e| e.to_string())?;
        fs::write(&path, contents).map_err(|e| e.to_string())?;
        
        Ok(())
    }

    pub fn should_exclude(&self, path: &std::path::Path) -> bool {
        let path_str = path.to_string_lossy();

        if self.exclude_hidden {
            if let Some(name) = path.file_name() {
                if name.to_string_lossy().starts_with('.') {
                    return true;
                }
            }
        }

        for pattern in &self.exclude_patterns {
            if path_str.contains(pattern) {
                return true;
            }
        }

        false
    }

    pub fn should_index_content(&self, path: &std::path::Path) -> bool {
        if !self.index_content {
            return false;
        }

        if let Some(ext) = path.extension() {
            let ext_str = ext.to_string_lossy().to_lowercase();
            return self.content_extensions.contains(&ext_str);
        }

        false
    }
}
</file>

<file path="apps/launcher/src-tauri/src/indexer/file_index.rs">
use super::config::IndexConfig;
use chrono::{DateTime, Utc};
use parking_lot::RwLock;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tantivy::collector::TopDocs;
use tantivy::query::QueryParser;
use tantivy::schema::*;
use tantivy::{Directory, Index, IndexReader, IndexWriter, ReloadPolicy};
use walkdir::WalkDir;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexedFile {
    pub path: String,
    pub name: String,
    pub extension: Option<String>,
    pub size: u64,
    pub modified: DateTime<Utc>,
    pub is_dir: bool,
}

pub struct FileIndexer {
    index: Index,
    reader: IndexReader,
    writer: Arc<RwLock<IndexWriter>>,
    schema: Schema,
    config: IndexConfig,
    path_field: Field,
    name_field: Field,
    extension_field: Field,
    content_field: Field,
    size_field: Field,
    modified_field: Field,
    is_dir_field: Field,
}

impl FileIndexer {
    pub fn new(index_dir: PathBuf, config: IndexConfig) -> Result<Self, String> {
        let mut schema_builder = Schema::builder();

        let text_options = TextOptions::default()
            .set_indexing_options(
                TextFieldIndexing::default()
                    .set_tokenizer("default")
                    .set_index_option(IndexRecordOption::WithFreqsAndPositions),
            )
            .set_stored();

        let path_field = schema_builder.add_text_field("path", STRING | STORED);
        let name_field = schema_builder.add_text_field("name", text_options.clone());
        let extension_field = schema_builder.add_text_field("extension", STRING | STORED);
        let content_field = schema_builder.add_text_field("content", TEXT);
        let size_field = schema_builder.add_u64_field("size", INDEXED | STORED);
        let modified_field = schema_builder.add_i64_field("modified", INDEXED | STORED);
        let is_dir_field = schema_builder.add_u64_field("is_dir", INDEXED | STORED);

        let schema = schema_builder.build();

        std::fs::create_dir_all(&index_dir).map_err(|e| e.to_string())?;

        let index = if index_dir.join("meta.json").exists() {
            Index::open_in_dir(&index_dir).map_err(|e| e.to_string())?
        } else {
            Index::create_in_dir(&index_dir, schema.clone()).map_err(|e| e.to_string())?
        };

        let writer = index
            .writer(50_000_000)
            .map_err(|e| e.to_string())?;

        let reader = index
            .reader_builder()
            .reload_policy(ReloadPolicy::OnCommitWithDelay)
            .try_into()
            .map_err(|e| e.to_string())?;

        Ok(Self {
            index,
            reader,
            writer: Arc::new(RwLock::new(writer)),
            schema,
            config,
            path_field,
            name_field,
            extension_field,
            content_field,
            size_field,
            modified_field,
            is_dir_field,
        })
    }

    pub fn index_all(&self) -> Result<usize, String> {
        let mut count = 0;

        {
            let mut writer = self.writer.write();
            writer.delete_all_documents().map_err(|e| e.to_string())?;
        }

        for base_path in &self.config.index_paths {
            if !base_path.exists() {
                continue;
            }

            for entry in WalkDir::new(base_path)
                .follow_links(false)
                .into_iter()
                .filter_entry(|e| !self.config.should_exclude(e.path()))
            {
                let entry = match entry {
                    Ok(e) => e,
                    Err(_) => continue,
                };

                let path = entry.path();
                let metadata = match entry.metadata() {
                    Ok(m) => m,
                    Err(_) => continue,
                };

                if metadata.len() > self.config.max_file_size_mb * 1024 * 1024 {
                    continue;
                }

                if let Err(e) = self.index_file(path, &metadata) {
                    eprintln!("Failed to index {}: {}", path.display(), e);
                    continue;
                }

                count += 1;

                if count % 1000 == 0 {
                    let mut writer = self.writer.write();
                    let _ = writer.commit();
                }
            }
        }

        {
            let mut writer = self.writer.write();
            writer.commit().map_err(|e| e.to_string())?;
        }

        Ok(count)
    }

    pub fn index_file(&self, path: &Path, metadata: &std::fs::Metadata) -> Result<(), String> {
        let name = path
            .file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_default();

        let extension = path
            .extension()
            .map(|e| e.to_string_lossy().to_string());

        let modified = metadata
            .modified()
            .map(|t| DateTime::<Utc>::from(t))
            .unwrap_or_else(|_| Utc::now());

        let content = if self.config.should_index_content(path) && metadata.is_file() {
            std::fs::read_to_string(path).unwrap_or_default()
        } else {
            String::new()
        };

        let mut doc = tantivy::TantivyDocument::new();
        doc.add_text(self.path_field, path.to_string_lossy());
        doc.add_text(self.name_field, &name);
        doc.add_text(self.extension_field, extension.as_deref().unwrap_or(""));
        doc.add_text(self.content_field, &content);
        doc.add_u64(self.size_field, metadata.len());
        doc.add_i64(self.modified_field, modified.timestamp());
        doc.add_u64(self.is_dir_field, if metadata.is_dir() { 1 } else { 0 });

        let mut writer = self.writer.write();
        writer.add_document(doc).map_err(|e| e.to_string())?;

        Ok(())
    }

    pub fn remove_file(&self, path: &Path) -> Result<(), String> {
        let term = tantivy::Term::from_field_text(self.path_field, &path.to_string_lossy());
        let mut writer = self.writer.write();
        writer.delete_term(term);
        Ok(())
    }

    pub fn update_file(&self, path: &Path) -> Result<(), String> {
        self.remove_file(path)?;

        if path.exists() {
            if let Ok(metadata) = std::fs::metadata(path) {
                self.index_file(path, &metadata)?;
            }
        }

        Ok(())
    }

    pub fn commit(&self) -> Result<(), String> {
        let mut writer = self.writer.write();
        writer.commit().map_err(|e| e.to_string())?;
        Ok(())
    }

    pub fn search(&self, query_str: &str, limit: usize) -> Result<Vec<IndexedFile>, String> {
        let searcher = self.reader.searcher();

        let query_parser = QueryParser::for_index(&self.index, vec![self.name_field, self.content_field]);

        let query = query_parser
            .parse_query(query_str)
            .map_err(|e| e.to_string())?;

        let top_docs = searcher
            .search(&query, &TopDocs::with_limit(limit))
            .map_err(|e| e.to_string())?;

        let mut results = Vec::new();

        for (_score, doc_address) in top_docs {
            let doc: tantivy::TantivyDocument = searcher.doc(doc_address).map_err(|e| e.to_string())?;

            let path = doc
                .get_first(self.path_field)
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();

            let name = doc
                .get_first(self.name_field)
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();

            let extension = doc
                .get_first(self.extension_field)
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
                .filter(|s| !s.is_empty());

            let size = doc
                .get_first(self.size_field)
                .and_then(|v| v.as_u64())
                .unwrap_or(0);

            let modified_ts = doc
                .get_first(self.modified_field)
                .and_then(|v| v.as_i64())
                .unwrap_or(0);

            let is_dir = doc
                .get_first(self.is_dir_field)
                .and_then(|v| v.as_u64())
                .map(|v| v == 1)
                .unwrap_or(false);

            let modified = DateTime::from_timestamp(modified_ts, 0).unwrap_or_else(|| Utc::now());

            results.push(IndexedFile {
                path,
                name,
                extension,
                size,
                modified,
                is_dir,
            });
        }

        Ok(results)
    }

    pub fn fuzzy_search(&self, query_str: &str, limit: usize) -> Result<Vec<IndexedFile>, String> {
        use fuzzy_matcher::skim::SkimMatcherV2;
        use fuzzy_matcher::FuzzyMatcher;

        let searcher = self.reader.searcher();
        let matcher = SkimMatcherV2::default();

        let all_docs = searcher
            .search(&tantivy::query::AllQuery, &TopDocs::with_limit(10000))
            .map_err(|e| e.to_string())?;

        let mut scored_results: Vec<(i64, IndexedFile)> = Vec::new();

        for (_score, doc_address) in all_docs {
            let doc: tantivy::TantivyDocument = searcher.doc(doc_address).map_err(|e| e.to_string())?;

            let name = doc
                .get_first(self.name_field)
                .and_then(|v| v.as_str())
                .unwrap_or("");

            let path = doc
                .get_first(self.path_field)
                .and_then(|v| v.as_str())
                .unwrap_or("");

            let name_score = matcher.fuzzy_match(name, query_str).unwrap_or(0);
            let path_score = matcher.fuzzy_match(path, query_str).unwrap_or(0) / 2;
            let total_score = name_score.max(path_score);

            if total_score > 0 {
                let extension = doc
                    .get_first(self.extension_field)
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string())
                    .filter(|s| !s.is_empty());

                let size = doc
                    .get_first(self.size_field)
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0);

                let modified_ts = doc
                    .get_first(self.modified_field)
                    .and_then(|v| v.as_i64())
                    .unwrap_or(0);

                let is_dir = doc
                    .get_first(self.is_dir_field)
                    .and_then(|v| v.as_u64())
                    .map(|v| v == 1)
                    .unwrap_or(false);

                let modified = DateTime::from_timestamp(modified_ts, 0).unwrap_or_else(|| Utc::now());

                scored_results.push((
                    total_score,
                    IndexedFile {
                        path: path.to_string(),
                        name: name.to_string(),
                        extension,
                        size,
                        modified,
                        is_dir,
                    },
                ));
            }
        }

        scored_results.sort_by(|a, b| b.0.cmp(&a.0));
        scored_results.truncate(limit);

        Ok(scored_results.into_iter().map(|(_, f)| f).collect())
    }

    pub fn get_stats(&self) -> Result<IndexStats, String> {
        let searcher = self.reader.searcher();
        let num_docs = searcher.num_docs() as usize;

        Ok(IndexStats {
            total_files: num_docs,
            index_paths: self.config.index_paths.clone(),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexStats {
    pub total_files: usize,
    pub index_paths: Vec<PathBuf>,
}
</file>

<file path="apps/launcher/src-tauri/src/indexer/mod.rs">
pub mod file_index;
pub mod watcher;
pub mod config;

pub use file_index::{FileIndexer, IndexStats, IndexedFile};
pub use watcher::FileWatcher;
pub use config::IndexConfig;
</file>

<file path="apps/launcher/src-tauri/src/indexer/watcher.rs">
use notify::{RecommendedWatcher, RecursiveMode};
use notify_debouncer_mini::{new_debouncer, DebouncedEvent, Debouncer};
use parking_lot::Mutex;
use std::path::PathBuf;
use std::sync::mpsc::{channel, Receiver};
use std::sync::Arc;
use std::time::Duration;

pub struct FileWatcher {
    _debouncer: Debouncer<RecommendedWatcher>,
    pending_paths: Arc<Mutex<Vec<PathBuf>>>,
}

impl FileWatcher {
    pub fn new(paths: Vec<PathBuf>) -> Result<Self, String> {
        let pending_paths = Arc::new(Mutex::new(Vec::new()));
        let pending_clone = pending_paths.clone();

        let (tx, rx) = channel();

        std::thread::spawn(move || {
            Self::receiver_thread(rx, pending_clone);
        });

        let mut debouncer = new_debouncer(Duration::from_millis(500), tx)
            .map_err(|e| e.to_string())?;

        for path in paths {
            if path.exists() {
                debouncer
                    .watcher()
                    .watch(&path, RecursiveMode::Recursive)
                    .map_err(|e| format!("Failed to watch {}: {}", path.display(), e))?;
            }
        }

        Ok(Self {
            _debouncer: debouncer,
            pending_paths,
        })
    }

    fn receiver_thread(
        receiver: Receiver<Result<Vec<DebouncedEvent>, notify::Error>>,
        pending_paths: Arc<Mutex<Vec<PathBuf>>>,
    ) {
        loop {
            match receiver.recv() {
                Ok(Ok(events)) => {
                    let mut lock = pending_paths.lock();
                    for event in events {
                        lock.push(event.path);
                    }
                }
                Ok(Err(e)) => {
                    eprintln!("Watcher error: {}", e);
                }
                Err(_) => {
                    break;
                }
            }
        }
    }

    pub fn poll_events(&self) -> Vec<PathBuf> {
        let mut lock = self.pending_paths.lock();
        let mut paths = std::mem::take(&mut *lock);
        paths.sort();
        paths.dedup();
        paths
    }
}
</file>

<file path="apps/launcher/src-tauri/src/oauth/callback.rs">
use axum::{
    extract::{Query, State},
    response::{Html, IntoResponse},
    routing::get,
    Router,
};
use std::sync::Arc;
use parking_lot::RwLock;
use serde::Deserialize;
use tokio::sync::oneshot;

use super::flow::OAuthFlow;

const CALLBACK_PORT: u16 = 19284;

#[derive(Debug, Deserialize)]
pub struct CallbackParams {
    code: Option<String>,
    state: Option<String>,
    error: Option<String>,
    error_description: Option<String>,
}

pub struct CallbackServer {
    shutdown_tx: RwLock<Option<oneshot::Sender<()>>>,
}

impl CallbackServer {
    pub fn new() -> Self {
        Self {
            shutdown_tx: RwLock::new(None),
        }
    }

    pub async fn start(&self, oauth_flow: Arc<OAuthFlow>) -> Result<(), String> {
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();
        
        {
            let mut tx = self.shutdown_tx.write();
            if tx.is_some() {
                return Ok(());
            }
            *tx = Some(shutdown_tx);
        }

        let app = Router::new()
            .route("/oauth/callback", get(handle_callback))
            .with_state(oauth_flow);

        let addr = format!("127.0.0.1:{}", CALLBACK_PORT);
        let listener = tokio::net::TcpListener::bind(&addr)
            .await
            .map_err(|e| format!("Failed to bind callback server: {}", e))?;

        println!("OAuth callback server listening on http://{}", addr);

        tokio::spawn(async move {
            axum::serve(listener, app)
                .with_graceful_shutdown(async {
                    let _ = shutdown_rx.await;
                })
                .await
                .ok();
        });

        Ok(())
    }

    pub fn stop(&self) {
        let mut tx = self.shutdown_tx.write();
        if let Some(sender) = tx.take() {
            let _ = sender.send(());
        }
    }

    pub fn callback_url() -> String {
        format!("http://localhost:{}/oauth/callback", CALLBACK_PORT)
    }
}

async fn handle_callback(
    State(oauth_flow): State<Arc<OAuthFlow>>,
    Query(params): Query<CallbackParams>,
) -> impl IntoResponse {
    if let Some(error) = params.error {
        let description = params.error_description.unwrap_or_default();
        return Html(error_page(&error, &description));
    }

    let (code, state) = match (params.code, params.state) {
        (Some(c), Some(s)) => (c, s),
        _ => {
            return Html(error_page(
                "Missing parameters",
                "The callback is missing required code or state parameters.",
            ));
        }
    };

    match oauth_flow.exchange_code(&state, &code).await {
        Ok(_) => Html(success_page()),
        Err(e) => Html(error_page("Token exchange failed", &e)),
    }
}

fn success_page() -> String {
    r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Authentication Successful</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e4e4e7;
        }
        .container {
            text-align: center;
            padding: 3rem;
            background: rgba(255,255,255,0.05);
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 400px;
        }
        .icon {
            width: 64px;
            height: 64px;
            background: #22c55e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            font-size: 2rem;
        }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        p { color: #a1a1aa; margin-bottom: 1.5rem; }
        .hint {
            font-size: 0.875rem;
            color: #71717a;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">âœ“</div>
        <h1>Connected Successfully!</h1>
        <p>Your account has been linked to Launcher.</p>
        <div class="hint">You can close this window and return to the app.</div>
    </div>
    <script>setTimeout(() => window.close(), 3000);</script>
</body>
</html>"#.to_string()
}

fn error_page(error: &str, description: &str) -> String {
    format!(r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Authentication Failed</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e4e4e7;
        }}
        .container {{
            text-align: center;
            padding: 3rem;
            background: rgba(255,255,255,0.05);
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 400px;
        }}
        .icon {{
            width: 64px;
            height: 64px;
            background: #ef4444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            font-size: 2rem;
        }}
        h1 {{ font-size: 1.5rem; margin-bottom: 0.5rem; }}
        .error {{ color: #fca5a5; margin-bottom: 0.5rem; }}
        p {{ color: #a1a1aa; margin-bottom: 1.5rem; }}
        .hint {{
            font-size: 0.875rem;
            color: #71717a;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">âœ•</div>
        <h1>Authentication Failed</h1>
        <p class="error">{}</p>
        <p>{}</p>
        <div class="hint">Please close this window and try again.</div>
    </div>
</body>
</html>"#, error, description)
}
</file>

<file path="apps/launcher/src-tauri/src/oauth/flow.rs">
use super::providers::OAuthProviderConfig;
use super::storage::{OAuthToken, TokenStorage};
use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
use rand::Rng;
use serde::Deserialize;
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;
use url::Url;

#[derive(Debug, Clone)]
pub struct PendingAuth {
    pub provider: String,
    pub state: String,
    pub code_verifier: String,
    pub redirect_uri: String,
}

pub struct OAuthFlow {
    storage: Arc<TokenStorage>,
    pending: RwLock<HashMap<String, PendingAuth>>,
    providers: RwLock<HashMap<String, OAuthProviderConfig>>,
}

impl OAuthFlow {
    pub fn new(storage: Arc<TokenStorage>) -> Self {
        Self {
            storage,
            pending: RwLock::new(HashMap::new()),
            providers: RwLock::new(HashMap::new()),
        }
    }

    pub fn register_provider(&self, config: OAuthProviderConfig) {
        let mut providers = self.providers.write();
        providers.insert(config.id.clone(), config);
    }

    pub fn get_provider(&self, provider_id: &str) -> Option<OAuthProviderConfig> {
        let providers = self.providers.read();
        providers.get(provider_id).cloned()
    }

    pub fn list_providers(&self) -> Vec<OAuthProviderConfig> {
        let providers = self.providers.read();
        providers.values().cloned().collect()
    }

    pub fn update_provider_credentials(
        &self,
        provider_id: &str,
        client_id: Option<String>,
        client_secret: Option<String>,
    ) -> Result<(), String> {
        let mut providers = self.providers.write();
        let provider = providers
            .get_mut(provider_id)
            .ok_or_else(|| format!("Unknown provider: {}", provider_id))?;
        
        provider.client_id = client_id;
        provider.client_secret = client_secret;
        Ok(())
    }

    fn generate_state() -> String {
        let bytes: [u8; 32] = rand::thread_rng().gen();
        URL_SAFE_NO_PAD.encode(bytes)
    }

    fn generate_code_verifier() -> String {
        let bytes: [u8; 32] = rand::thread_rng().gen();
        URL_SAFE_NO_PAD.encode(bytes)
    }

    fn generate_code_challenge(verifier: &str) -> String {
        let mut hasher = Sha256::new();
        hasher.update(verifier.as_bytes());
        let hash = hasher.finalize();
        URL_SAFE_NO_PAD.encode(hash)
    }

    pub fn start_auth(
        &self,
        provider_id: &str,
        scopes: Option<Vec<String>>,
        redirect_uri: &str,
    ) -> Result<String, String> {
        let provider = self
            .get_provider(provider_id)
            .ok_or_else(|| format!("Unknown provider: {}", provider_id))?;

        let client_id = provider
            .client_id
            .as_ref()
            .ok_or("Provider not configured: missing client_id")?;

        let state = Self::generate_state();
        let code_verifier = Self::generate_code_verifier();
        let code_challenge = Self::generate_code_challenge(&code_verifier);

        let scopes = scopes.unwrap_or(provider.scopes.clone());
        let scope_str = scopes.join(" ");

        let mut auth_url = Url::parse(&provider.auth_url)
            .map_err(|e| format!("Invalid auth URL: {}", e))?;

        auth_url.query_pairs_mut()
            .append_pair("client_id", client_id)
            .append_pair("redirect_uri", redirect_uri)
            .append_pair("response_type", "code")
            .append_pair("state", &state)
            .append_pair("scope", &scope_str)
            .append_pair("code_challenge", &code_challenge)
            .append_pair("code_challenge_method", "S256");

        let pending = PendingAuth {
            provider: provider_id.to_string(),
            state: state.clone(),
            code_verifier,
            redirect_uri: redirect_uri.to_string(),
        };

        {
            let mut pending_map = self.pending.write();
            pending_map.insert(state, pending);
        }

        Ok(auth_url.to_string())
    }

    pub async fn exchange_code(
        &self,
        state: &str,
        code: &str,
    ) -> Result<OAuthToken, String> {
        let pending = {
            let mut pending_map = self.pending.write();
            pending_map
                .remove(state)
                .ok_or("Invalid or expired state parameter")?
        };

        let provider = self
            .get_provider(&pending.provider)
            .ok_or("Provider not found")?;

        let client_id = provider
            .client_id
            .as_ref()
            .ok_or("Provider not configured: missing client_id")?;

        let client = reqwest::Client::new();

        let mut params = HashMap::new();
        params.insert("client_id", client_id.as_str());
        params.insert("code", code);
        params.insert("redirect_uri", &pending.redirect_uri);
        params.insert("grant_type", "authorization_code");
        params.insert("code_verifier", &pending.code_verifier);

        if let Some(ref secret) = provider.client_secret {
            params.insert("client_secret", secret.as_str());
        }

        let response = client
            .post(&provider.token_url)
            .header("Accept", "application/json")
            .form(&params)
            .send()
            .await
            .map_err(|e| format!("Token request failed: {}", e))?;

        if !response.status().is_success() {
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("Token exchange failed: {}", error_text));
        }

        let token_response: TokenResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse token response: {}", e))?;

        let expires_at = token_response.expires_in.map(|secs| {
            chrono::Utc::now().timestamp() + secs as i64
        });

        let token = OAuthToken {
            access_token: token_response.access_token,
            refresh_token: token_response.refresh_token,
            token_type: token_response.token_type.unwrap_or_else(|| "Bearer".to_string()),
            expires_at,
            scopes: token_response
                .scope
                .map(|s| s.split_whitespace().map(String::from).collect())
                .unwrap_or_default(),
        };

        self.storage.store_token(&pending.provider, &token)?;

        Ok(token)
    }

    pub async fn refresh_token(&self, provider_id: &str) -> Result<OAuthToken, String> {
        let current_token = self
            .storage
            .get_token(provider_id)
            .ok_or("No token found for provider")?;

        let refresh_token = current_token
            .refresh_token
            .as_ref()
            .ok_or("No refresh token available")?;

        let provider = self
            .get_provider(provider_id)
            .ok_or("Provider not found")?;

        let client_id = provider
            .client_id
            .as_ref()
            .ok_or("Provider not configured")?;

        let client = reqwest::Client::new();

        let mut params = HashMap::new();
        params.insert("client_id", client_id.as_str());
        params.insert("refresh_token", refresh_token.as_str());
        params.insert("grant_type", "refresh_token");

        if let Some(ref secret) = provider.client_secret {
            params.insert("client_secret", secret.as_str());
        }

        let response = client
            .post(&provider.token_url)
            .header("Accept", "application/json")
            .form(&params)
            .send()
            .await
            .map_err(|e| format!("Refresh request failed: {}", e))?;

        if !response.status().is_success() {
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("Token refresh failed: {}", error_text));
        }

        let token_response: TokenResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse token response: {}", e))?;

        let expires_at = token_response.expires_in.map(|secs| {
            chrono::Utc::now().timestamp() + secs as i64
        });

        let token = OAuthToken {
            access_token: token_response.access_token,
            refresh_token: token_response
                .refresh_token
                .or(current_token.refresh_token),
            token_type: token_response.token_type.unwrap_or_else(|| "Bearer".to_string()),
            expires_at,
            scopes: current_token.scopes,
        };

        self.storage.store_token(provider_id, &token)?;

        Ok(token)
    }

    pub async fn get_valid_token(&self, provider_id: &str) -> Result<String, String> {
        let token = self
            .storage
            .get_token(provider_id)
            .ok_or("Not authenticated with this provider")?;

        if token.is_expired() {
            let refreshed = self.refresh_token(provider_id).await?;
            Ok(refreshed.access_token)
        } else {
            Ok(token.access_token)
        }
    }

    pub fn disconnect(&self, provider_id: &str) -> Result<(), String> {
        self.storage.delete_token(provider_id)
    }

    pub fn is_connected(&self, provider_id: &str) -> bool {
        self.storage.has_token(provider_id)
    }

    pub fn get_token_if_valid(&self, provider_id: &str) -> Option<String> {
        let token = self.storage.get_token(provider_id)?;
        if !token.is_expired() {
            Some(token.access_token)
        } else {
            None
        }
    }
}

#[derive(Debug, Deserialize)]
struct TokenResponse {
    access_token: String,
    refresh_token: Option<String>,
    token_type: Option<String>,
    expires_in: Option<u64>,
    scope: Option<String>,
}
</file>

<file path="apps/launcher/src-tauri/src/oauth/mod.rs">
pub mod providers;
pub mod storage;
pub mod flow;
pub mod callback;

pub use providers::{OAuthProvider, OAuthProviderConfig, GITHUB_PROVIDER};
pub use storage::TokenStorage;
pub use flow::OAuthFlow;
pub use callback::CallbackServer;
</file>

<file path="apps/launcher/src-tauri/src/oauth/providers.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthProviderConfig {
    pub id: String,
    pub name: String,
    pub auth_url: String,
    pub token_url: String,
    pub scopes: Vec<String>,
    pub client_id: Option<String>,
    pub client_secret: Option<String>,
}

pub trait OAuthProvider: Send + Sync {
    fn id(&self) -> &str;
    fn name(&self) -> &str;
    fn config(&self) -> &OAuthProviderConfig;
    fn default_scopes(&self) -> Vec<String>;
}

pub struct GitHubProvider {
    config: OAuthProviderConfig,
}

impl GitHubProvider {
    pub fn new(client_id: Option<String>, client_secret: Option<String>) -> Self {
        Self {
            config: OAuthProviderConfig {
                id: "github".to_string(),
                name: "GitHub".to_string(),
                auth_url: "https://github.com/login/oauth/authorize".to_string(),
                token_url: "https://github.com/login/oauth/access_token".to_string(),
                scopes: vec!["repo".to_string(), "user".to_string()],
                client_id,
                client_secret,
            },
        }
    }
}

impl OAuthProvider for GitHubProvider {
    fn id(&self) -> &str {
        &self.config.id
    }

    fn name(&self) -> &str {
        &self.config.name
    }

    fn config(&self) -> &OAuthProviderConfig {
        &self.config
    }

    fn default_scopes(&self) -> Vec<String> {
        vec!["repo".to_string(), "user".to_string()]
    }
}

pub struct GoogleProvider {
    config: OAuthProviderConfig,
}

impl GoogleProvider {
    pub fn new(client_id: Option<String>, client_secret: Option<String>) -> Self {
        Self {
            config: OAuthProviderConfig {
                id: "google".to_string(),
                name: "Google".to_string(),
                auth_url: "https://accounts.google.com/o/oauth2/v2/auth".to_string(),
                token_url: "https://oauth2.googleapis.com/token".to_string(),
                scopes: vec![
                    "https://www.googleapis.com/auth/drive.readonly".to_string(),
                    "https://www.googleapis.com/auth/calendar.readonly".to_string(),
                ],
                client_id,
                client_secret,
            },
        }
    }
}

impl OAuthProvider for GoogleProvider {
    fn id(&self) -> &str {
        &self.config.id
    }

    fn name(&self) -> &str {
        &self.config.name
    }

    fn config(&self) -> &OAuthProviderConfig {
        &self.config
    }

    fn default_scopes(&self) -> Vec<String> {
        vec![
            "https://www.googleapis.com/auth/drive.readonly".to_string(),
            "https://www.googleapis.com/auth/calendar.readonly".to_string(),
        ]
    }
}

pub struct NotionProvider {
    config: OAuthProviderConfig,
}

impl NotionProvider {
    pub fn new(client_id: Option<String>, client_secret: Option<String>) -> Self {
        Self {
            config: OAuthProviderConfig {
                id: "notion".to_string(),
                name: "Notion".to_string(),
                auth_url: "https://api.notion.com/v1/oauth/authorize".to_string(),
                token_url: "https://api.notion.com/v1/oauth/token".to_string(),
                scopes: vec![], // Notion doesn't use scopes in the same way
                client_id,
                client_secret,
            },
        }
    }
}

impl OAuthProvider for NotionProvider {
    fn id(&self) -> &str {
        &self.config.id
    }

    fn name(&self) -> &str {
        &self.config.name
    }

    fn config(&self) -> &OAuthProviderConfig {
        &self.config
    }

    fn default_scopes(&self) -> Vec<String> {
        vec![] // Notion uses integration capabilities instead of scopes
    }
}

pub struct SlackProvider {
    config: OAuthProviderConfig,
}

impl SlackProvider {
    pub fn new(client_id: Option<String>, client_secret: Option<String>) -> Self {
        Self {
            config: OAuthProviderConfig {
                id: "slack".to_string(),
                name: "Slack".to_string(),
                auth_url: "https://slack.com/oauth/v2/authorize".to_string(),
                token_url: "https://slack.com/api/oauth.v2.access".to_string(),
                scopes: vec![
                    "channels:read".to_string(),
                    "search:read".to_string(),
                    "users:read".to_string(),
                ],
                client_id,
                client_secret,
            },
        }
    }
}

impl OAuthProvider for SlackProvider {
    fn id(&self) -> &str {
        &self.config.id
    }

    fn name(&self) -> &str {
        &self.config.name
    }

    fn config(&self) -> &OAuthProviderConfig {
        &self.config
    }

    fn default_scopes(&self) -> Vec<String> {
        vec![
            "channels:read".to_string(),
            "search:read".to_string(),
            "users:read".to_string(),
        ]
    }
}

pub static GITHUB_PROVIDER: &str = "github";
pub static GOOGLE_PROVIDER: &str = "google";
pub static NOTION_PROVIDER: &str = "notion";
pub static SLACK_PROVIDER: &str = "slack";
</file>

<file path="apps/launcher/src-tauri/src/oauth/storage.rs">
use keyring::Entry;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use parking_lot::RwLock;

const SERVICE_NAME: &str = "launcher-oauth";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthToken {
    pub access_token: String,
    pub refresh_token: Option<String>,
    pub token_type: String,
    pub expires_at: Option<i64>,
    pub scopes: Vec<String>,
}

impl OAuthToken {
    pub fn is_expired(&self) -> bool {
        if let Some(expires_at) = self.expires_at {
            let now = chrono::Utc::now().timestamp();
            now >= expires_at - 60
        } else {
            false
        }
    }
}

pub struct TokenStorage {
    cache: RwLock<HashMap<String, OAuthToken>>,
}

impl TokenStorage {
    pub fn new() -> Self {
        Self {
            cache: RwLock::new(HashMap::new()),
        }
    }

    fn keyring_key(provider: &str) -> String {
        format!("{}:{}", SERVICE_NAME, provider)
    }

    pub fn store_token(&self, provider: &str, token: &OAuthToken) -> Result<(), String> {
        let key = Self::keyring_key(provider);
        let json = serde_json::to_string(token)
            .map_err(|e| format!("Failed to serialize token: {}", e))?;

        let entry = Entry::new(SERVICE_NAME, &key)
            .map_err(|e| format!("Failed to create keyring entry: {}", e))?;

        entry
            .set_password(&json)
            .map_err(|e| format!("Failed to store token in keyring: {}", e))?;

        let mut cache = self.cache.write();
        cache.insert(provider.to_string(), token.clone());

        Ok(())
    }

    pub fn get_token(&self, provider: &str) -> Option<OAuthToken> {
        {
            let cache = self.cache.read();
            if let Some(token) = cache.get(provider) {
                if !token.is_expired() {
                    return Some(token.clone());
                }
            }
        }

        let key = Self::keyring_key(provider);
        let entry = Entry::new(SERVICE_NAME, &key).ok()?;
        let json = entry.get_password().ok()?;
        let token: OAuthToken = serde_json::from_str(&json).ok()?;

        if !token.is_expired() {
            let mut cache = self.cache.write();
            cache.insert(provider.to_string(), token.clone());
            Some(token)
        } else if token.refresh_token.is_some() {
            Some(token)
        } else {
            None
        }
    }

    pub fn delete_token(&self, provider: &str) -> Result<(), String> {
        let key = Self::keyring_key(provider);
        
        if let Ok(entry) = Entry::new(SERVICE_NAME, &key) {
            let _ = entry.delete_credential();
        }

        let mut cache = self.cache.write();
        cache.remove(provider);

        Ok(())
    }

    pub fn has_token(&self, provider: &str) -> bool {
        self.get_token(provider).is_some()
    }

    pub fn list_connected_providers(&self) -> Vec<String> {
        let cache = self.cache.read();
        cache.keys().cloned().collect()
    }
}

impl Default for TokenStorage {
    fn default() -> Self {
        Self::new()
    }
}
</file>

<file path="apps/launcher/src-tauri/src/plugins/host_api.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginSearchResult {
    pub id: String,
    pub title: String,
    pub subtitle: Option<String>,
    pub icon: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpRequest {
    pub url: String,
    pub method: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpResponse {
    pub status: u16,
    pub headers: Vec<(String, String)>,
    pub body: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfig {
    pub values: std::collections::HashMap<String, serde_json::Value>,
}

impl Default for PluginConfig {
    fn default() -> Self {
        Self {
            values: std::collections::HashMap::new(),
        }
    }
}

pub trait PluginHostApi: Send + Sync {
    fn log(&self, plugin_id: &str, level: &str, message: &str);
    fn http_request(&self, plugin_id: &str, request: HttpRequest) -> Result<HttpResponse, String>;
    fn read_file(&self, plugin_id: &str, path: &str) -> Result<Vec<u8>, String>;
    fn write_file(&self, plugin_id: &str, path: &str, data: &[u8]) -> Result<(), String>;
    fn get_config(&self, plugin_id: &str) -> PluginConfig;
    fn set_config(&self, plugin_id: &str, config: PluginConfig) -> Result<(), String>;
    fn show_notification(&self, plugin_id: &str, title: &str, body: &str) -> Result<(), String>;
    fn get_oauth_token(&self, plugin_id: &str, provider: &str) -> Result<String, String>;
}

pub struct DefaultHostApi {
    config_dir: std::path::PathBuf,
}

impl DefaultHostApi {
    pub fn new() -> Self {
        let config_dir = dirs::data_dir()
            .unwrap_or_else(|| std::path::PathBuf::from("."))
            .join("launcher")
            .join("plugin_configs");

        let _ = std::fs::create_dir_all(&config_dir);

        Self { config_dir }
    }

    fn get_config_path(&self, plugin_id: &str) -> std::path::PathBuf {
        self.config_dir.join(format!("{}.json", plugin_id))
    }
}

impl PluginHostApi for DefaultHostApi {
    fn log(&self, plugin_id: &str, level: &str, message: &str) {
        println!("[Plugin:{}] [{}] {}", plugin_id, level, message);
    }

    fn http_request(&self, _plugin_id: &str, request: HttpRequest) -> Result<HttpResponse, String> {
        Err(format!(
            "HTTP requests not yet implemented: {} {}",
            request.method, request.url
        ))
    }

    fn read_file(&self, _plugin_id: &str, path: &str) -> Result<Vec<u8>, String> {
        std::fs::read(path).map_err(|e| format!("Failed to read file: {}", e))
    }

    fn write_file(&self, _plugin_id: &str, path: &str, data: &[u8]) -> Result<(), String> {
        std::fs::write(path, data).map_err(|e| format!("Failed to write file: {}", e))
    }

    fn get_config(&self, plugin_id: &str) -> PluginConfig {
        let path = self.get_config_path(plugin_id);
        if let Ok(content) = std::fs::read_to_string(&path) {
            serde_json::from_str(&content).unwrap_or_default()
        } else {
            PluginConfig::default()
        }
    }

    fn set_config(&self, plugin_id: &str, config: PluginConfig) -> Result<(), String> {
        let path = self.get_config_path(plugin_id);
        let json = serde_json::to_string_pretty(&config)
            .map_err(|e| format!("Failed to serialize config: {}", e))?;
        std::fs::write(&path, json).map_err(|e| format!("Failed to write config: {}", e))
    }

    fn show_notification(&self, plugin_id: &str, title: &str, body: &str) -> Result<(), String> {
        println!("[Notification from {}] {}: {}", plugin_id, title, body);
        Ok(())
    }

    fn get_oauth_token(&self, _plugin_id: &str, provider: &str) -> Result<String, String> {
        Err(format!("OAuth not yet implemented for provider: {}", provider))
    }
}
</file>

<file path="apps/launcher/src-tauri/src/plugins/loader.rs">
use super::manifest::{LoadedPlugin, PluginManifest};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use parking_lot::RwLock;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginInfo {
    pub id: String,
    pub name: String,
    pub version: String,
    pub author: Option<String>,
    pub description: Option<String>,
    pub permissions: Vec<String>,
    pub entry: String,
    pub enabled: bool,
}

pub struct PluginLoader {
    plugins_dir: PathBuf,
    plugins: RwLock<HashMap<String, LoadedPlugin>>,
}

impl PluginLoader {
    pub fn new() -> Self {
        let plugins_dir = dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("launcher")
            .join("plugins");

        Self {
            plugins_dir,
            plugins: RwLock::new(HashMap::new()),
        }
    }

    pub fn scan_plugins(&self) -> Result<Vec<String>, String> {
        if !self.plugins_dir.exists() {
            std::fs::create_dir_all(&self.plugins_dir)
                .map_err(|e| format!("Failed to create plugins directory: {}", e))?;
            return Ok(Vec::new());
        }

        let mut loaded_ids = Vec::new();

        let entries = std::fs::read_dir(&self.plugins_dir)
            .map_err(|e| format!("Failed to read plugins directory: {}", e))?;

        for entry in entries.flatten() {
            let path = entry.path();
            if !path.is_dir() {
                continue;
            }

            let manifest_path = path.join("manifest.json");
            if !manifest_path.exists() {
                continue;
            }

            match self.load_plugin(&path) {
                Ok(id) => loaded_ids.push(id),
                Err(e) => eprintln!("Failed to load plugin at {}: {}", path.display(), e),
            }
        }

        Ok(loaded_ids)
    }

    fn load_plugin(&self, plugin_dir: &PathBuf) -> Result<String, String> {
        let manifest_path = plugin_dir.join("manifest.json");
        let manifest = PluginManifest::from_file(&manifest_path)?;

        let wasm_path = plugin_dir.join(&manifest.entry);
        if !wasm_path.exists() {
            return Err(format!("WASM entry file not found: {}", wasm_path.display()));
        }

        let wasm_bytes = std::fs::read(&wasm_path)
            .map_err(|e| format!("Failed to read WASM file: {}", e))?;

        let plugin_id = manifest.id.clone();

        let loaded = LoadedPlugin {
            manifest,
            path: plugin_dir.clone(),
            wasm_bytes,
            enabled: true,
        };

        let mut plugins = self.plugins.write();
        plugins.insert(plugin_id.clone(), loaded);

        Ok(plugin_id)
    }

    pub fn get_plugin(&self, id: &str) -> Option<LoadedPlugin> {
        let plugins = self.plugins.read();
        plugins.get(id).cloned()
    }

    pub fn list_plugins(&self) -> Vec<PluginInfo> {
        let plugins = self.plugins.read();
        plugins.values().map(|p| PluginInfo {
            id: p.manifest.id.clone(),
            name: p.manifest.name.clone(),
            version: p.manifest.version.clone(),
            author: p.manifest.author.clone(),
            description: p.manifest.description.clone(),
            permissions: p.manifest.permissions.iter().map(|perm| format!("{:?}", perm)).collect(),
            entry: p.manifest.entry.clone(),
            enabled: p.enabled,
        }).collect()
    }

    pub fn enable_plugin(&self, id: &str) -> Result<(), String> {
        let mut plugins = self.plugins.write();
        if let Some(plugin) = plugins.get_mut(id) {
            plugin.enabled = true;
            Ok(())
        } else {
            Err(format!("Plugin not found: {}", id))
        }
    }

    pub fn disable_plugin(&self, id: &str) -> Result<(), String> {
        let mut plugins = self.plugins.write();
        if let Some(plugin) = plugins.get_mut(id) {
            plugin.enabled = false;
            Ok(())
        } else {
            Err(format!("Plugin not found: {}", id))
        }
    }

    pub fn uninstall_plugin(&self, id: &str) -> Result<(), String> {
        let mut plugins = self.plugins.write();
        if let Some(plugin) = plugins.remove(id) {
            std::fs::remove_dir_all(&plugin.path)
                .map_err(|e| format!("Failed to remove plugin directory: {}", e))?;
            Ok(())
        } else {
            Err(format!("Plugin not found: {}", id))
        }
    }

    pub fn plugins_dir(&self) -> &PathBuf {
        &self.plugins_dir
    }
}
</file>

<file path="apps/launcher/src-tauri/src/plugins/manifest.rs">
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginManifest {
    pub id: String,
    pub name: String,
    pub version: String,
    pub author: Option<String>,
    pub description: Option<String>,
    pub permissions: Vec<PluginPermission>,
    pub entry: String,
    pub provides: PluginProvides,
    #[serde(default)]
    pub oauth: HashMap<String, OAuthConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginProvides {
    #[serde(default)]
    pub providers: Vec<String>,
    #[serde(default)]
    pub actions: Vec<String>,
    #[serde(default)]
    pub ai_tools: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum PluginPermission {
    Network,
    #[serde(rename = "filesystem:read")]
    FilesystemRead,
    #[serde(rename = "filesystem:write")]
    FilesystemWrite,
    Clipboard,
    Notifications,
    #[serde(rename = "oauth")]
    OAuth(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthConfig {
    pub scopes: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct LoadedPlugin {
    pub manifest: PluginManifest,
    pub path: PathBuf,
    pub wasm_bytes: Vec<u8>,
    pub enabled: bool,
}

impl PluginManifest {
    pub fn from_file(path: &PathBuf) -> Result<Self, String> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| format!("Failed to read manifest: {}", e))?;
        
        serde_json::from_str(&content)
            .map_err(|e| format!("Failed to parse manifest: {}", e))
    }

    pub fn has_permission(&self, permission: &PluginPermission) -> bool {
        self.permissions.contains(permission)
    }
}

impl Default for PluginProvides {
    fn default() -> Self {
        Self {
            providers: Vec::new(),
            actions: Vec::new(),
            ai_tools: Vec::new(),
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/plugins/mod.rs">
pub mod manifest;
pub mod loader;
pub mod runtime;
pub mod host_api;
pub mod registry;

pub use loader::{PluginLoader, PluginInfo};
pub use runtime::PluginRuntime;
pub use registry::{PluginRegistry, RegistryPlugin};
</file>

<file path="apps/launcher/src-tauri/src/plugins/registry.rs">
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use parking_lot::RwLock;

/// A plugin entry in the marketplace registry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryPlugin {
    pub id: String,
    pub name: String,
    pub version: String,
    pub author: Option<String>,
    pub description: Option<String>,
    pub homepage: Option<String>,
    pub repository: Option<String>,
    pub download_url: String,
    pub checksum: Option<String>,
    pub permissions: Vec<String>,
    pub categories: Vec<String>,
    pub downloads: u64,
    pub rating: Option<f32>,
}

/// Plugin registry for marketplace
pub struct PluginRegistry {
    cache_dir: PathBuf,
    plugins: RwLock<HashMap<String, RegistryPlugin>>,
    last_updated: RwLock<Option<std::time::SystemTime>>,
}

impl PluginRegistry {
    pub fn new() -> Self {
        let cache_dir = dirs::cache_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("launcher")
            .join("registry");

        Self {
            cache_dir,
            plugins: RwLock::new(HashMap::new()),
            last_updated: RwLock::new(None),
        }
    }

    /// Load registry from local cache
    pub fn load_cache(&self) -> Result<(), String> {
        let cache_file = self.cache_dir.join("plugins.json");
        if !cache_file.exists() {
            return Ok(());
        }

        let contents = std::fs::read_to_string(&cache_file)
            .map_err(|e| format!("Failed to read registry cache: {}", e))?;

        let plugins: Vec<RegistryPlugin> = serde_json::from_str(&contents)
            .map_err(|e| format!("Failed to parse registry cache: {}", e))?;

        let mut registry = self.plugins.write();
        for plugin in plugins {
            registry.insert(plugin.id.clone(), plugin);
        }

        if let Ok(metadata) = std::fs::metadata(&cache_file) {
            if let Ok(modified) = metadata.modified() {
                *self.last_updated.write() = Some(modified);
            }
        }

        Ok(())
    }

    /// Save registry to local cache
    pub fn save_cache(&self) -> Result<(), String> {
        std::fs::create_dir_all(&self.cache_dir)
            .map_err(|e| format!("Failed to create cache directory: {}", e))?;

        let plugins: Vec<RegistryPlugin> = self.plugins.read().values().cloned().collect();
        let contents = serde_json::to_string_pretty(&plugins)
            .map_err(|e| format!("Failed to serialize registry: {}", e))?;

        let cache_file = self.cache_dir.join("plugins.json");
        std::fs::write(&cache_file, contents)
            .map_err(|e| format!("Failed to write registry cache: {}", e))?;

        *self.last_updated.write() = Some(std::time::SystemTime::now());

        Ok(())
    }

    /// Fetch registry from remote URL
    pub async fn fetch_remote(&self, url: &str) -> Result<(), String> {
        let response = reqwest::get(url)
            .await
            .map_err(|e| format!("Failed to fetch registry: {}", e))?;

        if !response.status().is_success() {
            return Err(format!("Registry fetch failed with status: {}", response.status()));
        }

        let plugins: Vec<RegistryPlugin> = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse registry response: {}", e))?;

        let mut registry = self.plugins.write();
        registry.clear();
        for plugin in plugins {
            registry.insert(plugin.id.clone(), plugin);
        }
        drop(registry);

        self.save_cache()?;

        Ok(())
    }

    /// List all plugins in registry
    pub fn list_plugins(&self) -> Vec<RegistryPlugin> {
        self.plugins.read().values().cloned().collect()
    }

    /// Search plugins by query
    pub fn search(&self, query: &str) -> Vec<RegistryPlugin> {
        let query_lower = query.to_lowercase();
        self.plugins
            .read()
            .values()
            .filter(|p| {
                p.name.to_lowercase().contains(&query_lower)
                    || p.description
                        .as_ref()
                        .map(|d| d.to_lowercase().contains(&query_lower))
                        .unwrap_or(false)
                    || p.categories.iter().any(|c| c.to_lowercase().contains(&query_lower))
            })
            .cloned()
            .collect()
    }

    /// Get a specific plugin by ID
    pub fn get_plugin(&self, id: &str) -> Option<RegistryPlugin> {
        self.plugins.read().get(id).cloned()
    }

    /// Filter plugins by category
    pub fn by_category(&self, category: &str) -> Vec<RegistryPlugin> {
        let category_lower = category.to_lowercase();
        self.plugins
            .read()
            .values()
            .filter(|p| p.categories.iter().any(|c| c.to_lowercase() == category_lower))
            .cloned()
            .collect()
    }

    /// Get all unique categories
    pub fn categories(&self) -> Vec<String> {
        let mut categories: Vec<String> = self
            .plugins
            .read()
            .values()
            .flat_map(|p| p.categories.clone())
            .collect();
        categories.sort();
        categories.dedup();
        categories
    }

    /// Add a plugin to the registry (for local/dev plugins)
    pub fn add_plugin(&self, plugin: RegistryPlugin) {
        self.plugins.write().insert(plugin.id.clone(), plugin);
    }

    /// Load built-in/featured plugins (hardcoded for now, can be remote later)
    pub fn load_featured(&self) {
        let featured = vec![
            RegistryPlugin {
                id: "hello-plugin".to_string(),
                name: "Hello Plugin".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Launcher Team".to_string()),
                description: Some("A simple example plugin that demonstrates the plugin API".to_string()),
                homepage: None,
                repository: Some("https://github.com/launcher/hello-plugin".to_string()),
                download_url: "local://examples/hello-plugin".to_string(),
                checksum: None,
                permissions: vec!["logging".to_string()],
                categories: vec!["Examples".to_string(), "Development".to_string()],
                downloads: 0,
                rating: None,
            },
            RegistryPlugin {
                id: "clipboard-history".to_string(),
                name: "Clipboard History".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Launcher Team".to_string()),
                description: Some("Track and search your clipboard history. Access past copies with a simple search.".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/clipboard-history/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string()],
                categories: vec!["Productivity".to_string(), "Utilities".to_string()],
                downloads: 1250,
                rating: Some(4.5),
            },
            RegistryPlugin {
                id: "snippets".to_string(),
                name: "Snippets".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Launcher Team".to_string()),
                description: Some("Create and manage text snippets. Quickly insert frequently used text.".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/snippets/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string(), "filesystem:read".to_string()],
                categories: vec!["Productivity".to_string(), "Text".to_string()],
                downloads: 890,
                rating: Some(4.2),
            },
            RegistryPlugin {
                id: "emoji-picker".to_string(),
                name: "Emoji Picker".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Search and insert emojis quickly. Supports skin tone modifiers.".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/emoji-picker/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string()],
                categories: vec!["Utilities".to_string(), "Fun".to_string()],
                downloads: 2100,
                rating: Some(4.8),
            },
            RegistryPlugin {
                id: "color-picker".to_string(),
                name: "Color Picker".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Pick colors from screen, convert between formats (HEX, RGB, HSL).".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/color-picker/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string()],
                categories: vec!["Design".to_string(), "Development".to_string()],
                downloads: 1560,
                rating: Some(4.6),
            },
            RegistryPlugin {
                id: "linear".to_string(),
                name: "Linear".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Search and create Linear issues. View assigned tasks and project status.".to_string()),
                homepage: Some("https://linear.app".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/linear/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["network".to_string(), "oauth:linear".to_string()],
                categories: vec!["Productivity".to_string(), "Development".to_string(), "Project Management".to_string()],
                downloads: 3200,
                rating: Some(4.7),
            },
            RegistryPlugin {
                id: "jira".to_string(),
                name: "Jira".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Search Jira issues, view sprint boards, and create new tickets.".to_string()),
                homepage: Some("https://www.atlassian.com/software/jira".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/jira/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["network".to_string(), "oauth:jira".to_string()],
                categories: vec!["Productivity".to_string(), "Development".to_string(), "Project Management".to_string()],
                downloads: 4500,
                rating: Some(4.3),
            },
            RegistryPlugin {
                id: "todoist".to_string(),
                name: "Todoist".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Manage Todoist tasks. Add, complete, and search your to-dos.".to_string()),
                homepage: Some("https://todoist.com".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/todoist/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["network".to_string(), "oauth:todoist".to_string()],
                categories: vec!["Productivity".to_string(), "Tasks".to_string()],
                downloads: 2800,
                rating: Some(4.6),
            },
            RegistryPlugin {
                id: "things".to_string(),
                name: "Things 3".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Quick add tasks to Things 3. Search and complete your to-dos. (macOS only)".to_string()),
                homepage: Some("https://culturedcode.com/things/".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/things/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["applescript".to_string()],
                categories: vec!["Productivity".to_string(), "Tasks".to_string()],
                downloads: 1200,
                rating: Some(4.8),
            },
            RegistryPlugin {
                id: "1password".to_string(),
                name: "1Password".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Search and copy passwords from 1Password. Requires 1Password CLI.".to_string()),
                homepage: Some("https://1password.com".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/1password/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string(), "shell:op".to_string()],
                categories: vec!["Security".to_string(), "Utilities".to_string()],
                downloads: 5600,
                rating: Some(4.9),
            },
            RegistryPlugin {
                id: "bitwarden".to_string(),
                name: "Bitwarden".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Search and copy passwords from Bitwarden vault.".to_string()),
                homepage: Some("https://bitwarden.com".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/bitwarden/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["clipboard".to_string(), "shell:bw".to_string()],
                categories: vec!["Security".to_string(), "Utilities".to_string()],
                downloads: 3400,
                rating: Some(4.5),
            },
            RegistryPlugin {
                id: "spotify".to_string(),
                name: "Spotify".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Control Spotify playback. Search tracks, albums, and playlists.".to_string()),
                homepage: Some("https://spotify.com".to_string()),
                repository: None,
                download_url: "https://plugins.launcher.dev/spotify/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["network".to_string(), "oauth:spotify".to_string()],
                categories: vec!["Media".to_string(), "Music".to_string()],
                downloads: 6200,
                rating: Some(4.7),
            },
            RegistryPlugin {
                id: "docker".to_string(),
                name: "Docker".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Manage Docker containers. Start, stop, and view logs.".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/docker/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["shell:docker".to_string()],
                categories: vec!["Development".to_string(), "DevOps".to_string()],
                downloads: 2100,
                rating: Some(4.4),
            },
            RegistryPlugin {
                id: "ssh".to_string(),
                name: "SSH Connections".to_string(),
                version: "1.0.0".to_string(),
                author: Some("Community".to_string()),
                description: Some("Quick connect to SSH hosts from ~/.ssh/config.".to_string()),
                homepage: None,
                repository: None,
                download_url: "https://plugins.launcher.dev/ssh/1.0.0.zip".to_string(),
                checksum: None,
                permissions: vec!["filesystem:read".to_string(), "shell:ssh".to_string()],
                categories: vec!["Development".to_string(), "DevOps".to_string(), "Utilities".to_string()],
                downloads: 1800,
                rating: Some(4.3),
            },
        ];

        let mut registry = self.plugins.write();
        for plugin in featured {
            registry.insert(plugin.id.clone(), plugin);
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/plugins/runtime.rs">
use super::host_api::{DefaultHostApi, PluginHostApi, PluginSearchResult};
use super::manifest::LoadedPlugin;
use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;
use wasmtime::*;

pub struct PluginRuntime {
    engine: Engine,
    instances: RwLock<HashMap<String, PluginInstance>>,
    host_api: Arc<dyn PluginHostApi>,
}

struct PluginInstance {
    _module: Module,
    store: Store<PluginState>,
    instance: Instance,
}

struct PluginState {
    plugin_id: String,
    host_api: Arc<dyn PluginHostApi>,
}

impl PluginRuntime {
    pub fn new() -> Result<Self, String> {
        let engine = Engine::default();

        Ok(Self {
            engine,
            instances: RwLock::new(HashMap::new()),
            host_api: Arc::new(DefaultHostApi::new()),
        })
    }

    pub fn load_plugin(&self, plugin: &LoadedPlugin) -> Result<(), String> {
        let module = Module::new(&self.engine, &plugin.wasm_bytes)
            .map_err(|e| format!("Failed to compile WASM module: {}", e))?;

        let mut store = Store::new(
            &self.engine,
            PluginState {
                plugin_id: plugin.manifest.id.clone(),
                host_api: self.host_api.clone(),
            },
        );

        let mut linker = Linker::new(&self.engine);

        self.register_host_functions(&mut linker)?;

        let instance = linker
            .instantiate(&mut store, &module)
            .map_err(|e| format!("Failed to instantiate WASM module: {}", e))?;

        if let Some(init) = instance.get_func(&mut store, "init") {
            init.call(&mut store, &[], &mut [])
                .map_err(|e| format!("Plugin init failed: {}", e))?;
        }

        let plugin_instance = PluginInstance {
            _module: module,
            store,
            instance,
        };

        let mut instances = self.instances.write();
        instances.insert(plugin.manifest.id.clone(), plugin_instance);

        Ok(())
    }

    fn register_host_functions(&self, linker: &mut Linker<PluginState>) -> Result<(), String> {
        linker
            .func_wrap("env", "host_log", |mut caller: Caller<'_, PluginState>, ptr: i32, len: i32| {
                let mem = caller.get_export("memory").and_then(|e| e.into_memory());
                if let Some(memory) = mem {
                    let data = memory.data(&caller);
                    if let Some(slice) = data.get(ptr as usize..(ptr + len) as usize) {
                        if let Ok(message) = std::str::from_utf8(slice) {
                            let state = caller.data();
                            state.host_api.log(&state.plugin_id, "info", message);
                        }
                    }
                }
            })
            .map_err(|e| format!("Failed to register host_log: {}", e))?;

        Ok(())
    }

    pub fn call_search(&self, plugin_id: &str, query: &str) -> Result<Vec<PluginSearchResult>, String> {
        let mut instances = self.instances.write();
        let instance = instances
            .get_mut(plugin_id)
            .ok_or_else(|| format!("Plugin not loaded: {}", plugin_id))?;

        let search_fn = instance
            .instance
            .get_func(&mut instance.store, "search")
            .ok_or("Plugin does not export 'search' function")?;

        let alloc_fn = instance
            .instance
            .get_func(&mut instance.store, "alloc")
            .ok_or("Plugin does not export 'alloc' function")?;

        let memory = instance
            .instance
            .get_memory(&mut instance.store, "memory")
            .ok_or("Plugin does not export 'memory'")?;

        let query_bytes = query.as_bytes();
        let query_len = query_bytes.len() as i32;

        let mut alloc_result = [Val::I32(0)];
        alloc_fn
            .call(&mut instance.store, &[Val::I32(query_len)], &mut alloc_result)
            .map_err(|e| format!("Failed to allocate memory: {}", e))?;

        let query_ptr = alloc_result[0].unwrap_i32();

        memory
            .write(&mut instance.store, query_ptr as usize, query_bytes)
            .map_err(|e| format!("Failed to write query to memory: {}", e))?;

        let mut search_result = [Val::I32(0)];
        search_fn
            .call(
                &mut instance.store,
                &[Val::I32(query_ptr), Val::I32(query_len)],
                &mut search_result,
            )
            .map_err(|e| format!("Search call failed: {}", e))?;

        Ok(vec![])
    }

    pub fn unload_plugin(&self, plugin_id: &str) -> Result<(), String> {
        let mut instances = self.instances.write();

        if let Some(mut instance) = instances.remove(plugin_id) {
            if let Some(shutdown) = instance.instance.get_func(&mut instance.store, "shutdown") {
                let _ = shutdown.call(&mut instance.store, &[], &mut []);
            }
        }

        Ok(())
    }

    pub fn is_loaded(&self, plugin_id: &str) -> bool {
        let instances = self.instances.read();
        instances.contains_key(plugin_id)
    }

    pub fn loaded_plugin_ids(&self) -> Vec<String> {
        let instances = self.instances.read();
        instances.keys().cloned().collect()
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/apps.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use freedesktop_desktop_entry::{default_paths, DesktopEntry, Iter};
use std::collections::HashMap;
use std::sync::RwLock;

pub struct AppProvider {
    apps: RwLock<Vec<AppEntry>>,
}

#[derive(Debug, Clone)]
struct AppEntry {
    id: String,
    name: String,
    generic_name: Option<String>,
    comment: Option<String>,
    exec: String,
    icon: Option<String>,
    keywords: Vec<String>,
}

impl AppProvider {
    pub fn new() -> Self {
        let provider = Self {
            apps: RwLock::new(Vec::new()),
        };
        provider.refresh_apps();
        provider
    }

    pub fn refresh_apps(&self) {
        let mut apps = Vec::new();
        let mut seen: HashMap<String, bool> = HashMap::new();
        let locales = &["en"];

        for path in Iter::new(default_paths()) {
            if let Ok(entry_data) = std::fs::read_to_string(&path) {
                if let Ok(desktop) = DesktopEntry::from_str(&path, &entry_data, Some(locales)) {
                    if desktop.no_display() {
                        continue;
                    }

                    let name = desktop.name(locales).unwrap_or_default().to_string();
                    if name.is_empty() || seen.contains_key(&name) {
                        continue;
                    }
                    seen.insert(name.clone(), true);

                    let exec = desktop.exec().unwrap_or_default().to_string();
                    if exec.is_empty() {
                        continue;
                    }

                    let exec_clean = exec
                        .split_whitespace()
                        .next()
                        .unwrap_or(&exec)
                        .replace("%u", "")
                        .replace("%U", "")
                        .replace("%f", "")
                        .replace("%F", "");

                    let keywords: Vec<String> = desktop
                        .keywords(locales)
                        .map(|k| k.iter().map(|s| s.to_string()).collect())
                        .unwrap_or_default();

                    apps.push(AppEntry {
                        id: path.to_string_lossy().to_string(),
                        name: name.clone(),
                        generic_name: desktop.generic_name(locales).map(|s| s.to_string()),
                        comment: desktop.comment(locales).map(|s| s.to_string()),
                        exec: exec_clean,
                        icon: desktop.icon().map(|s| s.to_string()),
                        keywords,
                    });
                }
            }
        }

        if let Ok(mut lock) = self.apps.write() {
            *lock = apps;
        }
    }

    fn score_match(query: &str, app: &AppEntry) -> f32 {
        let query_lower = query.to_lowercase();
        let name_lower = app.name.to_lowercase();

        if name_lower == query_lower {
            return 100.0;
        }

        if name_lower.starts_with(&query_lower) {
            return 90.0 + (query_lower.len() as f32 / name_lower.len() as f32) * 10.0;
        }

        if name_lower.contains(&query_lower) {
            return 70.0 + (query_lower.len() as f32 / name_lower.len() as f32) * 10.0;
        }

        if let Some(ref generic) = app.generic_name {
            let generic_lower = generic.to_lowercase();
            if generic_lower.contains(&query_lower) {
                return 50.0;
            }
        }

        for keyword in &app.keywords {
            if keyword.to_lowercase().contains(&query_lower) {
                return 40.0;
            }
        }

        if let Some(ref comment) = app.comment {
            if comment.to_lowercase().contains(&query_lower) {
                return 30.0;
            }
        }

        0.0
    }
}

impl SearchProvider for AppProvider {
    fn id(&self) -> &str {
        "apps"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        if query.trim().is_empty() {
            return vec![];
        }

        let apps = match self.apps.read() {
            Ok(lock) => lock,
            Err(_) => return vec![],
        };

        let mut results: Vec<SearchResult> = apps
            .iter()
            .filter_map(|app| {
                let score = Self::score_match(query, app);
                if score > 0.0 {
                    Some(SearchResult {
                        id: format!("app:{}", app.id),
                        title: app.name.clone(),
                        subtitle: app.generic_name.clone().or(app.comment.clone()),
                        icon: app
                            .icon
                            .clone()
                            .map(ResultIcon::Text)
                            .unwrap_or(ResultIcon::Emoji("ðŸ“¦".to_string())),
                        category: ResultCategory::Application,
                        score,
                    })
                } else {
                    None
                }
            })
            .collect();

        results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());
        results.truncate(10);
        results
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if let Some(desktop_path) = result_id.strip_prefix("app:") {
            let apps = self.apps.read().map_err(|e| e.to_string())?;
            if let Some(app) = apps.iter().find(|a| a.id == desktop_path) {
                std::process::Command::new("sh")
                    .arg("-c")
                    .arg(&app.exec)
                    .spawn()
                    .map_err(|e| e.to_string())?;
                Ok(())
            } else {
                Err("App not found".to_string())
            }
        } else {
            Err("Invalid app result".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/calculator.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};

pub struct CalculatorProvider;

impl CalculatorProvider {
    pub fn new() -> Self {
        Self
    }

    fn is_math_expression(query: &str) -> bool {
        let trimmed = query.trim();
        if trimmed.is_empty() {
            return false;
        }

        let has_operator = trimmed.contains('+')
            || trimmed.contains('-')
            || trimmed.contains('*')
            || trimmed.contains('/')
            || trimmed.contains('^')
            || trimmed.contains('%')
            || trimmed.contains('(');

        let has_math_func = trimmed.starts_with("sqrt")
            || trimmed.starts_with("sin")
            || trimmed.starts_with("cos")
            || trimmed.starts_with("tan")
            || trimmed.starts_with("log")
            || trimmed.starts_with("ln")
            || trimmed.starts_with("abs")
            || trimmed.starts_with("floor")
            || trimmed.starts_with("ceil");

        has_operator || has_math_func
    }
}

impl SearchProvider for CalculatorProvider {
    fn id(&self) -> &str {
        "calculator"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        if !Self::is_math_expression(query) {
            return vec![];
        }

        match meval::eval_str(query) {
            Ok(result) => {
                let formatted = if result.fract() == 0.0 && result.abs() < 1e15 {
                    format!("{}", result as i64)
                } else {
                    format!("{:.10}", result)
                        .trim_end_matches('0')
                        .trim_end_matches('.')
                        .to_string()
                };

                vec![SearchResult {
                    id: format!("calc:{}", formatted),
                    title: formatted,
                    subtitle: Some(format!("= {}", query)),
                    icon: ResultIcon::Emoji("ðŸ”¢".to_string()),
                    category: ResultCategory::Calculator,
                    score: 1000.0,
                }]
            }
            Err(_) => vec![],
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if let Some(value) = result_id.strip_prefix("calc:") {
            println!("Copy to clipboard: {}", value);
            Ok(())
        } else {
            Err("Invalid calculator result".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/files.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::indexer::{FileIndexer, FileWatcher, IndexConfig};
use parking_lot::{Mutex, RwLock};
use std::path::PathBuf;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

pub struct FileProvider {
    indexer: Arc<RwLock<Option<FileIndexer>>>,
    watcher: Arc<Mutex<Option<FileWatcher>>>,
    config: Arc<RwLock<Option<IndexConfig>>>,
    watcher_running: Arc<AtomicBool>,
}

impl FileProvider {
    pub fn new() -> Self {
        Self {
            indexer: Arc::new(RwLock::new(None)),
            watcher: Arc::new(Mutex::new(None)),
            config: Arc::new(RwLock::new(None)),
            watcher_running: Arc::new(AtomicBool::new(false)),
        }
    }

    pub fn get_config(&self) -> IndexConfig {
        self.config.read().clone().unwrap_or_default()
    }

    pub fn set_config(&self, config: IndexConfig) {
        let mut lock = self.config.write();
        *lock = Some(config);
    }

    pub fn initialize(&self) -> Result<usize, String> {
        let config = IndexConfig::load();

        let index_dir = dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("launcher")
            .join("index");

        let indexer = FileIndexer::new(index_dir, config.clone())?;
        let count = indexer.index_all()?;

        {
            let mut lock = self.indexer.write();
            *lock = Some(indexer);
        }

        {
            let mut lock = self.config.write();
            *lock = Some(config);
        }

        Ok(count)
    }

    pub fn start_watcher(&self) -> Result<(), String> {
        let config = self.config.read();
        let config = config.as_ref().ok_or("Config not initialized")?;

        let watcher = FileWatcher::new(config.index_paths.clone())?;

        {
            let mut lock = self.watcher.lock();
            *lock = Some(watcher);
        }

        self.watcher_running.store(true, Ordering::SeqCst);
        Ok(())
    }

    pub fn process_watcher_events(&self) -> usize {
        if !self.watcher_running.load(Ordering::SeqCst) {
            return 0;
        }

        let changed_paths = {
            let watcher_lock = self.watcher.lock();
            match watcher_lock.as_ref() {
                Some(w) => w.poll_events(),
                None => return 0,
            }
        };

        if changed_paths.is_empty() {
            return 0;
        }

        let config_lock = self.config.read();
        let config = match config_lock.as_ref() {
            Some(c) => c,
            None => return 0,
        };

        let indexer_lock = self.indexer.read();
        let indexer = match indexer_lock.as_ref() {
            Some(i) => i,
            None => return 0,
        };

        let mut updated = 0;
        for path in &changed_paths {
            if config.should_exclude(path) {
                continue;
            }

            if let Err(e) = indexer.update_file(path) {
                eprintln!("Failed to update index for {}: {}", path.display(), e);
            } else {
                updated += 1;
            }
        }

        if updated > 0 {
            let _ = indexer.commit();
        }

        updated
    }

    pub fn is_initialized(&self) -> bool {
        self.indexer.read().is_some()
    }

    pub fn reindex(&self) -> Result<usize, String> {
        let lock = self.indexer.read();
        if let Some(indexer) = lock.as_ref() {
            indexer.index_all()
        } else {
            Err("Indexer not initialized".to_string())
        }
    }

    pub fn update_file(&self, path: &std::path::Path) -> Result<(), String> {
        let lock = self.indexer.read();
        if let Some(indexer) = lock.as_ref() {
            indexer.update_file(path)?;
            indexer.commit()?;
        }
        Ok(())
    }

    fn get_file_icon(extension: &Option<String>, is_dir: bool) -> ResultIcon {
        if is_dir {
            return ResultIcon::Emoji("ðŸ“".to_string());
        }

        let emoji = match extension.as_deref() {
            Some("rs") => "ðŸ¦€",
            Some("py") => "ðŸ",
            Some("js") | Some("ts") | Some("jsx") | Some("tsx") => "ðŸ“œ",
            Some("html") => "ðŸŒ",
            Some("css") | Some("scss") | Some("sass") => "ðŸŽ¨",
            Some("json") | Some("yaml") | Some("yml") | Some("toml") => "âš™ï¸",
            Some("md") | Some("txt") => "ðŸ“",
            Some("pdf") => "ðŸ“•",
            Some("png") | Some("jpg") | Some("jpeg") | Some("gif") | Some("svg") | Some("webp") => "ðŸ–¼ï¸",
            Some("mp3") | Some("wav") | Some("flac") | Some("ogg") => "ðŸŽµ",
            Some("mp4") | Some("mkv") | Some("avi") | Some("mov") => "ðŸŽ¬",
            Some("zip") | Some("tar") | Some("gz") | Some("7z") | Some("rar") => "ðŸ“¦",
            Some("sh") | Some("bash") | Some("zsh") => "ðŸ’»",
            Some("go") => "ðŸ¹",
            Some("java") | Some("kt") => "â˜•",
            Some("c") | Some("cpp") | Some("h") | Some("hpp") => "âš¡",
            Some("sql") | Some("db") => "ðŸ—ƒï¸",
            _ => "ðŸ“„",
        };

        ResultIcon::Emoji(emoji.to_string())
    }

    fn format_size(size: u64) -> String {
        const KB: u64 = 1024;
        const MB: u64 = KB * 1024;
        const GB: u64 = MB * 1024;

        if size >= GB {
            format!("{:.1} GB", size as f64 / GB as f64)
        } else if size >= MB {
            format!("{:.1} MB", size as f64 / MB as f64)
        } else if size >= KB {
            format!("{:.1} KB", size as f64 / KB as f64)
        } else {
            format!("{} B", size)
        }
    }
}

impl SearchProvider for FileProvider {
    fn id(&self) -> &str {
        "files"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        if query.trim().len() < 2 {
            return vec![];
        }

        let lock = self.indexer.read();
        let indexer = match lock.as_ref() {
            Some(i) => i,
            None => return vec![],
        };

        let files = match indexer.fuzzy_search(query, 15) {
            Ok(f) => f,
            Err(_) => return vec![],
        };

        files
            .into_iter()
            .enumerate()
            .map(|(idx, file)| {
                let subtitle = if file.is_dir {
                    file.path.clone()
                } else {
                    format!("{} â€¢ {}", Self::format_size(file.size), file.path)
                };

                SearchResult {
                    id: format!("file:{}", file.path),
                    title: file.name,
                    subtitle: Some(subtitle),
                    icon: Self::get_file_icon(&file.extension, file.is_dir),
                    category: ResultCategory::File,
                    score: 50.0 - (idx as f32 * 0.5),
                }
            })
            .collect()
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if let Some(path) = result_id.strip_prefix("file:") {
            let path = std::path::Path::new(path);

            if path.is_dir() {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(path)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }

                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(path)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }

                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("explorer")
                        .arg(path)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
            } else {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(path)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }

                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(path)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }

                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", &path.to_string_lossy()])
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
            }

            Ok(())
        } else {
            Err("Invalid file result".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/github.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::oauth::OAuthFlow;
use parking_lot::RwLock;
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;

pub struct GitHubProvider {
    oauth_flow: Arc<OAuthFlow>,
    cache: RwLock<SearchCache>,
}

struct SearchCache {
    query: String,
    results: Vec<SearchResult>,
    urls: HashMap<String, String>,
    timestamp: std::time::Instant,
}

impl SearchCache {
    fn new() -> Self {
        Self {
            query: String::new(),
            results: Vec::new(),
            urls: HashMap::new(),
            timestamp: std::time::Instant::now(),
        }
    }

    fn is_valid(&self, query: &str) -> bool {
        self.query == query && self.timestamp.elapsed().as_secs() < 60
    }
}

#[derive(Debug, Deserialize)]
struct GitHubSearchResponse {
    items: Vec<GitHubRepo>,
}

#[derive(Debug, Deserialize)]
struct GitHubRepo {
    id: u64,
    full_name: String,
    description: Option<String>,
    html_url: String,
    stargazers_count: u32,
    language: Option<String>,
}

impl GitHubProvider {
    pub fn new(oauth_flow: Arc<OAuthFlow>) -> Self {
        Self {
            oauth_flow,
            cache: RwLock::new(SearchCache::new()),
        }
    }

    fn get_token_sync(&self) -> Option<String> {
        self.oauth_flow.get_token_if_valid("github")
    }

    fn search_github(&self, query: &str) -> Vec<SearchResult> {
        if query.len() < 2 {
            return Vec::new();
        }

        // Check cache first
        {
            let cache = self.cache.read();
            if cache.is_valid(query) {
                return cache.results.clone();
            }
        }

        // Check if connected to GitHub
        if !self.oauth_flow.is_connected("github") {
            return vec![SearchResult {
                id: "github:connect".to_string(),
                title: "Connect GitHub".to_string(),
                subtitle: Some("Go to Settings â†’ Accounts to connect GitHub".to_string()),
                icon: ResultIcon::Emoji("ðŸ”—".to_string()),
                category: ResultCategory::GitHub,
                score: 50.0,
            }];
        }

        // Get token synchronously (non-expired only)
        let token = match self.get_token_sync() {
            Some(t) => t,
            None => return Vec::new(),
        };

        // Make GitHub API request
        let client = reqwest::blocking::Client::new();
        let response = client
            .get("https://api.github.com/search/repositories")
            .query(&[("q", query), ("per_page", "8")])
            .header("Authorization", format!("Bearer {}", token))
            .header("Accept", "application/vnd.github+json")
            .header("User-Agent", "Launcher-App")
            .header("X-GitHub-Api-Version", "2022-11-28")
            .send();

        let (results, urls): (Vec<SearchResult>, HashMap<String, String>) = match response {
            Ok(resp) if resp.status().is_success() => {
                match resp.json::<GitHubSearchResponse>() {
                    Ok(data) => {
                        let mut urls = HashMap::new();
                        let results = data
                            .items
                            .into_iter()
                            .enumerate()
                            .map(|(i, repo)| {
                                let id = format!("github:repo:{}", repo.id);
                                urls.insert(id.clone(), repo.html_url);
                                
                                let lang = repo.language.as_deref().unwrap_or("");
                                let subtitle = match &repo.description {
                                    Some(desc) if !desc.is_empty() => desc.clone(),
                                    _ => format!("â­ {} Â· {}", repo.stargazers_count, lang),
                                };
                                
                                SearchResult {
                                    id,
                                    title: repo.full_name,
                                    subtitle: Some(subtitle),
                                    icon: ResultIcon::Emoji("ðŸ“¦".to_string()),
                                    category: ResultCategory::GitHub,
                                    score: 100.0 - (i as f32 * 5.0),
                                }
                            })
                            .collect();
                        (results, urls)
                    }
                    Err(_) => (Vec::new(), HashMap::new()),
                }
            }
            Ok(resp) => {
                eprintln!("GitHub API error: {}", resp.status());
                (Vec::new(), HashMap::new())
            }
            Err(e) => {
                eprintln!("GitHub request failed: {}", e);
                (Vec::new(), HashMap::new())
            }
        };

        // Update cache
        {
            let mut cache = self.cache.write();
            cache.query = query.to_string();
            cache.results = results.clone();
            cache.urls = urls;
            cache.timestamp = std::time::Instant::now();
        }

        results
    }
}

impl SearchProvider for GitHubProvider {
    fn id(&self) -> &str {
        "github"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        // Only search GitHub if query starts with "gh " prefix
        if let Some(gh_query) = query.strip_prefix("gh ") {
            self.search_github(gh_query.trim())
        } else {
            Vec::new()
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if result_id == "github:connect" {
            return Ok(());
        }
        
        if result_id.starts_with("github:repo:") {
            let cache = self.cache.read();
            if let Some(url) = cache.urls.get(result_id) {
                std::process::Command::new("xdg-open")
                    .arg(url)
                    .spawn()
                    .map_err(|e| e.to_string())?;
                return Ok(());
            }
            Err("Repository URL not found".to_string())
        } else {
            Err("Invalid GitHub result ID".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/google_calendar.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::oauth::OAuthFlow;
use parking_lot::RwLock;
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;
use chrono::{DateTime, Utc, Local};

pub struct GoogleCalendarProvider {
    oauth_flow: Arc<OAuthFlow>,
    cache: RwLock<SearchCache>,
}

struct SearchCache {
    query: String,
    results: Vec<SearchResult>,
    urls: HashMap<String, String>,
    timestamp: std::time::Instant,
}

impl SearchCache {
    fn new() -> Self {
        Self {
            query: String::new(),
            results: Vec::new(),
            urls: HashMap::new(),
            timestamp: std::time::Instant::now(),
        }
    }

    fn is_valid(&self, query: &str) -> bool {
        self.query == query && self.timestamp.elapsed().as_secs() < 60
    }
}

#[derive(Debug, Deserialize)]
struct CalendarListResponse {
    items: Option<Vec<CalendarEvent>>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CalendarEvent {
    id: String,
    summary: Option<String>,
    description: Option<String>,
    html_link: Option<String>,
    start: Option<EventTime>,
    end: Option<EventTime>,
    location: Option<String>,
    organizer: Option<EventOrganizer>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct EventTime {
    date_time: Option<String>,
    date: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct EventOrganizer {
    display_name: Option<String>,
    email: Option<String>,
}

impl GoogleCalendarProvider {
    pub fn new(oauth_flow: Arc<OAuthFlow>) -> Self {
        Self {
            oauth_flow,
            cache: RwLock::new(SearchCache::new()),
        }
    }

    fn get_token_sync(&self) -> Option<String> {
        self.oauth_flow.get_token_if_valid("google")
    }

    fn format_event_time(event: &CalendarEvent) -> String {
        if let Some(start) = &event.start {
            if let Some(dt_str) = &start.date_time {
                if let Ok(dt) = DateTime::parse_from_rfc3339(dt_str) {
                    let local: DateTime<Local> = dt.into();
                    return local.format("%b %d, %H:%M").to_string();
                }
            }
            if let Some(date) = &start.date {
                return format!("{} (All day)", date);
            }
        }
        "No time".to_string()
    }

    fn search_calendar(&self, query: &str) -> Vec<SearchResult> {
        if query.len() < 2 {
            return Vec::new();
        }

        // Check cache first
        {
            let cache = self.cache.read();
            if cache.is_valid(query) {
                return cache.results.clone();
            }
        }

        // Check if connected to Google
        if !self.oauth_flow.is_connected("google") {
            return vec![SearchResult {
                id: "google:connect".to_string(),
                title: "Connect Google".to_string(),
                subtitle: Some("Go to Settings â†’ Accounts to connect Google".to_string()),
                icon: ResultIcon::Emoji("ðŸ”—".to_string()),
                category: ResultCategory::Plugin,
                score: 50.0,
            }];
        }

        // Get token synchronously
        let token = match self.get_token_sync() {
            Some(t) => t,
            None => return Vec::new(),
        };

        // Get time range (now to 30 days from now)
        let now = Utc::now();
        let time_min = now.to_rfc3339();
        let time_max = (now + chrono::Duration::days(30)).to_rfc3339();

        // Make Google Calendar API request
        let client = reqwest::blocking::Client::new();
        let response = client
            .get("https://www.googleapis.com/calendar/v3/calendars/primary/events")
            .query(&[
                ("q", query),
                ("timeMin", &time_min),
                ("timeMax", &time_max),
                ("maxResults", "10"),
                ("singleEvents", "true"),
                ("orderBy", "startTime"),
            ])
            .header("Authorization", format!("Bearer {}", token))
            .send();

        let (results, urls): (Vec<SearchResult>, HashMap<String, String>) = match response {
            Ok(resp) if resp.status().is_success() => {
                match resp.json::<CalendarListResponse>() {
                    Ok(data) => {
                        let mut urls = HashMap::new();
                        let results = data
                            .items
                            .unwrap_or_default()
                            .into_iter()
                            .enumerate()
                            .map(|(i, event)| {
                                let id = format!("gcal:event:{}", event.id);
                                if let Some(link) = &event.html_link {
                                    urls.insert(id.clone(), link.clone());
                                }
                                
                                let title = event.summary.clone().unwrap_or_else(|| "(No title)".to_string());
                                let time = Self::format_event_time(&event);
                                let location = event.location.as_deref().unwrap_or("");
                                
                                let subtitle = if location.is_empty() {
                                    time
                                } else {
                                    format!("{} â€¢ {}", time, location)
                                };
                                
                                SearchResult {
                                    id,
                                    title,
                                    subtitle: Some(subtitle),
                                    icon: ResultIcon::Emoji("ðŸ“…".to_string()),
                                    category: ResultCategory::Plugin,
                                    score: 100.0 - (i as f32 * 5.0),
                                }
                            })
                            .collect();
                        (results, urls)
                    }
                    Err(e) => {
                        eprintln!("Failed to parse Calendar response: {}", e);
                        (Vec::new(), HashMap::new())
                    }
                }
            }
            Ok(resp) => {
                eprintln!("Google Calendar API error: {}", resp.status());
                (Vec::new(), HashMap::new())
            }
            Err(e) => {
                eprintln!("Google Calendar request failed: {}", e);
                (Vec::new(), HashMap::new())
            }
        };

        // Update cache
        {
            let mut cache = self.cache.write();
            cache.query = query.to_string();
            cache.results = results.clone();
            cache.urls = urls;
            cache.timestamp = std::time::Instant::now();
        }

        results
    }
}

impl SearchProvider for GoogleCalendarProvider {
    fn id(&self) -> &str {
        "google_calendar"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        // Only search Google Calendar if query starts with "gc " prefix
        if let Some(cal_query) = query.strip_prefix("gc ") {
            self.search_calendar(cal_query.trim())
        } else {
            Vec::new()
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if result_id == "google:connect" {
            return Ok(());
        }
        
        if result_id.starts_with("gcal:event:") {
            let cache = self.cache.read();
            if let Some(url) = cache.urls.get(result_id) {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", url])
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                return Ok(());
            }
            Err("Event URL not found".to_string())
        } else {
            Err("Invalid Google Calendar result ID".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/google_drive.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::oauth::OAuthFlow;
use parking_lot::RwLock;
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;

pub struct GoogleDriveProvider {
    oauth_flow: Arc<OAuthFlow>,
    cache: RwLock<SearchCache>,
}

struct SearchCache {
    query: String,
    results: Vec<SearchResult>,
    urls: HashMap<String, String>,
    timestamp: std::time::Instant,
}

impl SearchCache {
    fn new() -> Self {
        Self {
            query: String::new(),
            results: Vec::new(),
            urls: HashMap::new(),
            timestamp: std::time::Instant::now(),
        }
    }

    fn is_valid(&self, query: &str) -> bool {
        self.query == query && self.timestamp.elapsed().as_secs() < 60
    }
}

#[derive(Debug, Deserialize)]
struct DriveSearchResponse {
    files: Option<Vec<DriveFile>>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct DriveFile {
    id: String,
    name: String,
    mime_type: String,
    web_view_link: Option<String>,
    icon_link: Option<String>,
    modified_time: Option<String>,
    owners: Option<Vec<DriveOwner>>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct DriveOwner {
    display_name: String,
}

impl GoogleDriveProvider {
    pub fn new(oauth_flow: Arc<OAuthFlow>) -> Self {
        Self {
            oauth_flow,
            cache: RwLock::new(SearchCache::new()),
        }
    }

    fn get_token_sync(&self) -> Option<String> {
        self.oauth_flow.get_token_if_valid("google")
    }

    fn get_file_emoji(mime_type: &str) -> &'static str {
        match mime_type {
            "application/vnd.google-apps.document" => "ðŸ“„",
            "application/vnd.google-apps.spreadsheet" => "ðŸ“Š",
            "application/vnd.google-apps.presentation" => "ðŸ“½ï¸",
            "application/vnd.google-apps.form" => "ðŸ“",
            "application/vnd.google-apps.folder" => "ðŸ“",
            "application/pdf" => "ðŸ“•",
            "image/jpeg" | "image/png" | "image/gif" | "image/webp" => "ðŸ–¼ï¸",
            "video/mp4" | "video/quicktime" | "video/webm" => "ðŸŽ¬",
            "audio/mpeg" | "audio/wav" | "audio/ogg" => "ðŸŽµ",
            "application/zip" | "application/x-rar-compressed" => "ðŸ“¦",
            _ if mime_type.starts_with("text/") => "ðŸ“ƒ",
            _ if mime_type.starts_with("application/vnd.google-apps") => "ðŸ“„",
            _ => "ðŸ“„",
        }
    }

    fn get_file_type_name(mime_type: &str) -> &'static str {
        match mime_type {
            "application/vnd.google-apps.document" => "Google Doc",
            "application/vnd.google-apps.spreadsheet" => "Google Sheet",
            "application/vnd.google-apps.presentation" => "Google Slides",
            "application/vnd.google-apps.form" => "Google Form",
            "application/vnd.google-apps.folder" => "Folder",
            "application/pdf" => "PDF",
            "image/jpeg" => "JPEG Image",
            "image/png" => "PNG Image",
            "image/gif" => "GIF",
            "video/mp4" => "MP4 Video",
            "audio/mpeg" => "MP3 Audio",
            "application/zip" => "ZIP Archive",
            "text/plain" => "Text File",
            _ if mime_type.starts_with("image/") => "Image",
            _ if mime_type.starts_with("video/") => "Video",
            _ if mime_type.starts_with("audio/") => "Audio",
            _ => "File",
        }
    }

    fn search_drive(&self, query: &str) -> Vec<SearchResult> {
        if query.len() < 2 {
            return Vec::new();
        }

        // Check cache first
        {
            let cache = self.cache.read();
            if cache.is_valid(query) {
                return cache.results.clone();
            }
        }

        // Check if connected to Google
        if !self.oauth_flow.is_connected("google") {
            return vec![SearchResult {
                id: "google:connect".to_string(),
                title: "Connect Google".to_string(),
                subtitle: Some("Go to Settings â†’ Accounts to connect Google".to_string()),
                icon: ResultIcon::Emoji("ðŸ”—".to_string()),
                category: ResultCategory::Plugin,
                score: 50.0,
            }];
        }

        // Get token synchronously
        let token = match self.get_token_sync() {
            Some(t) => t,
            None => return Vec::new(),
        };

        // Make Google Drive API request
        let client = reqwest::blocking::Client::new();
        let search_query = format!("name contains '{}' and trashed = false", query);
        let response = client
            .get("https://www.googleapis.com/drive/v3/files")
            .query(&[
                ("q", search_query.as_str()),
                ("pageSize", "10"),
                ("fields", "files(id,name,mimeType,webViewLink,iconLink,modifiedTime,owners)"),
                ("orderBy", "modifiedTime desc"),
            ])
            .header("Authorization", format!("Bearer {}", token))
            .send();

        let (results, urls): (Vec<SearchResult>, HashMap<String, String>) = match response {
            Ok(resp) if resp.status().is_success() => {
                match resp.json::<DriveSearchResponse>() {
                    Ok(data) => {
                        let mut urls = HashMap::new();
                        let results = data
                            .files
                            .unwrap_or_default()
                            .into_iter()
                            .enumerate()
                            .map(|(i, file)| {
                                let id = format!("gdrive:file:{}", file.id);
                                if let Some(link) = file.web_view_link {
                                    urls.insert(id.clone(), link);
                                }
                                
                                let file_type = Self::get_file_type_name(&file.mime_type);
                                let owner = file.owners
                                    .and_then(|o| o.first().map(|o| o.display_name.clone()))
                                    .unwrap_or_default();
                                
                                let subtitle = if owner.is_empty() {
                                    file_type.to_string()
                                } else {
                                    format!("{} â€¢ {}", file_type, owner)
                                };
                                
                                SearchResult {
                                    id,
                                    title: file.name,
                                    subtitle: Some(subtitle),
                                    icon: ResultIcon::Emoji(Self::get_file_emoji(&file.mime_type).to_string()),
                                    category: ResultCategory::Plugin,
                                    score: 100.0 - (i as f32 * 5.0),
                                }
                            })
                            .collect();
                        (results, urls)
                    }
                    Err(e) => {
                        eprintln!("Failed to parse Drive response: {}", e);
                        (Vec::new(), HashMap::new())
                    }
                }
            }
            Ok(resp) => {
                eprintln!("Google Drive API error: {}", resp.status());
                (Vec::new(), HashMap::new())
            }
            Err(e) => {
                eprintln!("Google Drive request failed: {}", e);
                (Vec::new(), HashMap::new())
            }
        };

        // Update cache
        {
            let mut cache = self.cache.write();
            cache.query = query.to_string();
            cache.results = results.clone();
            cache.urls = urls;
            cache.timestamp = std::time::Instant::now();
        }

        results
    }
}

impl SearchProvider for GoogleDriveProvider {
    fn id(&self) -> &str {
        "google_drive"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        // Only search Google Drive if query starts with "gd " prefix
        if let Some(drive_query) = query.strip_prefix("gd ") {
            self.search_drive(drive_query.trim())
        } else {
            Vec::new()
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if result_id == "google:connect" {
            return Ok(());
        }
        
        if result_id.starts_with("gdrive:file:") {
            let cache = self.cache.read();
            if let Some(url) = cache.urls.get(result_id) {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", url])
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                return Ok(());
            }
            Err("File URL not found".to_string())
        } else {
            Err("Invalid Google Drive result ID".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/mod.rs">
pub mod calculator;
pub mod apps;
pub mod files;
pub mod plugins;
pub mod github;
pub mod notion;
pub mod slack;
pub mod google_drive;
pub mod google_calendar;

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchResult {
    pub id: String,
    pub title: String,
    pub subtitle: Option<String>,
    pub icon: ResultIcon,
    pub category: ResultCategory,
    pub score: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "value")]
pub enum ResultIcon {
    Text(String),
    Path(String),
    Emoji(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ResultCategory {
    Calculator,
    Application,
    File,
    Command,
    Plugin,
    GitHub,
}

pub trait SearchProvider: Send + Sync {
    fn id(&self) -> &str;
    fn search(&self, query: &str) -> Vec<SearchResult>;
    fn execute(&self, result_id: &str) -> Result<(), String>;
}
</file>

<file path="apps/launcher/src-tauri/src/providers/notion.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::oauth::OAuthFlow;
use parking_lot::RwLock;
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;

pub struct NotionProvider {
    oauth_flow: Arc<OAuthFlow>,
    cache: RwLock<SearchCache>,
}

struct SearchCache {
    query: String,
    results: Vec<SearchResult>,
    urls: HashMap<String, String>,
    timestamp: std::time::Instant,
}

impl SearchCache {
    fn new() -> Self {
        Self {
            query: String::new(),
            results: Vec::new(),
            urls: HashMap::new(),
            timestamp: std::time::Instant::now(),
        }
    }

    fn is_valid(&self, query: &str) -> bool {
        self.query == query && self.timestamp.elapsed().as_secs() < 60
    }
}

#[derive(Debug, Deserialize)]
struct NotionSearchResponse {
    results: Vec<NotionPage>,
}

#[derive(Debug, Deserialize)]
struct NotionPage {
    id: String,
    url: String,
    #[serde(default)]
    icon: Option<NotionIcon>,
    properties: NotionProperties,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
enum NotionIcon {
    #[serde(rename = "emoji")]
    Emoji { emoji: String },
    #[serde(rename = "external")]
    External { external: NotionExternalUrl },
    #[serde(rename = "file")]
    File { file: NotionFileUrl },
}

#[derive(Debug, Deserialize)]
struct NotionExternalUrl {
    url: String,
}

#[derive(Debug, Deserialize)]
struct NotionFileUrl {
    url: String,
}

#[derive(Debug, Deserialize)]
struct NotionProperties {
    #[serde(default)]
    title: Option<NotionTitle>,
    #[serde(default)]
    #[serde(rename = "Name")]
    name: Option<NotionTitle>,
}

#[derive(Debug, Deserialize)]
struct NotionTitle {
    title: Vec<NotionRichText>,
}

#[derive(Debug, Deserialize)]
struct NotionRichText {
    plain_text: String,
}

impl NotionProvider {
    pub fn new(oauth_flow: Arc<OAuthFlow>) -> Self {
        Self {
            oauth_flow,
            cache: RwLock::new(SearchCache::new()),
        }
    }

    fn get_token_sync(&self) -> Option<String> {
        self.oauth_flow.get_token_if_valid("notion")
    }

    fn get_page_title(page: &NotionPage) -> String {
        // Try to get title from properties.title or properties.Name
        if let Some(title_prop) = &page.properties.title {
            if let Some(text) = title_prop.title.first() {
                return text.plain_text.clone();
            }
        }
        if let Some(name_prop) = &page.properties.name {
            if let Some(text) = name_prop.title.first() {
                return text.plain_text.clone();
            }
        }
        "Untitled".to_string()
    }

    fn get_page_icon(page: &NotionPage) -> ResultIcon {
        match &page.icon {
            Some(NotionIcon::Emoji { emoji }) => ResultIcon::Emoji(emoji.clone()),
            _ => ResultIcon::Emoji("ðŸ“„".to_string()),
        }
    }

    fn search_notion(&self, query: &str) -> Vec<SearchResult> {
        if query.len() < 2 {
            return Vec::new();
        }

        // Check cache first
        {
            let cache = self.cache.read();
            if cache.is_valid(query) {
                return cache.results.clone();
            }
        }

        // Check if connected to Notion
        if !self.oauth_flow.is_connected("notion") {
            return vec![SearchResult {
                id: "notion:connect".to_string(),
                title: "Connect Notion".to_string(),
                subtitle: Some("Go to Settings â†’ Accounts to connect Notion".to_string()),
                icon: ResultIcon::Emoji("ðŸ”—".to_string()),
                category: ResultCategory::Plugin, // Using Plugin as generic category
                score: 50.0,
            }];
        }

        // Get token synchronously
        let token = match self.get_token_sync() {
            Some(t) => t,
            None => return Vec::new(),
        };

        // Make Notion API request
        let client = reqwest::blocking::Client::new();
        let response = client
            .post("https://api.notion.com/v1/search")
            .header("Authorization", format!("Bearer {}", token))
            .header("Notion-Version", "2022-06-28")
            .header("Content-Type", "application/json")
            .json(&serde_json::json!({
                "query": query,
                "page_size": 8,
                "filter": {
                    "property": "object",
                    "value": "page"
                }
            }))
            .send();

        let (results, urls): (Vec<SearchResult>, HashMap<String, String>) = match response {
            Ok(resp) if resp.status().is_success() => {
                match resp.json::<NotionSearchResponse>() {
                    Ok(data) => {
                        let mut urls = HashMap::new();
                        let results = data
                            .results
                            .into_iter()
                            .enumerate()
                            .map(|(i, page)| {
                                let id = format!("notion:page:{}", page.id);
                                urls.insert(id.clone(), page.url.clone());
                                
                                let title = Self::get_page_title(&page);
                                let icon = Self::get_page_icon(&page);
                                
                                SearchResult {
                                    id,
                                    title,
                                    subtitle: Some("Notion Page".to_string()),
                                    icon,
                                    category: ResultCategory::Plugin,
                                    score: 100.0 - (i as f32 * 5.0),
                                }
                            })
                            .collect();
                        (results, urls)
                    }
                    Err(e) => {
                        eprintln!("Failed to parse Notion response: {}", e);
                        (Vec::new(), HashMap::new())
                    }
                }
            }
            Ok(resp) => {
                eprintln!("Notion API error: {}", resp.status());
                (Vec::new(), HashMap::new())
            }
            Err(e) => {
                eprintln!("Notion request failed: {}", e);
                (Vec::new(), HashMap::new())
            }
        };

        // Update cache
        {
            let mut cache = self.cache.write();
            cache.query = query.to_string();
            cache.results = results.clone();
            cache.urls = urls;
            cache.timestamp = std::time::Instant::now();
        }

        results
    }
}

impl SearchProvider for NotionProvider {
    fn id(&self) -> &str {
        "notion"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        // Only search Notion if query starts with "nt " prefix
        if let Some(notion_query) = query.strip_prefix("nt ") {
            self.search_notion(notion_query.trim())
        } else {
            Vec::new()
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if result_id == "notion:connect" {
            return Ok(());
        }
        
        if result_id.starts_with("notion:page:") {
            let cache = self.cache.read();
            if let Some(url) = cache.urls.get(result_id) {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", url])
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                return Ok(());
            }
            Err("Page URL not found".to_string())
        } else {
            Err("Invalid Notion result ID".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/plugins.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::plugins::{PluginLoader, PluginRuntime};
use std::sync::Arc;

pub struct PluginProvider {
    loader: Arc<PluginLoader>,
    runtime: Arc<PluginRuntime>,
}

impl PluginProvider {
    pub fn new(loader: Arc<PluginLoader>, runtime: Arc<PluginRuntime>) -> Self {
        Self { loader, runtime }
    }
}

impl SearchProvider for PluginProvider {
    fn id(&self) -> &str {
        "plugins"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        if query.is_empty() {
            return vec![];
        }

        let mut results = Vec::new();
        let plugin_ids = self.runtime.loaded_plugin_ids();

        for plugin_id in plugin_ids {
            if let Some(plugin) = self.loader.get_plugin(&plugin_id) {
                if !plugin.enabled {
                    continue;
                }

                match self.runtime.call_search(&plugin_id, query) {
                    Ok(plugin_results) => {
                        for pr in plugin_results {
                            results.push(SearchResult {
                                id: format!("plugin:{}:{}", plugin_id, pr.id),
                                title: pr.title,
                                subtitle: pr.subtitle,
                                icon: pr.icon.map(|i| ResultIcon::Emoji(i)).unwrap_or(ResultIcon::Emoji("ðŸ”Œ".to_string())),
                                category: ResultCategory::Plugin,
                                score: 50.0,
                            });
                        }
                    }
                    Err(e) => {
                        eprintln!("Plugin {} search error: {}", plugin_id, e);
                    }
                }
            }
        }

        results
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        let parts: Vec<&str> = result_id.splitn(3, ':').collect();
        if parts.len() < 3 || parts[0] != "plugin" {
            return Err("Invalid plugin result ID".to_string());
        }

        let _plugin_id = parts[1];
        let _action_id = parts[2];

        Ok(())
    }
}
</file>

<file path="apps/launcher/src-tauri/src/providers/slack.rs">
use super::{ResultCategory, ResultIcon, SearchProvider, SearchResult};
use crate::oauth::OAuthFlow;
use parking_lot::RwLock;
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::Arc;

pub struct SlackProvider {
    oauth_flow: Arc<OAuthFlow>,
    cache: RwLock<SearchCache>,
}

struct SearchCache {
    query: String,
    results: Vec<SearchResult>,
    urls: HashMap<String, String>,
    timestamp: std::time::Instant,
}

impl SearchCache {
    fn new() -> Self {
        Self {
            query: String::new(),
            results: Vec::new(),
            urls: HashMap::new(),
            timestamp: std::time::Instant::now(),
        }
    }

    fn is_valid(&self, query: &str) -> bool {
        self.query == query && self.timestamp.elapsed().as_secs() < 60
    }
}

#[derive(Debug, Deserialize)]
struct SlackSearchResponse {
    ok: bool,
    messages: Option<SlackMessages>,
}

#[derive(Debug, Deserialize)]
struct SlackMessages {
    matches: Vec<SlackMessage>,
}

#[derive(Debug, Deserialize)]
struct SlackMessage {
    iid: String,
    text: String,
    username: Option<String>,
    channel: SlackChannel,
    permalink: String,
    ts: String,
}

#[derive(Debug, Deserialize)]
struct SlackChannel {
    id: String,
    name: Option<String>,
}

impl SlackProvider {
    pub fn new(oauth_flow: Arc<OAuthFlow>) -> Self {
        Self {
            oauth_flow,
            cache: RwLock::new(SearchCache::new()),
        }
    }

    fn get_token_sync(&self) -> Option<String> {
        self.oauth_flow.get_token_if_valid("slack")
    }

    fn truncate_text(text: &str, max_len: usize) -> String {
        if text.len() <= max_len {
            text.to_string()
        } else {
            format!("{}...", &text[..max_len.saturating_sub(3)])
        }
    }

    fn search_slack(&self, query: &str) -> Vec<SearchResult> {
        if query.len() < 2 {
            return Vec::new();
        }

        // Check cache first
        {
            let cache = self.cache.read();
            if cache.is_valid(query) {
                return cache.results.clone();
            }
        }

        // Check if connected to Slack
        if !self.oauth_flow.is_connected("slack") {
            return vec![SearchResult {
                id: "slack:connect".to_string(),
                title: "Connect Slack".to_string(),
                subtitle: Some("Go to Settings â†’ Accounts to connect Slack".to_string()),
                icon: ResultIcon::Emoji("ðŸ”—".to_string()),
                category: ResultCategory::Plugin,
                score: 50.0,
            }];
        }

        // Get token synchronously
        let token = match self.get_token_sync() {
            Some(t) => t,
            None => return Vec::new(),
        };

        // Make Slack API request
        let client = reqwest::blocking::Client::new();
        let response = client
            .get("https://slack.com/api/search.messages")
            .query(&[("query", query), ("count", "8")])
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/x-www-form-urlencoded")
            .send();

        let (results, urls): (Vec<SearchResult>, HashMap<String, String>) = match response {
            Ok(resp) if resp.status().is_success() => {
                match resp.json::<SlackSearchResponse>() {
                    Ok(data) if data.ok => {
                        let mut urls = HashMap::new();
                        let results = data
                            .messages
                            .map(|m| m.matches)
                            .unwrap_or_default()
                            .into_iter()
                            .enumerate()
                            .map(|(i, msg)| {
                                let id = format!("slack:msg:{}", msg.iid);
                                urls.insert(id.clone(), msg.permalink.clone());
                                
                                let channel_name = msg.channel.name.as_deref().unwrap_or("DM");
                                let username = msg.username.as_deref().unwrap_or("Unknown");
                                let title = Self::truncate_text(&msg.text, 60);
                                let subtitle = format!("#{} â€¢ {}", channel_name, username);
                                
                                SearchResult {
                                    id,
                                    title,
                                    subtitle: Some(subtitle),
                                    icon: ResultIcon::Emoji("ðŸ’¬".to_string()),
                                    category: ResultCategory::Plugin,
                                    score: 100.0 - (i as f32 * 5.0),
                                }
                            })
                            .collect();
                        (results, urls)
                    }
                    Ok(data) => {
                        eprintln!("Slack API returned ok=false");
                        (Vec::new(), HashMap::new())
                    }
                    Err(e) => {
                        eprintln!("Failed to parse Slack response: {}", e);
                        (Vec::new(), HashMap::new())
                    }
                }
            }
            Ok(resp) => {
                eprintln!("Slack API error: {}", resp.status());
                (Vec::new(), HashMap::new())
            }
            Err(e) => {
                eprintln!("Slack request failed: {}", e);
                (Vec::new(), HashMap::new())
            }
        };

        // Update cache
        {
            let mut cache = self.cache.write();
            cache.query = query.to_string();
            cache.results = results.clone();
            cache.urls = urls;
            cache.timestamp = std::time::Instant::now();
        }

        results
    }
}

impl SearchProvider for SlackProvider {
    fn id(&self) -> &str {
        "slack"
    }

    fn search(&self, query: &str) -> Vec<SearchResult> {
        // Only search Slack if query starts with "sl " prefix
        if let Some(slack_query) = query.strip_prefix("sl ") {
            self.search_slack(slack_query.trim())
        } else {
            Vec::new()
        }
    }

    fn execute(&self, result_id: &str) -> Result<(), String> {
        if result_id == "slack:connect" {
            return Ok(());
        }
        
        if result_id.starts_with("slack:msg:") {
            let cache = self.cache.read();
            if let Some(url) = cache.urls.get(result_id) {
                #[cfg(target_os = "linux")]
                {
                    std::process::Command::new("xdg-open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "macos")]
                {
                    std::process::Command::new("open")
                        .arg(url)
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                #[cfg(target_os = "windows")]
                {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", url])
                        .spawn()
                        .map_err(|e| e.to_string())?;
                }
                return Ok(());
            }
            Err("Message URL not found".to_string())
        } else {
            Err("Invalid Slack result ID".to_string())
        }
    }
}
</file>

<file path="apps/launcher/src-tauri/src/auth.rs">
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use parking_lot::RwLock;
use keyring::Entry;

const SERVICE_NAME: &str = "com.heien.launcher";
const AUTH_KEY: &str = "web_auth_session";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserSession {
    pub user_id: String,
    pub email: Option<String>,
    pub name: Option<String>,
    pub avatar: Option<String>,
    pub access_token: String,
    pub refresh_token: Option<String>,
    pub expires_at: Option<i64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthState {
    pub is_authenticated: bool,
    pub user: Option<UserInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserInfo {
    pub id: String,
    pub email: Option<String>,
    pub name: Option<String>,
    pub avatar: Option<String>,
}

pub struct WebAuth {
    web_app_url: String,
    session: RwLock<Option<UserSession>>,
    pending_token: RwLock<Option<String>>, // Track token being processed to prevent duplicates
}

impl WebAuth {
    pub fn new(web_app_url: &str) -> Self {
        let auth = Self {
            web_app_url: web_app_url.to_string(),
            session: RwLock::new(None),
            pending_token: RwLock::new(None),
        };
        
        // Try to load existing session from keyring
        if let Ok(session) = auth.load_session() {
            *auth.session.write() = Some(session);
        }
        
        auth
    }

    pub fn web_app_url(&self) -> &str {
        &self.web_app_url
    }

    pub fn get_login_url(&self) -> String {
        format!(
            "{}/auth/desktop?redirect_uri=launcher://auth/callback",
            self.web_app_url
        )
    }

    pub fn get_auth_state(&self) -> AuthState {
        let session = self.session.read();
        match session.as_ref() {
            Some(s) => AuthState {
                is_authenticated: true,
                user: Some(UserInfo {
                    id: s.user_id.clone(),
                    email: s.email.clone(),
                    name: s.name.clone(),
                    avatar: s.avatar.clone(),
                }),
            },
            None => AuthState {
                is_authenticated: false,
                user: None,
            },
        }
    }

    pub fn get_access_token(&self) -> Option<String> {
        let session = self.session.read();
        session.as_ref().map(|s| s.access_token.clone())
    }

    pub async fn handle_callback(&self, token: &str) -> Result<UserSession, String> {
        // Check if we're already processing this token (prevent duplicate calls)
        {
            let mut pending = self.pending_token.write();
            if pending.as_ref() == Some(&token.to_string()) {
                println!("[auth] Token already being processed, skipping duplicate");
                return Err("Token already being processed".to_string());
            }
            *pending = Some(token.to_string());
        }
        
        // Exchange the one-time token for a session
        println!("[auth] Exchanging token with web server at {}", self.web_app_url);
        let client = reqwest::Client::new();
        
        let response = client
            .post(&format!("{}/api/auth/desktop/exchange", self.web_app_url))
            .json(&serde_json::json!({ "token": token }))
            .send()
            .await
            .map_err(|e| format!("Failed to exchange token: {}", e))?;

        println!("[auth] Response status: {}", response.status());
        
        if !response.status().is_success() {
            let error_text = response.text().await.unwrap_or_default();
            println!("[auth] Error response: {}", error_text);
            return Err(format!("Token exchange failed: {}", error_text));
        }

        let session: UserSession = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse session: {}", e))?;

        // Store session
        self.save_session(&session)?;
        *self.session.write() = Some(session.clone());

        Ok(session)
    }

    pub fn logout(&self) -> Result<(), String> {
        *self.session.write() = None;
        self.delete_session()
    }

    fn save_session(&self, session: &UserSession) -> Result<(), String> {
        let entry = Entry::new(SERVICE_NAME, AUTH_KEY)
            .map_err(|e| format!("Failed to create keyring entry: {}", e))?;
        
        let json = serde_json::to_string(session)
            .map_err(|e| format!("Failed to serialize session: {}", e))?;
        
        entry.set_password(&json)
            .map_err(|e| format!("Failed to save session: {}", e))?;
        
        Ok(())
    }

    fn load_session(&self) -> Result<UserSession, String> {
        let entry = Entry::new(SERVICE_NAME, AUTH_KEY)
            .map_err(|e| format!("Failed to create keyring entry: {}", e))?;
        
        let json = entry.get_password()
            .map_err(|e| format!("Failed to load session: {}", e))?;
        
        let session: UserSession = serde_json::from_str(&json)
            .map_err(|e| format!("Failed to parse session: {}", e))?;
        
        // Check if session is expired
        if let Some(expires_at) = session.expires_at {
            let now = chrono::Utc::now().timestamp();
            if now > expires_at {
                self.delete_session().ok();
                return Err("Session expired".to_string());
            }
        }
        
        Ok(session)
    }

    fn delete_session(&self) -> Result<(), String> {
        let entry = Entry::new(SERVICE_NAME, AUTH_KEY)
            .map_err(|e| format!("Failed to create keyring entry: {}", e))?;
        
        entry.delete_credential()
            .map_err(|e| format!("Failed to delete session: {}", e))?;
        
        Ok(())
    }

    pub async fn refresh_session(&self) -> Result<UserSession, String> {
        let current_session = {
            let session = self.session.read();
            session.clone().ok_or("No session to refresh")?
        };

        let refresh_token = current_session
            .refresh_token
            .as_ref()
            .ok_or("No refresh token available")?;

        let client = reqwest::Client::new();
        
        let response = client
            .post(&format!("{}/api/auth/desktop/refresh", self.web_app_url))
            .json(&serde_json::json!({ "refresh_token": refresh_token }))
            .send()
            .await
            .map_err(|e| format!("Failed to refresh session: {}", e))?;

        if !response.status().is_success() {
            // Session invalid, clear it
            self.logout().ok();
            return Err("Session refresh failed, please log in again".to_string());
        }

        let session: UserSession = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse session: {}", e))?;

        self.save_session(&session)?;
        *self.session.write() = Some(session.clone());

        Ok(session)
    }
}
</file>

<file path="apps/launcher/src-tauri/src/config.rs">
use std::env;

pub struct AppConfig {
    pub web_app_url: String,
    pub api_url: String,
}

impl AppConfig {
    pub fn load() -> Self {
        Self {
            web_app_url: env::var("LAUNCHER_WEB_URL")
                .unwrap_or_else(|_| "http://localhost:3000".to_string()),
            api_url: env::var("LAUNCHER_API_URL")
                .unwrap_or_else(|_| "http://localhost:3001".to_string()),
        }
    }

    pub fn plugins_api_url(&self) -> String {
        format!("{}/api/plugins", self.api_url)
    }
}

lazy_static::lazy_static! {
    pub static ref CONFIG: AppConfig = AppConfig::load();
}
</file>

<file path="apps/launcher/src-tauri/src/frecency.rs">
use chrono::{DateTime, Utc};
use parking_lot::RwLock;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

const HALF_LIFE_DAYS: f64 = 7.0;
const MAX_ENTRIES: usize = 1000;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrecencyEntry {
    pub id: String,
    pub access_count: u32,
    pub last_access: DateTime<Utc>,
}

impl FrecencyEntry {
    pub fn new(id: String) -> Self {
        Self {
            id,
            access_count: 1,
            last_access: Utc::now(),
        }
    }

    pub fn record_access(&mut self) {
        self.access_count += 1;
        self.last_access = Utc::now();
    }

    pub fn score(&self) -> f64 {
        let days_since = (Utc::now() - self.last_access).num_hours() as f64 / 24.0;
        let recency_factor = (-days_since / HALF_LIFE_DAYS).exp();
        let frequency_factor = (self.access_count as f64).ln() + 1.0;
        recency_factor * frequency_factor * 10.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FrecencyData {
    pub entries: HashMap<String, FrecencyEntry>,
}

pub struct FrecencyStore {
    data: RwLock<FrecencyData>,
    path: PathBuf,
}

impl FrecencyStore {
    pub fn new() -> Self {
        let path = dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("launcher")
            .join("frecency.json");

        let data = Self::load_from_file(&path).unwrap_or_default();

        Self {
            data: RwLock::new(data),
            path,
        }
    }

    fn load_from_file(path: &PathBuf) -> Option<FrecencyData> {
        let content = std::fs::read_to_string(path).ok()?;
        serde_json::from_str(&content).ok()
    }

    pub fn record_access(&self, id: &str) {
        let mut data = self.data.write();

        if let Some(entry) = data.entries.get_mut(id) {
            entry.record_access();
        } else {
            data.entries
                .insert(id.to_string(), FrecencyEntry::new(id.to_string()));
        }

        if data.entries.len() > MAX_ENTRIES {
            self.prune_old_entries(&mut data);
        }

        drop(data);
        self.save();
    }

    fn prune_old_entries(&self, data: &mut FrecencyData) {
        let mut entries: Vec<_> = data.entries.drain().collect();
        entries.sort_by(|a, b| {
            b.1.score()
                .partial_cmp(&a.1.score())
                .unwrap_or(std::cmp::Ordering::Equal)
        });
        entries.truncate(MAX_ENTRIES / 2);
        data.entries = entries.into_iter().collect();
    }

    pub fn get_boost(&self, id: &str) -> f64 {
        let data = self.data.read();
        data.entries.get(id).map(|e| e.score()).unwrap_or(0.0)
    }

    pub fn save(&self) {
        let data = self.data.read();

        if let Some(parent) = self.path.parent() {
            let _ = std::fs::create_dir_all(parent);
        }

        if let Ok(json) = serde_json::to_string_pretty(&*data) {
            let _ = std::fs::write(&self.path, json);
        }
    }

    pub fn get_top_results(&self, limit: usize) -> Vec<(String, f64)> {
        let data = self.data.read();
        let mut entries: Vec<_> = data
            .entries
            .iter()
            .map(|(id, entry)| (id.clone(), entry.score()))
            .collect();

        entries.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
        entries.truncate(limit);
        entries
    }
}
</file>

<file path="apps/launcher/src-tauri/src/lib.rs">
mod auth;
mod config;
mod frecency;
mod indexer;
mod oauth;
mod plugins;
mod providers;
mod theme;

use auth::{WebAuth, AuthState};
use frecency::FrecencyStore;
use oauth::{OAuthFlow, TokenStorage, CallbackServer};
use oauth::providers::{
    GitHubProvider as OAuthGitHubConfig, GoogleProvider as OAuthGoogleConfig,
    NotionProvider as OAuthNotionConfig, SlackProvider as OAuthSlackConfig, OAuthProvider
};
use plugins::{PluginLoader, PluginRuntime, PluginInfo, PluginRegistry, RegistryPlugin};
use providers::{
    apps::AppProvider, calculator::CalculatorProvider, files::FileProvider, 
    plugins::PluginProvider, github::GitHubProvider, notion::NotionProvider,
    slack::SlackProvider, google_drive::GoogleDriveProvider, 
    google_calendar::GoogleCalendarProvider, SearchProvider, SearchResult,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tauri::{AppHandle, Emitter, Manager};
use tauri_plugin_global_shortcut::{Code, GlobalShortcutExt, Modifiers, Shortcut, ShortcutState};
use tauri_plugin_deep_link::DeepLinkExt;
use theme::SystemTheme;

struct AppState {
    providers: Vec<Arc<dyn SearchProvider>>,
    file_provider: Arc<FileProvider>,
    frecency: Arc<FrecencyStore>,
    plugin_loader: Arc<PluginLoader>,
    plugin_runtime: Arc<PluginRuntime>,
    plugin_registry: Arc<PluginRegistry>,
    oauth_flow: Arc<OAuthFlow>,
    callback_server: Arc<CallbackServer>,
    web_auth: Arc<WebAuth>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct IndexingStatus {
    is_indexing: bool,
    files_indexed: usize,
    message: String,
}

#[tauri::command]
fn search(query: &str, state: tauri::State<AppState>) -> Vec<SearchResult> {
    let mut all_results: Vec<SearchResult> = Vec::new();

    for provider in &state.providers {
        let results = provider.search(query);
        all_results.extend(results);
    }

    for result in &mut all_results {
        let frecency_boost = state.frecency.get_boost(&result.id);
        result.score += frecency_boost as f32;
    }

    all_results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());
    all_results.truncate(20);
    all_results
}

#[tauri::command]
fn execute_result(result_id: &str, state: tauri::State<AppState>) -> Result<(), String> {
    state.frecency.record_access(result_id);

    for provider in &state.providers {
        if result_id.starts_with(&format!("{}:", provider.id()))
            || (provider.id() == "apps" && result_id.starts_with("app:"))
            || (provider.id() == "calculator" && result_id.starts_with("calc:"))
            || (provider.id() == "files" && result_id.starts_with("file:"))
        {
            return provider.execute(result_id);
        }
    }
    Err("No provider found for result".to_string())
}

#[tauri::command]
fn get_system_theme() -> SystemTheme {
    theme::get_system_theme()
}

#[tauri::command]
fn hide_window(app: AppHandle) {
    if let Some(window) = app.get_webview_window("main") {
        let _ = window.hide();
    }
}

#[tauri::command]
fn show_window(app: AppHandle) {
    if let Some(window) = app.get_webview_window("main") {
        let _ = window.show();
        let _ = window.set_focus();
    }
}

#[tauri::command]
async fn start_indexing(app: AppHandle, state: tauri::State<'_, AppState>) -> Result<usize, String> {
    let file_provider = state.file_provider.clone();

    let _ = app.emit("indexing-status", IndexingStatus {
        is_indexing: true,
        files_indexed: 0,
        message: "Starting file indexing...".to_string(),
    });

    let result = tokio::task::spawn_blocking(move || {
        file_provider.initialize()
    })
    .await
    .map_err(|e| e.to_string())?;

    let count = result?;

    let _ = app.emit("indexing-status", IndexingStatus {
        is_indexing: false,
        files_indexed: count,
        message: format!("Indexed {} files", count),
    });

    Ok(count)
}

#[tauri::command]
fn get_index_status(state: tauri::State<AppState>) -> bool {
    state.file_provider.is_initialized()
}

#[tauri::command]
fn list_plugins(state: tauri::State<AppState>) -> Vec<PluginInfo> {
    state.plugin_loader.list_plugins()
}

#[tauri::command]
fn enable_plugin(id: &str, state: tauri::State<AppState>) -> Result<(), String> {
    state.plugin_loader.enable_plugin(id)?;
    if let Some(plugin) = state.plugin_loader.get_plugin(id) {
        if !state.plugin_runtime.is_loaded(id) {
            state.plugin_runtime.load_plugin(&plugin)?;
        }
    }
    Ok(())
}

#[tauri::command]
fn disable_plugin(id: &str, state: tauri::State<AppState>) -> Result<(), String> {
    state.plugin_loader.disable_plugin(id)?;
    state.plugin_runtime.unload_plugin(id)?;
    Ok(())
}

#[tauri::command]
fn get_plugins_dir(state: tauri::State<AppState>) -> String {
    state.plugin_loader.plugins_dir().to_string_lossy().to_string()
}

#[tauri::command]
fn get_index_config(state: tauri::State<AppState>) -> indexer::IndexConfig {
    state.file_provider.get_config()
}

#[tauri::command]
fn set_index_config(config: indexer::IndexConfig, state: tauri::State<AppState>) -> Result<(), String> {
    config.save()?;
    state.file_provider.set_config(config);
    Ok(())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct OAuthProviderInfo {
    id: String,
    name: String,
    connected: bool,
}

#[tauri::command]
fn list_oauth_providers(state: tauri::State<AppState>) -> Vec<OAuthProviderInfo> {
    state.oauth_flow.list_providers()
        .into_iter()
        .map(|p| OAuthProviderInfo {
            id: p.id.clone(),
            name: p.name.clone(),
            connected: state.oauth_flow.is_connected(&p.id),
        })
        .collect()
}

#[tauri::command]
fn start_oauth(provider_id: &str, state: tauri::State<AppState>) -> Result<String, String> {
    let redirect_uri = "http://localhost:19284/oauth/callback";
    state.oauth_flow.start_auth(provider_id, None, redirect_uri)
}

#[tauri::command]
async fn complete_oauth(state: &str, code: &str, app_state: tauri::State<'_, AppState>) -> Result<(), String> {
    app_state.oauth_flow.exchange_code(state, code).await?;
    Ok(())
}

#[tauri::command]
fn disconnect_oauth(provider_id: &str, state: tauri::State<AppState>) -> Result<(), String> {
    state.oauth_flow.disconnect(provider_id)
}

#[tauri::command]
fn is_oauth_connected(provider_id: &str, state: tauri::State<AppState>) -> bool {
    state.oauth_flow.is_connected(provider_id)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct OAuthCredentials {
    client_id: Option<String>,
    client_secret: Option<String>,
}

#[tauri::command]
fn get_oauth_credentials(provider_id: &str, state: tauri::State<AppState>) -> OAuthCredentials {
    state.oauth_flow.get_provider(provider_id)
        .map(|p| OAuthCredentials {
            client_id: p.client_id,
            client_secret: p.client_secret,
        })
        .unwrap_or(OAuthCredentials {
            client_id: None,
            client_secret: None,
        })
}

#[tauri::command]
fn set_oauth_credentials(
    provider_id: &str,
    client_id: Option<String>,
    client_secret: Option<String>,
    state: tauri::State<AppState>,
) -> Result<(), String> {
    state.oauth_flow.update_provider_credentials(provider_id, client_id, client_secret)
}

// Web App Authentication commands
#[tauri::command]
fn get_auth_state(state: tauri::State<AppState>) -> AuthState {
    state.web_auth.get_auth_state()
}

#[tauri::command]
fn get_login_url(state: tauri::State<AppState>) -> String {
    state.web_auth.get_login_url()
}

#[tauri::command]
fn open_login(app: AppHandle, state: tauri::State<AppState>) -> Result<(), String> {
    let url = state.web_auth.get_login_url();
    tauri_plugin_opener::open_url(&url, None::<&str>)
        .map_err(|e| format!("Failed to open browser: {}", e))
}

#[tauri::command]
async fn handle_auth_callback(token: &str, state: tauri::State<'_, AppState>) -> Result<AuthState, String> {
    state.web_auth.handle_callback(token).await?;
    Ok(state.web_auth.get_auth_state())
}

#[tauri::command]
fn logout(state: tauri::State<AppState>) -> Result<AuthState, String> {
    state.web_auth.logout()?;
    Ok(state.web_auth.get_auth_state())
}

#[tauri::command]
fn get_access_token(state: tauri::State<AppState>) -> Option<String> {
    state.web_auth.get_access_token()
}

// Marketplace commands
use config::CONFIG;

#[tauri::command]
async fn refresh_marketplace(state: tauri::State<'_, AppState>) -> Result<(), String> {
    // Fetch from server API
    let response = reqwest::get(&CONFIG.plugins_api_url())
        .await
        .map_err(|e| format!("Failed to fetch registry: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Registry fetch failed: {}", response.status()));
    }
    
    #[derive(serde::Deserialize)]
    struct ApiResponse {
        plugins: Vec<RegistryPlugin>,
    }
    
    let data: ApiResponse = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse response: {}", e))?;
    
    // Update local registry
    for plugin in data.plugins {
        state.plugin_registry.add_plugin(plugin);
    }
    
    // Save to cache
    let _ = state.plugin_registry.save_cache();
    
    Ok(())
}

#[tauri::command]
fn list_marketplace_plugins(state: tauri::State<AppState>) -> Vec<RegistryPlugin> {
    state.plugin_registry.list_plugins()
}

#[tauri::command]
fn search_marketplace(query: &str, state: tauri::State<AppState>) -> Vec<RegistryPlugin> {
    state.plugin_registry.search(query)
}

#[tauri::command]
fn get_marketplace_categories(state: tauri::State<AppState>) -> Vec<String> {
    state.plugin_registry.categories()
}

#[tauri::command]
fn get_marketplace_plugin(id: &str, state: tauri::State<AppState>) -> Option<RegistryPlugin> {
    state.plugin_registry.get_plugin(id)
}

#[tauri::command]
async fn install_plugin(id: &str, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let plugin = state.plugin_registry.get_plugin(id)
        .ok_or_else(|| format!("Plugin not found: {}", id))?;
    
    let plugins_dir = state.plugin_loader.plugins_dir();
    let plugin_dir = plugins_dir.join(&plugin.id);
    
    // Handle local plugins (from examples directory)
    if plugin.download_url.starts_with("local://") {
        let local_path = plugin.download_url.strip_prefix("local://").unwrap();
        let source_dir = std::env::current_dir()
            .map_err(|e| e.to_string())?
            .parent()
            .ok_or("Cannot find parent directory")?
            .join(local_path);
        
        if !source_dir.exists() {
            return Err(format!("Local plugin source not found: {}", source_dir.display()));
        }
        
        // Copy plugin directory
        std::fs::create_dir_all(&plugin_dir).map_err(|e| e.to_string())?;
        copy_dir_recursive(&source_dir, &plugin_dir)?;
        
        // Rescan plugins
        state.plugin_loader.scan_plugins()?;
        
        return Ok(());
    }
    
    // Download remote plugin
    let response = reqwest::get(&plugin.download_url)
        .await
        .map_err(|e| format!("Failed to download plugin: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Download failed with status: {}", response.status()));
    }
    
    let bytes = response.bytes().await.map_err(|e| e.to_string())?;
    
    // Create plugin directory and extract
    std::fs::create_dir_all(&plugin_dir).map_err(|e| e.to_string())?;
    
    // For now, assume it's a zip file
    let cursor = std::io::Cursor::new(bytes);
    let mut archive = zip::ZipArchive::new(cursor)
        .map_err(|e| format!("Failed to read zip archive: {}", e))?;
    
    archive.extract(&plugin_dir)
        .map_err(|e| format!("Failed to extract plugin: {}", e))?;
    
    // Rescan plugins
    state.plugin_loader.scan_plugins()?;
    
    Ok(())
}

#[tauri::command]
fn uninstall_plugin(id: &str, state: tauri::State<AppState>) -> Result<(), String> {
    state.plugin_loader.uninstall_plugin(id)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct PluginUpdate {
    id: String,
    name: String,
    current_version: String,
    latest_version: String,
}

#[tauri::command]
fn check_plugin_updates(state: tauri::State<AppState>) -> Vec<PluginUpdate> {
    let installed = state.plugin_loader.list_plugins();
    let mut updates = Vec::new();
    
    for plugin in installed {
        if let Some(registry_plugin) = state.plugin_registry.get_plugin(&plugin.id) {
            if registry_plugin.version != plugin.version {
                // Simple version comparison - registry version is different
                updates.push(PluginUpdate {
                    id: plugin.id,
                    name: plugin.name,
                    current_version: plugin.version,
                    latest_version: registry_plugin.version,
                });
            }
        }
    }
    
    updates
}

#[tauri::command]
async fn update_plugin(id: &str, state: tauri::State<'_, AppState>) -> Result<(), String> {
    // Uninstall current version
    state.plugin_loader.uninstall_plugin(id)?;
    
    // Install latest from registry
    let plugin = state.plugin_registry.get_plugin(id)
        .ok_or_else(|| format!("Plugin not found in registry: {}", id))?;
    
    let plugins_dir = state.plugin_loader.plugins_dir();
    let plugin_dir = plugins_dir.join(&plugin.id);
    
    // Handle local plugins
    if plugin.download_url.starts_with("local://") {
        let local_path = plugin.download_url.strip_prefix("local://").unwrap();
        let source_dir = std::env::current_dir()
            .map_err(|e| e.to_string())?
            .parent()
            .ok_or("Cannot find parent directory")?
            .join(local_path);
        
        if !source_dir.exists() {
            return Err(format!("Local plugin source not found: {}", source_dir.display()));
        }
        
        std::fs::create_dir_all(&plugin_dir).map_err(|e| e.to_string())?;
        copy_dir_recursive(&source_dir, &plugin_dir)?;
        state.plugin_loader.scan_plugins()?;
        return Ok(());
    }
    
    // Download remote plugin
    let response = reqwest::get(&plugin.download_url)
        .await
        .map_err(|e| format!("Failed to download plugin: {}", e))?;
    
    if !response.status().is_success() {
        return Err(format!("Download failed with status: {}", response.status()));
    }
    
    let bytes = response.bytes().await.map_err(|e| e.to_string())?;
    
    std::fs::create_dir_all(&plugin_dir).map_err(|e| e.to_string())?;
    
    let cursor = std::io::Cursor::new(bytes);
    let mut archive = zip::ZipArchive::new(cursor)
        .map_err(|e| format!("Failed to read zip archive: {}", e))?;
    
    archive.extract(&plugin_dir)
        .map_err(|e| format!("Failed to extract plugin: {}", e))?;
    
    state.plugin_loader.scan_plugins()?;
    
    Ok(())
}

fn copy_dir_recursive(src: &std::path::Path, dst: &std::path::Path) -> Result<(), String> {
    if !dst.exists() {
        std::fs::create_dir_all(dst).map_err(|e| e.to_string())?;
    }
    
    for entry in std::fs::read_dir(src).map_err(|e| e.to_string())? {
        let entry = entry.map_err(|e| e.to_string())?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());
        
        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path).map_err(|e| e.to_string())?;
        }
    }
    
    Ok(())
}

fn toggle_window(app: &AppHandle) {
    if let Some(window) = app.get_webview_window("main") {
        if window.is_visible().unwrap_or(false) {
            let _ = window.hide();
        } else {
            let _ = window.show();
            let _ = window.set_focus();
        }
    }
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let file_provider = Arc::new(FileProvider::new());
    let frecency = Arc::new(FrecencyStore::new());
    let plugin_loader = Arc::new(PluginLoader::new());
    let plugin_runtime = Arc::new(
        PluginRuntime::new().expect("Failed to initialize plugin runtime")
    );

    let plugin_provider = Arc::new(PluginProvider::new(
        plugin_loader.clone(),
        plugin_runtime.clone(),
    ));

    let plugin_registry = Arc::new(PluginRegistry::new());
    plugin_registry.load_featured();
    let _ = plugin_registry.load_cache();

    let token_storage = Arc::new(TokenStorage::new());
    let oauth_flow = Arc::new(OAuthFlow::new(token_storage));
    let callback_server = Arc::new(CallbackServer::new());
    let web_auth = Arc::new(WebAuth::new(&CONFIG.web_app_url));
    
    oauth_flow.register_provider(OAuthGitHubConfig::new(None, None).config().clone());
    oauth_flow.register_provider(OAuthGoogleConfig::new(None, None).config().clone());
    oauth_flow.register_provider(OAuthNotionConfig::new(None, None).config().clone());
    oauth_flow.register_provider(OAuthSlackConfig::new(None, None).config().clone());

    let github_provider = Arc::new(GitHubProvider::new(oauth_flow.clone()));
    let notion_provider = Arc::new(NotionProvider::new(oauth_flow.clone()));
    let slack_provider = Arc::new(SlackProvider::new(oauth_flow.clone()));
    let google_drive_provider = Arc::new(GoogleDriveProvider::new(oauth_flow.clone()));
    let google_calendar_provider = Arc::new(GoogleCalendarProvider::new(oauth_flow.clone()));

    let providers: Vec<Arc<dyn SearchProvider>> = vec![
        Arc::new(CalculatorProvider::new()),
        Arc::new(AppProvider::new()),
        file_provider.clone(),
        plugin_provider,
        github_provider,
        notion_provider,
        slack_provider,
        google_drive_provider,
        google_calendar_provider,
    ];

    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_deep_link::init())
        .plugin(tauri_plugin_single_instance::init(|app, args, _cwd| {
            // When a second instance is launched (e.g., from a deep link),
            // this callback receives the args and we can handle the deep link URL
            println!("Single instance callback - args: {:?}", args);
            for arg in args {
                if arg.starts_with("launcher://") {
                    if let Ok(url) = url::Url::parse(&arg) {
                        // For launcher://auth/callback, host() = "auth", path() = "/callback"
                        let host = url.host_str().unwrap_or("");
                        let path = url.path();
                        println!("Parsed URL - host: '{}', path: '{}'", host, path);
                        
                        if host == "auth" && path == "/callback" {
                            if let Some(query) = url.query() {
                                for pair in query.split('&') {
                                    let mut parts = pair.split('=');
                                    if let (Some(key), Some(value)) = (parts.next(), parts.next()) {
                                        if key == "token" {
                                            println!("Emitting auth-callback with token: {}...", &value[..8.min(value.len())]);
                                            let _ = app.emit("auth-callback", value.to_string());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }))
        .manage(AppState {
            providers,
            file_provider,
            frecency,
            plugin_loader,
            plugin_runtime,
            plugin_registry,
            oauth_flow,
            callback_server,
            web_auth,
        })
        .invoke_handler(tauri::generate_handler![
            search,
            execute_result,
            get_system_theme,
            hide_window,
            show_window,
            start_indexing,
            get_index_status,
            list_plugins,
            enable_plugin,
            disable_plugin,
            get_plugins_dir,
            get_index_config,
            set_index_config,
            list_oauth_providers,
            start_oauth,
            complete_oauth,
            disconnect_oauth,
            is_oauth_connected,
            get_oauth_credentials,
            set_oauth_credentials,
            list_marketplace_plugins,
            search_marketplace,
            get_marketplace_categories,
            get_marketplace_plugin,
            install_plugin,
            uninstall_plugin,
            check_plugin_updates,
            update_plugin,
            refresh_marketplace,
            get_auth_state,
            get_login_url,
            open_login,
            handle_auth_callback,
            logout,
            get_access_token
        ])
        .setup(|app| {
            // Use Super+Space (Meta/Windows key) to avoid conflict with KRunner's Alt+Space
            let shortcut = Shortcut::new(Some(Modifiers::SUPER), Code::Space);
            let app_handle = app.handle().clone();

            app.handle().plugin(
                tauri_plugin_global_shortcut::Builder::new()
                    .with_handler(move |_app, _shortcut, event| {
                        if event.state() == ShortcutState::Pressed {
                            toggle_window(&app_handle);
                        }
                    })
                    .build(),
            )?;

            app.global_shortcut().register(shortcut)?;

            let state = app.state::<AppState>();
            let plugin_loader = state.plugin_loader.clone();
            let plugin_runtime = state.plugin_runtime.clone();
            
            let callback_server = state.callback_server.clone();
            let oauth_flow = state.oauth_flow.clone();
            tauri::async_runtime::spawn(async move {
                if let Err(e) = callback_server.start(oauth_flow).await {
                    eprintln!("Failed to start OAuth callback server: {}", e);
                }
            });

            // Register deep link handler for launcher:// URLs
            let deep_link_handle = app.handle().clone();
            app.deep_link().on_open_url(move |event| {
                let urls = event.urls();
                for url in urls {
                    println!("Received deep link: {}", url);
                    // Parse launcher://auth/callback?token=xxx
                    if url.scheme() == "launcher" && url.path() == "/auth/callback" {
                        if let Some(query) = url.query() {
                            for pair in query.split('&') {
                                let mut parts = pair.split('=');
                                if let (Some(key), Some(value)) = (parts.next(), parts.next()) {
                                    if key == "token" {
                                        let _ = deep_link_handle.emit("auth-callback", value.to_string());
                                    }
                                }
                            }
                        }
                    }
                }
            });
            
            match plugin_loader.scan_plugins() {
                Ok(plugin_ids) => {
                    println!("Found {} plugins", plugin_ids.len());
                    for id in &plugin_ids {
                        if let Some(plugin) = plugin_loader.get_plugin(id) {
                            if plugin.enabled {
                                match plugin_runtime.load_plugin(&plugin) {
                                    Ok(_) => println!("Loaded plugin: {}", id),
                                    Err(e) => eprintln!("Failed to load plugin {}: {}", id, e),
                                }
                            }
                        }
                    }
                }
                Err(e) => eprintln!("Failed to scan plugins: {}", e),
            }

            let indexing_handle = app.handle().clone();
            let file_provider = state.file_provider.clone();
            
            std::thread::spawn(move || {
                std::thread::sleep(std::time::Duration::from_secs(2));
                
                let _ = indexing_handle.emit("indexing-status", IndexingStatus {
                    is_indexing: true,
                    files_indexed: 0,
                    message: "Starting background indexing...".to_string(),
                });

                match file_provider.initialize() {
                    Ok(count) => {
                        let _ = indexing_handle.emit("indexing-status", IndexingStatus {
                            is_indexing: false,
                            files_indexed: count,
                            message: format!("Indexed {} files", count),
                        });
                        println!("Background indexing complete: {} files", count);

                        if let Err(e) = file_provider.start_watcher() {
                            eprintln!("Failed to start file watcher: {}", e);
                        } else {
                            println!("File watcher started");
                            
                            loop {
                                std::thread::sleep(std::time::Duration::from_secs(1));
                                let updated = file_provider.process_watcher_events();
                            }
                        }
                    }
                    Err(e) => {
                        let _ = indexing_handle.emit("indexing-status", IndexingStatus {
                            is_indexing: false,
                            files_indexed: 0,
                            message: format!("Indexing failed: {}", e),
                        });
                        eprintln!("Background indexing failed: {}", e);
                    }
                }
            });

            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="apps/launcher/src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    launcher_lib::run()
}
</file>

<file path="apps/launcher/src-tauri/src/theme.rs">
use serde::{Deserialize, Serialize};
use std::process::Command;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemTheme {
    pub is_dark: bool,
    pub accent_color: Option<String>,
    pub window_blur_supported: bool,
}

impl Default for SystemTheme {
    fn default() -> Self {
        Self {
            is_dark: true,
            accent_color: None,
            window_blur_supported: false,
        }
    }
}

pub fn get_system_theme() -> SystemTheme {
    #[cfg(target_os = "linux")]
    {
        get_linux_theme()
    }

    #[cfg(target_os = "windows")]
    {
        get_windows_theme()
    }

    #[cfg(target_os = "macos")]
    {
        get_macos_theme()
    }

    #[cfg(not(any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        SystemTheme::default()
    }
}

#[cfg(target_os = "linux")]
fn get_linux_theme() -> SystemTheme {
    let is_dark = detect_linux_dark_mode();
    let accent_color = detect_linux_accent_color();
    let window_blur_supported = detect_linux_compositor_blur();

    SystemTheme {
        is_dark,
        accent_color,
        window_blur_supported,
    }
}

#[cfg(target_os = "linux")]
fn detect_linux_dark_mode() -> bool {
    if let Ok(output) = Command::new("gsettings")
        .args(["get", "org.gnome.desktop.interface", "color-scheme"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if stdout.contains("dark") {
            return true;
        }
    }

    if let Ok(output) = Command::new("gsettings")
        .args(["get", "org.gnome.desktop.interface", "gtk-theme"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout).to_lowercase();
        if stdout.contains("dark") {
            return true;
        }
    }

    if let Ok(output) = Command::new("kreadconfig5")
        .args([
            "--group",
            "General",
            "--key",
            "ColorScheme",
            "--file",
            "kdeglobals",
        ])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout).to_lowercase();
        if stdout.contains("dark") || stdout.contains("breeze") {
            return true;
        }
    }

    true
}

#[cfg(target_os = "linux")]
fn detect_linux_accent_color() -> Option<String> {
    if let Ok(output) = Command::new("gsettings")
        .args(["get", "org.gnome.desktop.interface", "accent-color"])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if !stdout.is_empty() && stdout != "''" {
            let color = stdout.trim_matches('\'');
            return accent_name_to_hex(color);
        }
    }

    if let Ok(output) = Command::new("kreadconfig5")
        .args([
            "--group",
            "Colors:View",
            "--key",
            "DecorationFocus",
            "--file",
            "kdeglobals",
        ])
        .output()
    {
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if !stdout.is_empty() {
            let parts: Vec<&str> = stdout.split(',').collect();
            if parts.len() >= 3 {
                if let (Ok(r), Ok(g), Ok(b)) = (
                    parts[0].parse::<u8>(),
                    parts[1].parse::<u8>(),
                    parts[2].parse::<u8>(),
                ) {
                    return Some(format!("#{:02x}{:02x}{:02x}", r, g, b));
                }
            }
        }
    }

    None
}

fn accent_name_to_hex(name: &str) -> Option<String> {
    match name.to_lowercase().as_str() {
        "blue" => Some("#3584e4".to_string()),
        "teal" => Some("#2190a4".to_string()),
        "green" => Some("#3a944a".to_string()),
        "yellow" => Some("#c88800".to_string()),
        "orange" => Some("#ed5b00".to_string()),
        "red" => Some("#e62d42".to_string()),
        "pink" => Some("#d56199".to_string()),
        "purple" => Some("#9141ac".to_string()),
        "slate" => Some("#6f8396".to_string()),
        _ => None,
    }
}

#[cfg(target_os = "linux")]
fn detect_linux_compositor_blur() -> bool {
    if std::env::var("XDG_SESSION_TYPE").map(|v| v == "wayland").unwrap_or(false) {
        if std::env::var("XDG_CURRENT_DESKTOP")
            .map(|v| v.to_lowercase().contains("kde"))
            .unwrap_or(false)
        {
            return true;
        }
    }

    if let Ok(output) = Command::new("pgrep").args(["-x", "picom"]).output() {
        if output.status.success() {
            return true;
        }
    }

    if let Ok(output) = Command::new("pgrep").args(["-x", "compiz"]).output() {
        if output.status.success() {
            return true;
        }
    }

    false
}

#[cfg(target_os = "windows")]
fn get_windows_theme() -> SystemTheme {
    SystemTheme {
        is_dark: true,
        accent_color: Some("#0078d4".to_string()),
        window_blur_supported: true,
    }
}

#[cfg(target_os = "macos")]
fn get_macos_theme() -> SystemTheme {
    SystemTheme {
        is_dark: true,
        accent_color: Some("#007aff".to_string()),
        window_blur_supported: true,
    }
}
</file>

<file path="apps/launcher/src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="apps/launcher/src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="apps/launcher/src-tauri/Cargo.toml">
[package]
name = "launcher"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "launcher_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
tauri-plugin-global-shortcut = "2"
tauri-plugin-deep-link = "2"
tauri-plugin-single-instance = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
meval = "0.2"
freedesktop-desktop-entry = "0.7"
tokio = { version = "1", features = ["full"] }
dirs = "6"
walkdir = "2"
tantivy = "0.22"
notify = { version = "7", default-features = false, features = ["macos_kqueue"] }
notify-debouncer-mini = "0.5"
chrono = { version = "0.4", features = ["serde"] }
parking_lot = "0.12"
fuzzy-matcher = "0.3"
wasmtime = "27"
wit-bindgen = "0.36"
keyring = "3"
reqwest = { version = "0.12", features = ["json", "blocking"] }
url = "2"
base64 = "0.22"
rand = "0.8"
sha2 = "0.10"
axum = "0.7"
tower = "0.5"
zip = "2"
lazy_static = "1.5"
</file>

<file path="apps/launcher/src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "launcher",
  "version": "0.1.0",
  "identifier": "com.heien.launcher",
  "build": {
    "beforeDevCommand": "bun run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "bun run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "label": "main",
        "title": "Launcher",
        "width": 680,
        "height": 480,
        "minWidth": 680,
        "minHeight": 100,
        "resizable": false,
        "decorations": false,
        "transparent": true,
        "alwaysOnTop": true,
        "skipTaskbar": true,
        "center": true,
        "visible": false,
        "focus": true
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  },
  "plugins": {
    "deep-link": {
      "desktop": {
        "schemes": ["launcher"]
      }
    }
  }
}
</file>

<file path="apps/launcher/.env">
# Launcher Desktop App Environment Variables

# Web app URL (for authentication)
LAUNCHER_WEB_URL=http://localhost:3000

# API server URL (for plugin registry)
LAUNCHER_API_URL=http://localhost:3001
</file>

<file path="apps/launcher/.env.example">
# Launcher Desktop App Environment Variables

# Web app URL (for authentication)
LAUNCHER_WEB_URL=http://localhost:3000

# API server URL (for plugin registry)
LAUNCHER_API_URL=http://localhost:3001
</file>

<file path="apps/launcher/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="apps/launcher/launcher-handler.desktop">
[Desktop Entry]
Name=Launcher URL Handler
Exec=/home/heien/Development/launcher/apps/launcher/src-tauri/target/debug/launcher %u
Type=Application
NoDisplay=true
MimeType=x-scheme-handler/launcher;
</file>

<file path="apps/launcher/package.json">
{
  "name": "@launcher/desktop",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "GDK_BACKEND=x11 tauri",
    "tauri:wayland": "tauri",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@radix-ui/react-slot": "^1.2.4",
    "@tailwindcss/vite": "^4.1.18",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-opener": "^2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.26",
    "lucide-react": "^0.561.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.1.18",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2",
    "@types/node": "^25.0.3",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "typescript": "~5.8.3",
    "vite": "^7.0.4"
  }
}
</file>

<file path="apps/launcher/PROGRESS.md">
# Launcher Development Progress

## Current Phase: Phase 4 - OAuth & SaaS Integrations COMPLETE âœ…

### Session Log

#### Session 1 - Dec 17, 2025
**Status:** Phase 1 Core Implementation COMPLETE âœ…

**Completed:**
- [x] Project documentation review
- [x] Frontend dependencies setup (Tailwind v4, Zustand, Framer Motion, Lucide)
- [x] Tauri window configuration (transparent, borderless, always-on-top)
- [x] Global hotkey registration (Alt+Space)
- [x] Window toggle show/hide
- [x] Theme engine (Linux GTK/KDE detection)
- [x] Search UI with keyboard navigation
- [x] Calculator provider with instant math evaluation
- [x] App provider (Linux .desktop file discovery)

#### Session 2 - Dec 17, 2025
**Status:** Phase 2 File Indexer COMPLETE âœ…

**Completed:**
- [x] Tantivy full-text search integration
- [x] Background file indexing (indexes ~40k files on startup)
- [x] Fuzzy search with skim matcher
- [x] FileProvider integrated with search system
- [x] Indexing status events (Rust â†’ React via Tauri events)
- [x] UI shows indexing progress spinner
- [x] File type icons (emoji-based by extension)
- [x] File execution (xdg-open on Linux)

**How to Test:**
1. Run `bun tauri dev` in project root
2. Press `Alt+Space` to toggle launcher
3. Wait for "Indexing files..." to complete (~2-5 seconds)
4. Type filenames to search indexed files
5. Files from ~/Documents, ~/Downloads, ~/Desktop, ~/Projects, ~/Development are indexed

**Index Configuration:**
- Excludes: node_modules, .git, target, venv, __pycache__, etc.
- Content indexing for: .txt, .md, .rs, .py, .js, .ts, .json, .yaml, etc.
- Max file size: 10MB

**Completed (continued):**
- [x] Filesystem watcher for real-time incremental updates
- [x] Frecency boosting (tracks usage, boosts frequently used results)
- [x] Phase 3: Plugin Foundation started
  - wasmtime WASM runtime integration
  - Plugin manifest format (JSON)
  - Plugin loader (scans plugins directory)
  - Plugin runtime (WASM instantiation, host functions)
  - Host API (logging, file I/O, config, notifications)

**New Files (Phase 3):**
- `src-tauri/src/plugins/mod.rs` - Plugin module exports
- `src-tauri/src/plugins/manifest.rs` - PluginManifest, permissions
- `src-tauri/src/plugins/loader.rs` - PluginLoader for scanning/loading
- `src-tauri/src/plugins/runtime.rs` - WASM runtime with wasmtime
- `src-tauri/src/plugins/host_api.rs` - Host functions for plugins
- `src-tauri/src/frecency.rs` - Frecency tracking for search results

#### Session 3 - Dec 17, 2025
**Status:** Phase 3 Plugin System Integration COMPLETE âœ…

**Completed:**
- [x] Integrated plugin system with main app (`lib.rs`)
  - Added `plugins` module import
  - Added `PluginLoader` and `PluginRuntime` to `AppState`
  - Plugin scanning and loading on startup
- [x] Added Tauri commands for plugin management:
  - `list_plugins` - List all loaded plugins
  - `enable_plugin` - Enable and load a plugin
  - `disable_plugin` - Disable and unload a plugin
  - `get_plugins_dir` - Get plugins directory path
- [x] Created example WASM plugin (`examples/hello-plugin/`)
  - `#![no_std]` Rust plugin compiling to wasm32-unknown-unknown
  - Exports: `init`, `shutdown`, `search`, `alloc`
  - Uses `host_log` host function for logging
  - Build scripts: `build.sh`, `install.sh`
- [x] Verified plugin loads and initializes correctly:
  - "Found 1 plugins"
  - "[Plugin:hello-plugin] [info] Hello Plugin initialized!"
  - "Loaded plugin: hello-plugin"

**Plugin Directory:**
- `~/.local/share/launcher/plugins/` - Plugins are installed here
- Each plugin is a folder with `manifest.json` + `*.wasm`

#### Session 4 - Dec 17, 2025
**Status:** Plugin Provider + Settings UI COMPLETE âœ…

**Completed:**
- [x] Created `PluginProvider` (`src-tauri/src/providers/plugins.rs`)
  - Integrates plugin search results into main search system
  - Queries all loaded plugins via `call_search`
  - Converts plugin results to `SearchResult` format
- [x] Added `loaded_plugin_ids()` method to `PluginRuntime`
- [x] Added Tauri commands for index configuration:
  - `get_index_config` - Get current index settings
  - `set_index_config` - Update index settings
- [x] Created Settings UI (`src/components/Settings.tsx`)
  - Modal with tabs: File Index, Plugins
  - Shows indexed directories, exclude patterns, content extensions
  - Lists installed plugins with metadata
- [x] Integrated Settings button into Launcher footer
- [x] Added TypeScript types: `IndexConfig`, `PluginManifest`

**New Files:**
- `src-tauri/src/providers/plugins.rs` - Plugin search provider
- `src/components/Settings.tsx` - Settings modal UI

**How to Test:**
1. Run `cargo run` in `src-tauri/`
2. Press `Alt+Space` to toggle launcher
3. Click the gear icon (âš™ï¸) in the footer to open Settings
4. View File Index tab for indexing configuration
5. View Plugins tab for installed plugins

#### Session 5 - Dec 17, 2025
**Status:** Phase 4 OAuth Infrastructure COMPLETE âœ…

**Completed:**
- [x] Added OAuth dependencies to Cargo.toml:
  - `keyring` - Secure OS keychain token storage
  - `reqwest` - HTTP client for token exchange
  - `url`, `base64`, `rand`, `sha2` - PKCE support
- [x] Created OAuth module (`src-tauri/src/oauth/`):
  - `providers.rs` - GitHub and Google provider configs
  - `storage.rs` - Secure token storage with keyring + memory cache
  - `flow.rs` - OAuth flow with PKCE, token exchange, refresh
- [x] Added Tauri commands for OAuth:
  - `list_oauth_providers` - List providers with connection status
  - `start_oauth` - Generate auth URL with PKCE
  - `complete_oauth` - Exchange code for tokens
  - `disconnect_oauth` - Remove stored tokens
  - `is_oauth_connected` - Check connection status
- [x] Added Accounts tab to Settings UI:
  - Shows GitHub and Google providers
  - Connect/Disconnect buttons
  - Connection status indicators
- [x] Integrated OAuthFlow into AppState

**New Files:**
- `src-tauri/src/oauth/mod.rs` - OAuth module exports
- `src-tauri/src/oauth/providers.rs` - Provider configs (GitHub, Google)
- `src-tauri/src/oauth/storage.rs` - Keyring-based token storage
- `src-tauri/src/oauth/flow.rs` - PKCE OAuth flow implementation

**How to Test:**
1. Run `cargo run` in `src-tauri/`
2. Press `Alt+Space` to toggle launcher
3. Click âš™ï¸ gear icon â†’ Accounts tab
4. See GitHub and Google providers listed
5. (OAuth requires client credentials to fully test)

**OAuth Features:**
- PKCE (Proof Key for Code Exchange) for security
- Secure token storage in OS keychain
- Automatic token refresh when expired
- Memory cache for fast token access

#### Session 6 - Dec 17, 2025
**Status:** OAuth Callback Server & Credentials UI COMPLETE âœ…

**Completed:**
- [x] Created OAuth callback server (`src-tauri/src/oauth/callback.rs`)
  - Axum-based HTTP server on `localhost:19284`
  - Handles `/oauth/callback` redirect with code/state params
  - Beautiful success/error HTML pages with auto-close
  - Graceful shutdown support
- [x] Integrated callback server with main app
  - Starts automatically on app launch via `tauri::async_runtime::spawn`
  - Shares `OAuthFlow` for token exchange
- [x] Added client credentials configuration to Settings UI
  - Expandable provider cards with credential inputs
  - Client ID and Client Secret fields
  - Save button with loading state
  - "Get credentials" link to provider dev consoles
  - Shows redirect URI for easy copy
  - Status indicators: "Credentials required" / "Ready to connect" / "Connected"
- [x] Added Tauri commands for credentials management:
  - `get_oauth_credentials` - Get current credentials for a provider
  - `set_oauth_credentials` - Update credentials for a provider
- [x] Added `update_provider_credentials` method to `OAuthFlow`

**New Files:**
- `src-tauri/src/oauth/callback.rs` - OAuth callback HTTP server

**Dependencies Added:**
- `axum = "0.7"` - HTTP server for callback handling
- `tower = "0.5"` - Middleware support

**How to Test OAuth:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Click âš™ï¸ gear â†’ Accounts tab
3. Click chevron to expand GitHub/Google provider
4. Enter Client ID (and optionally Client Secret)
5. Click "Save" â†’ Click "Connect"
6. Complete OAuth in browser â†’ Redirects to callback server
7. Token stored securely in OS keychain

#### Session 7 - Dec 17, 2025
**Status:** GitHub Search Provider COMPLETE âœ…

**Completed:**
- [x] Created native GitHub search provider (`src-tauri/src/providers/github.rs`)
  - Searches GitHub repositories via API
  - Uses OAuth token from connected GitHub account
  - Triggered with `gh ` prefix (e.g., "gh tauri")
  - Caches results for 60 seconds
  - Shows "Connect GitHub" prompt if not authenticated
- [x] Added `get_token_if_valid` method to `OAuthFlow` for sync token access
- [x] Added `GitHub` category to `ResultCategory` enum
- [x] Integrated GitHub provider into main app
- [x] Added `blocking` feature to reqwest for sync HTTP requests

**New Files:**
- `src-tauri/src/providers/github.rs` - GitHub repository search provider

**How to Test GitHub Search:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Accounts â†’ GitHub
3. Enter Client ID from GitHub OAuth App
4. Click Save â†’ Connect â†’ Authorize in browser
5. Type `gh tauri` to search GitHub repos
6. Press Enter to open repo in browser

**GitHub Search Features:**
- Prefix-triggered: Only searches when query starts with "gh "
- Shows repo name, description, stars, language
- Opens repo URL in browser on selection
- 60-second result caching
- Graceful handling when not connected

#### Session 8 - Dec 17, 2025
**Status:** Editable Settings & Plugin Toggle COMPLETE âœ…

**Completed:**
- [x] Made Index Settings fully editable:
  - Add/remove indexed directories with input field
  - Add/remove exclude patterns (tags with X button)
  - Add/remove content-indexed extensions
  - Toggle exclude_hidden and index_content options
  - Save Changes button to persist config
  - Reindex button to trigger re-indexing
- [x] Added plugin enable/disable toggle:
  - Created `PluginInfo` struct with `enabled` field
  - Toggle button shows Enabled/Disabled state
  - Calls `enable_plugin`/`disable_plugin` Tauri commands
  - Visual feedback: disabled plugins appear dimmed
- [x] Updated types:
  - Rust: `PluginInfo` in `loader.rs` with enabled status
  - TypeScript: `PluginInfo` interface with enabled field

**UI Improvements:**
- Hover-to-reveal delete buttons on list items
- Enter key support for adding items
- Loading spinners during save/toggle operations
- Visual distinction between enabled/disabled plugins

#### Session 9 - Dec 17, 2025
**Status:** Index Config Persistence COMPLETE âœ…

**Completed:**
- [x] Added config persistence to `IndexConfig`:
  - `load()` - Load config from `~/.local/share/launcher/index_config.json`
  - `save()` - Save config to disk with pretty JSON formatting
  - Falls back to defaults if config file doesn't exist or is invalid
- [x] Updated `FileProvider::initialize()` to use `IndexConfig::load()` instead of `default()`
- [x] Updated `set_index_config` Tauri command to persist changes to disk before updating in-memory state
- [x] Config now survives app restarts

**Modified Files:**
- `src-tauri/src/indexer/config.rs` - Added `load()`, `save()`, `config_path()` methods
- `src-tauri/src/providers/files.rs` - Changed `initialize()` to use `IndexConfig::load()`
- `src-tauri/src/lib.rs` - Updated `set_index_config` to call `config.save()`

**How to Test:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ File Index tab
3. Add/remove directories, patterns, or extensions
4. Click "Save Changes"
5. Restart the app - settings should persist

**Config Location:**
- `~/.local/share/launcher/index_config.json`

#### Session 10 - Dec 17, 2025
**Status:** Phase 5 Plugin Marketplace COMPLETE âœ…

**Completed:**
- [x] Created plugin registry system (`src-tauri/src/plugins/registry.rs`):
  - `RegistryPlugin` struct with metadata (name, version, author, description, categories, downloads, rating)
  - `PluginRegistry` with in-memory cache and disk persistence
  - Featured plugins catalog (Hello Plugin, Clipboard History, Snippets, Emoji Picker, Color Picker)
  - Search, filter by category, load/save cache
- [x] Added Tauri commands for marketplace:
  - `list_marketplace_plugins` - List all available plugins
  - `search_marketplace` - Search plugins by query
  - `get_marketplace_categories` - Get unique categories
  - `get_marketplace_plugin` - Get plugin details by ID
  - `install_plugin` - Download and install plugin (supports local:// and remote URLs)
  - `uninstall_plugin` - Remove installed plugin
- [x] Added `zip` crate for extracting downloaded plugin archives
- [x] Created Marketplace UI tab in Settings:
  - Search bar with Enter key support
  - Category filter buttons (All, Productivity, Utilities, etc.)
  - Plugin cards with name, version, description, author, rating, downloads
  - Install/Uninstall buttons with loading states
  - "Installed" badge for installed plugins
- [x] Added TypeScript types: `RegistryPlugin`

**New Files:**
- `src-tauri/src/plugins/registry.rs` - Plugin registry/catalog system

**Modified Files:**
- `src-tauri/src/plugins/mod.rs` - Export registry module
- `src-tauri/src/lib.rs` - Add registry to AppState, marketplace commands
- `src-tauri/Cargo.toml` - Add `zip` dependency
- `src/types/index.ts` - Add `RegistryPlugin` type
- `src/components/Settings.tsx` - Add Marketplace tab with full UI

**How to Test:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Marketplace tab
3. Browse featured plugins with categories
4. Search for plugins by name/description
5. Click "Install" to install a plugin (Hello Plugin works locally)
6. Installed plugins appear in Plugins tab

**Marketplace Features:**
- Search plugins by name/description
- Filter by category
- Shows download count and rating
- One-click install/uninstall
- Local plugin support (local:// URLs for development)
- Remote plugin support (downloads and extracts zip files)

#### Session 11 - Dec 17, 2025
**Status:** Notion & Slack OAuth + Notion Search Provider COMPLETE âœ…

**Completed:**
- [x] Added Notion OAuth provider (`src-tauri/src/oauth/providers.rs`):
  - Auth URL: `https://api.notion.com/v1/oauth/authorize`
  - Token URL: `https://api.notion.com/v1/oauth/token`
  - Notion uses integration capabilities instead of scopes
- [x] Added Slack OAuth provider:
  - Auth URL: `https://slack.com/oauth/v2/authorize`
  - Token URL: `https://slack.com/api/oauth.v2.access`
  - Scopes: `channels:read`, `search:read`, `users:read`
- [x] Created Notion search provider (`src-tauri/src/providers/notion.rs`):
  - Triggered with `nt ` prefix (e.g., "nt meeting notes")
  - Searches Notion pages via API
  - Shows page title, emoji icon, and "Notion Page" subtitle
  - Opens page in browser on selection
  - 60-second result caching
- [x] Updated Settings UI with Notion/Slack icons and developer console links:
  - Notion: ðŸ“ â†’ https://www.notion.so/my-integrations
  - Slack: ðŸ’¬ â†’ https://api.slack.com/apps
- [x] Registered all 4 OAuth providers (GitHub, Google, Notion, Slack)

**New Files:**
- `src-tauri/src/providers/notion.rs` - Notion search provider

**Modified Files:**
- `src-tauri/src/oauth/providers.rs` - Added NotionProvider, SlackProvider
- `src-tauri/src/providers/mod.rs` - Export notion module
- `src-tauri/src/lib.rs` - Register OAuth providers, add NotionProvider to search
- `src/components/Settings.tsx` - Add Notion/Slack icons and docs links

**How to Test Notion Search:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Accounts â†’ Notion
3. Create integration at https://www.notion.so/my-integrations
4. Enter Client ID and Client Secret â†’ Save â†’ Connect
5. Type `nt meeting` to search Notion pages
6. Press Enter to open page in browser

**Search Prefixes:**
- `gh <query>` - Search GitHub repositories
- `nt <query>` - Search Notion pages

#### Session 12 - Dec 17, 2025
**Status:** Slack Search Provider COMPLETE âœ…

**Completed:**
- [x] Created Slack search provider (`src-tauri/src/providers/slack.rs`):
  - Triggered with `sl ` prefix (e.g., "sl project update")
  - Searches Slack messages via `search.messages` API
  - Shows message text, channel name, and username
  - Opens message permalink in browser on selection
  - 60-second result caching
  - Truncates long messages to 60 chars

**New Files:**
- `src-tauri/src/providers/slack.rs` - Slack search provider

**Modified Files:**
- `src-tauri/src/providers/mod.rs` - Export slack module
- `src-tauri/src/lib.rs` - Add SlackProvider to search providers

**How to Test Slack Search:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Accounts â†’ Slack
3. Create app at https://api.slack.com/apps with `search:read` scope
4. Enter Client ID and Client Secret â†’ Save â†’ Connect
5. Type `sl meeting` to search Slack messages
6. Press Enter to open message in Slack

**All Search Prefixes:**
- `gh <query>` - Search GitHub repositories
- `nt <query>` - Search Notion pages
- `sl <query>` - Search Slack messages

#### Session 13 - Dec 17, 2025
**Status:** Plugin Update Checking COMPLETE âœ…

**Completed:**
- [x] Added `check_plugin_updates` Tauri command:
  - Compares installed plugin versions with registry versions
  - Returns list of plugins with available updates
- [x] Added `update_plugin` Tauri command:
  - Uninstalls current version
  - Downloads and installs latest from registry
  - Supports both local:// and remote URLs
- [x] Added `PluginUpdate` type (Rust + TypeScript)
- [x] Updated Plugins tab UI:
  - Shows yellow "Update: vX.X.X" badge when update available
  - "Update" button with loading state
  - Automatically checks for updates when tab opens

**Modified Files:**
- `src-tauri/src/lib.rs` - Added check_plugin_updates, update_plugin commands
- `src/types/index.ts` - Added PluginUpdate interface
- `src/components/Settings.tsx` - Added update checking UI to Plugins tab

**How to Test:**
1. Run `bun tauri dev`
2. Install a plugin from Marketplace
3. Go to Plugins tab - see current version
4. If registry has newer version, yellow badge appears
5. Click "Update" to update to latest version

#### Session 14 - Dec 17, 2025
**Status:** Google Drive Search Provider COMPLETE âœ…

**Completed:**
- [x] Created Google Drive search provider (`src-tauri/src/providers/google_drive.rs`):
  - Triggered with `gd ` prefix (e.g., "gd budget report")
  - Searches files in Google Drive via API
  - Shows file name, type (Google Doc/Sheet/Slides/PDF/etc.), and owner
  - File type icons: ðŸ“„ Doc, ðŸ“Š Sheet, ðŸ“½ï¸ Slides, ðŸ“ Folder, ðŸ“• PDF, ðŸ–¼ï¸ Image, ðŸŽ¬ Video
  - Opens file in browser on selection
  - 60-second result caching
  - Orders by most recently modified

**New Files:**
- `src-tauri/src/providers/google_drive.rs` - Google Drive search provider

**Modified Files:**
- `src-tauri/src/providers/mod.rs` - Export google_drive module
- `src-tauri/src/lib.rs` - Add GoogleDriveProvider to search providers

**How to Test:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Accounts â†’ Google
3. Create OAuth app at https://console.cloud.google.com/apis/credentials
4. Enable Google Drive API, add `drive.readonly` scope
5. Enter Client ID and Client Secret â†’ Save â†’ Connect
6. Type `gd meeting notes` to search Drive files
7. Press Enter to open file in browser

**All Search Prefixes:**
- `gh <query>` - Search GitHub repositories
- `nt <query>` - Search Notion pages
- `sl <query>` - Search Slack messages
- `gd <query>` - Search Google Drive files

#### Session 15 - Dec 17, 2025
**Status:** Google Calendar Search Provider COMPLETE âœ…

**Completed:**
- [x] Created Google Calendar search provider (`src-tauri/src/providers/google_calendar.rs`):
  - Triggered with `gc ` prefix (e.g., "gc standup")
  - Searches upcoming events (next 30 days) via Calendar API
  - Shows event title, date/time, and location
  - Formats time nicely: "Dec 17, 14:30" or "2025-01-15 (All day)"
  - Opens event in Google Calendar on selection
  - 60-second result caching
  - Orders by start time

**New Files:**
- `src-tauri/src/providers/google_calendar.rs` - Google Calendar search provider

**Modified Files:**
- `src-tauri/src/providers/mod.rs` - Export google_calendar module
- `src-tauri/src/lib.rs` - Add GoogleCalendarProvider to search providers

**How to Test:**
1. Run `bun tauri dev`
2. Press `Alt+Space` â†’ Settings â†’ Accounts â†’ Google
3. Enable Google Calendar API, add `calendar.readonly` scope
4. Connect Google account
5. Type `gc meeting` to search upcoming events
6. Press Enter to open event in Google Calendar

**All Search Prefixes:**
- `gh <query>` - Search GitHub repositories
- `nt <query>` - Search Notion pages
- `sl <query>` - Search Slack messages
- `gd <query>` - Search Google Drive files
- `gc <query>` - Search Google Calendar events

#### Session 16 - Dec 17, 2025
**Status:** Expanded Plugin Marketplace Catalog âœ…

**Completed:**
- [x] Added 9 new plugin entries to marketplace registry:
  - **Linear** - Search/create issues, view assigned tasks
  - **Jira** - Search issues, view sprint boards, create tickets
  - **Todoist** - Manage tasks, add/complete/search to-dos
  - **Things 3** - Quick add tasks (macOS only)
  - **1Password** - Search and copy passwords (requires CLI)
  - **Bitwarden** - Search and copy passwords from vault
  - **Spotify** - Control playback, search tracks/albums
  - **Docker** - Manage containers, start/stop/logs
  - **SSH Connections** - Quick connect from ~/.ssh/config

**Modified Files:**
- `src-tauri/src/plugins/registry.rs` - Added 9 plugin entries with categories, permissions, ratings

**Marketplace Now Has 14 Plugins:**
| Plugin | Category | Downloads | Rating |
|--------|----------|-----------|--------|
| Spotify | Media | 6,200 | 4.7 |
| 1Password | Security | 5,600 | 4.9 |
| Jira | Project Management | 4,500 | 4.3 |
| Bitwarden | Security | 3,400 | 4.5 |
| Linear | Project Management | 3,200 | 4.7 |
| Todoist | Tasks | 2,800 | 4.6 |
| Emoji Picker | Utilities | 2,100 | 4.8 |
| Docker | DevOps | 2,100 | 4.4 |
| SSH | DevOps | 1,800 | 4.3 |
| Color Picker | Design | 1,560 | 4.6 |
| Clipboard History | Productivity | 1,250 | 4.5 |
| Things 3 | Tasks | 1,200 | 4.8 |
| Snippets | Text | 890 | 4.2 |
| Hello Plugin | Examples | 0 | - |

**New Categories:**
- Project Management, Tasks, Security, Media, Music, DevOps

#### Session 17 - Dec 17, 2025
**Status:** Monorepo Restructure COMPLETE âœ…

**Completed:**
- [x] Restructured project into monorepo:
  ```
  launcher/
  â”œâ”€â”€ apps/
  â”‚   â””â”€â”€ launcher/     # Desktop app (moved here)
  â”œâ”€â”€ packages/         # Shared packages (future)
  â”œâ”€â”€ package.json      # Workspace root
  â”œâ”€â”€ turbo.json        # Turborepo config
  â””â”€â”€ README.md         # Monorepo docs
  ```
- [x] Renamed package to `@launcher/desktop`
- [x] Added Turborepo for task orchestration
- [x] Updated .gitignore for monorepo

**New Root Files:**
- `package.json` - Bun workspaces config
- `turbo.json` - Turborepo task config
- `README.md` - Monorepo documentation

**Future Apps (placeholders):**
- `apps/web` - Web dashboard for plugin marketplace
- `apps/server` - Plugin registry API server

**Future Packages:**
- `packages/shared` - Shared types and utilities

**How to Run:**
```bash
cd apps/launcher
bun install
bun tauri dev
```

#### Session 18 - Dec 17, 2025
**Status:** Server + Shared Package COMPLETE âœ…

**Completed:**
- [x] Created `apps/server` - Plugin Registry API:
  - Hono framework for fast HTTP
  - Endpoints: `/api/plugins`, `/api/plugins/:id`, `/api/categories`, `/api/search`
  - Download tracking endpoint
  - CORS enabled for desktop app
  - Runs on port 3001
- [x] Created `packages/shared` - Shared TypeScript types:
  - `RegistryPlugin`, `PluginUpdate`, `PluginManifest`
  - `OAuthProviderInfo`, `OAuthCredentials`
  - `IndexConfig`, `SearchResult`
  - API response types

**New Files:**
- `apps/server/package.json` - Server package config
- `apps/server/src/index.ts` - Hono API server
- `apps/server/tsconfig.json` - TypeScript config
- `packages/shared/package.json` - Shared package config
- `packages/shared/src/index.ts` - Shared types
- `packages/shared/tsconfig.json` - TypeScript config

**Monorepo Structure:**
```
launcher/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ launcher/     # Desktop app (Tauri + React)
â”‚   â””â”€â”€ server/       # Plugin registry API (Hono)
â”œâ”€â”€ packages/
â”‚   â””â”€â”€ shared/       # Shared TypeScript types
â”œâ”€â”€ package.json      # Workspace root
â”œâ”€â”€ turbo.json        # Turborepo config
â””â”€â”€ README.md
```

**How to Run Server:**
```bash
cd apps/server
bun install
bun run dev
# API at http://localhost:3001
```

**API Endpoints:**
- `GET /api/plugins` - List all plugins
- `GET /api/plugins/:id` - Get plugin by ID
- `GET /api/categories` - List categories
- `GET /api/search?q=query` - Search plugins
- `POST /api/plugins/:id/download` - Track download

#### Session 19 - Dec 17, 2025
**Status:** Desktop â†” Server API Integration COMPLETE âœ…

**Completed:**
- [x] Added `refresh_marketplace` Tauri command:
  - Fetches plugins from `http://localhost:3001/api/plugins`
  - Updates local registry with server data
  - Saves to local cache
- [x] Added refresh button to Marketplace UI:
  - RefreshCw icon button next to search
  - Loading spinner while refreshing
  - Fetches latest plugins from server

**Modified Files:**
- `apps/launcher/src-tauri/src/lib.rs` - Added refresh_marketplace command
- `apps/launcher/src/components/Settings.tsx` - Added refresh button to Marketplace

**How to Test:**
1. Start server: `cd apps/server && bun run dev`
2. Start desktop: `cd apps/launcher && bun tauri dev`
3. Open Settings â†’ Marketplace
4. Click refresh button (â†») to fetch from server

#### Session 20 - Dec 17, 2025
**Status:** Web Dashboard COMPLETE âœ…

**Completed:**
- [x] Created `apps/web` - Plugin Marketplace Web Dashboard:
  - Next.js 16 with App Router
  - Dark theme with Tailwind CSS
  - Server-side data fetching from API
  - Responsive grid layout
- [x] Components:
  - `PluginGrid` - Grid of plugin cards with ratings, downloads, categories
  - `SearchBar` - Search input with navigation
  - `CategoryFilter` - Category filter buttons
- [x] Pages:
  - `/` - Homepage with all plugins
  - `/search?q=query` - Search results page

**New Files:**
- `apps/web/src/app/page.tsx` - Homepage
- `apps/web/src/app/search/page.tsx` - Search results
- `apps/web/src/components/plugin-grid.tsx` - Plugin cards
- `apps/web/src/components/search-bar.tsx` - Search input
- `apps/web/src/components/category-filter.tsx` - Category buttons

**Final Monorepo Structure:**
```
launcher/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ launcher/     # Desktop app (Tauri + React)
â”‚   â”œâ”€â”€ server/       # Plugin registry API (Hono)
â”‚   â””â”€â”€ web/          # Web dashboard (Next.js)
â”œâ”€â”€ packages/
â”‚   â””â”€â”€ shared/       # Shared TypeScript types
â”œâ”€â”€ package.json      # Workspace root
â”œâ”€â”€ turbo.json        # Turborepo config
â””â”€â”€ README.md
```

**How to Run Everything:**
```bash
# Terminal 1: API Server
cd apps/server && bun run dev

# Terminal 2: Web Dashboard
cd apps/web && bun run dev

# Terminal 3: Desktop App
cd apps/launcher && bun tauri dev
```

**URLs:**
- Desktop: Alt+Space hotkey
- Server API: http://localhost:3001
- Web Dashboard: http://localhost:3000

#### Session 21 - Dec 17, 2025
**Status:** Plugin Detail Page + Neon Auth Integration COMPLETE âœ…

**Completed:**
- [x] Created plugin detail page (`apps/web/src/app/plugins/[id]/page.tsx`):
  - Dynamic routing for individual plugins
  - Shows full description, categories, permissions
  - Installation instructions with CLI command
  - Links to homepage and repository
- [x] Expanded server plugin registry with more detailed data
- [x] Created shared packages for monorepo scalability:
  - `packages/db` - Drizzle ORM schema and Neon Postgres client
  - `packages/cache` - Upstash Redis and Vector clients
- [x] Integrated Neon Auth (Stack Auth) for user authentication:
  - `@stackframe/stack` SDK
  - OAuth with Google and GitHub
  - Server and client app separation (`stack.ts`, `stack-client.ts`)
  - Auth handler at `/handler/[...stack]`
  - `StackProvider` wrapper in layout
- [x] Created user dashboard page (`/dashboard`):
  - Usage stats (AI queries, plugins, subscription tier)
  - Quick actions (browse plugins, settings, API keys)
  - Protected route with auth redirect
- [x] Added Header component with user navigation:
  - Sign In button when logged out
  - UserButton dropdown when logged in
  - Dashboard link for authenticated users

**New Files:**
- `apps/web/src/app/plugins/[id]/page.tsx` - Plugin detail page
- `apps/web/src/app/dashboard/page.tsx` - User dashboard
- `apps/web/src/app/handler/[...stack]/page.tsx` - Stack Auth handler
- `apps/web/src/stack.ts` - Server-side Stack Auth app
- `apps/web/src/stack-client.ts` - Client-side Stack Auth app
- `apps/web/src/components/header.tsx` - Header with auth
- `apps/web/src/components/auth-provider.tsx` - StackProvider wrapper
- `apps/web/src/lib/auth/client.ts` - Auth hooks export
- `packages/db/src/schema.ts` - Drizzle ORM schema (users, subscriptions, usage, plugins)
- `packages/db/src/index.ts` - Neon Postgres client
- `packages/cache/src/redis.ts` - Upstash Redis client
- `packages/cache/src/vector.ts` - Upstash Vector client

**Database Schema (packages/db):**
- `neon_auth.users_sync` - Reference to Neon Auth users
- `user_profiles` - App-specific user settings
- `subscriptions` - Subscription tiers (free/pro/team/enterprise)
- `usage_records` - AI query and action tracking
- `usage_aggregates` - Monthly usage summaries
- `plugins` - Marketplace plugins
- `user_plugins` - Installed plugins per user
- `plugin_ratings` - User ratings/reviews
- `api_keys` - Desktop app sync keys

**Environment Variables (apps/web/.env):**
```bash
# Neon Auth (Stack Auth)
NEXT_PUBLIC_STACK_PROJECT_ID=xxx
NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY=pck_xxx
STACK_SECRET_SERVER_KEY=ssk_xxx

# Database
DATABASE_URL=postgresql://...

# Upstash Redis/Vector (optional)
UPSTASH_REDIS_REST_URL=...
UPSTASH_REDIS_REST_TOKEN=...
```

**Auth Routes:**
- `/handler/sign-in` - Sign in page
- `/handler/sign-up` - Sign up page
- `/handler/sign-out` - Sign out
- `/dashboard` - Protected user dashboard

**How to Test Auth:**
1. Start server: `cd apps/server && bun run dev`
2. Start web: `cd apps/web && bun run dev`
3. Click "Sign In" in header
4. Sign in with Google or GitHub
5. Redirected to dashboard after auth

**Next Session:**
- [x] Stripe subscription integration âœ…
- [x] Plugin submission form âœ…
- [x] Usage tracking implementation âœ…
- [x] API key generation for desktop sync âœ…

---

#### Session 22 - Dec 17, 2025
**Status:** Stripe Integration + Plugin Submission + Usage Tracking COMPLETE âœ…

**Completed:**
- [x] **Stripe Subscription Integration:**
  - Added `stripe` package to web app
  - Created `/pricing` page with tier cards (Free/Pro/Team/Enterprise)
  - Monthly/yearly billing toggle with 17% yearly discount
  - Checkout API route (`/api/stripe/checkout`) creates Stripe sessions
  - Webhook handler (`/api/stripe/webhook`) processes subscription events
  - Customer portal route (`/api/stripe/portal`) for billing management
  - Subscription management page (`/dashboard/subscription`)

- [x] **Plugin Submission Form:**
  - Created `/plugins/submit` page for developers
  - Form fields: name, ID, version, description, URLs
  - Category selection (Productivity, Developer Tools, etc.)
  - Permission selection (fs:read, fs:write, net:http, etc.)
  - API route (`/api/plugins/submit`) validates and inserts plugins

- [x] **Usage Tracking:**
  - Created `lib/usage.ts` with tracking functions
  - `trackUsage()` - records usage and updates monthly aggregates
  - `getMonthlyUsage()` - fetches current month's usage
  - `checkUsageLimit()` - validates against tier limits
  - API route (`/api/usage`) for GET/POST usage data
  - Dashboard now shows real usage data from database

- [x] **API Key Generation:**
  - Created `/dashboard/api-keys` page
  - `ApiKeyManager` client component for key management
  - API routes (`/api/keys`, `/api/keys/[id]`) for CRUD
  - Secure key generation with SHA-256 hashing
  - Keys shown only once, stored as hashes

**New Files:**
- `apps/web/src/lib/stripe.ts` - Stripe client and pricing config
- `apps/web/src/lib/usage.ts` - Usage tracking utilities
- `apps/web/src/app/pricing/page.tsx` - Pricing page
- `apps/web/src/app/api/stripe/checkout/route.ts` - Checkout API
- `apps/web/src/app/api/stripe/webhook/route.ts` - Webhook handler
- `apps/web/src/app/api/stripe/portal/route.ts` - Customer portal
- `apps/web/src/app/dashboard/subscription/page.tsx` - Subscription management
- `apps/web/src/app/plugins/submit/page.tsx` - Plugin submission form
- `apps/web/src/app/api/plugins/submit/route.ts` - Plugin submission API
- `apps/web/src/app/dashboard/api-keys/page.tsx` - API keys page
- `apps/web/src/app/dashboard/api-keys/api-key-manager.tsx` - Key manager component
- `apps/web/src/app/api/keys/route.ts` - API keys CRUD
- `apps/web/src/app/api/keys/[id]/route.ts` - Delete API key
- `apps/web/src/app/api/usage/route.ts` - Usage tracking API

**Environment Variables Added (apps/web/.env):**
```bash
# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...

# Optional: Stripe Price IDs
STRIPE_PRO_MONTHLY_PRICE_ID=price_...
STRIPE_PRO_YEARLY_PRICE_ID=price_...
# etc.
```

**Routes Added:**
- `/pricing` - Pricing page with tier comparison
- `/plugins/submit` - Plugin submission form (auth required)
- `/dashboard/subscription` - Subscription management
- `/dashboard/api-keys` - API key management
- `/api/stripe/checkout` - POST: Create checkout session
- `/api/stripe/webhook` - POST: Handle Stripe webhooks
- `/api/stripe/portal` - GET: Redirect to Stripe portal
- `/api/plugins/submit` - POST: Submit new plugin
- `/api/keys` - GET/POST: List/create API keys
- `/api/keys/[id]` - DELETE: Remove API key
- `/api/usage` - GET/POST: Usage data

**Next Session:**
- [x] Run database migrations with Drizzle (`bun run db:push`) âœ…
- [ ] Set up Stripe products/prices in dashboard
- [x] Desktop app: Web auth integration âœ…
- [ ] Desktop app: Cloud sync with web account
- [ ] Plugin verification workflow

---

#### Session 22 (continued) - Dec 17, 2025
**Status:** Desktop App Web Authentication COMPLETE âœ…

**Completed:**
- [x] **Deep Link URL Scheme:**
  - Added `tauri-plugin-deep-link` for `launcher://` URL handling
  - Configured in `tauri.conf.json` with `launcher` scheme
  - Deep link handler parses `launcher://auth/callback?token=xxx`

- [x] **Desktop Auth Module (`src-tauri/src/auth.rs`):**
  - `WebAuth` struct manages session state
  - Secure token storage via system keyring
  - `get_login_url()` - generates web auth URL
  - `handle_callback()` - exchanges one-time token for session
  - `logout()` - clears session from keyring
  - Session refresh support

- [x] **Web Auth Endpoints:**
  - `/auth/desktop` - Auth page that generates one-time token
  - `/api/auth/desktop/exchange` - Exchanges token for session
  - `/api/auth/desktop/refresh` - Refreshes expired sessions
  - `lib/desktop-auth.ts` - Shared token management

- [x] **Desktop Frontend Integration:**
  - `stores/auth.ts` - Zustand store for auth state
  - Settings â†’ Accounts tab shows "Launcher Account" section
  - Sign In button opens browser to web app
  - Deep link callback updates auth state
  - Sign Out button clears session

**New Files (Desktop):**
- `apps/launcher/src-tauri/src/auth.rs` - Web auth module
- `apps/launcher/src/stores/auth.ts` - Auth Zustand store

**New Files (Web):**
- `apps/web/src/lib/desktop-auth.ts` - Token management
- `apps/web/src/app/auth/desktop/page.tsx` - Desktop auth page
- `apps/web/src/app/api/auth/desktop/exchange/route.ts` - Token exchange
- `apps/web/src/app/api/auth/desktop/refresh/route.ts` - Token refresh

**Modified Files:**
- `apps/launcher/src-tauri/tauri.conf.json` - Added deep-link plugin config
- `apps/launcher/src-tauri/Cargo.toml` - Added tauri-plugin-deep-link
- `apps/launcher/src-tauri/src/lib.rs` - Integrated auth module
- `apps/launcher/src/components/Launcher.tsx` - Auth listener setup
- `apps/launcher/src/components/Settings.tsx` - Launcher Account UI

**Auth Flow:**
1. User clicks "Sign In" in desktop Settings â†’ Accounts
2. Browser opens to `http://localhost:3000/auth/desktop`
3. User authenticates via Stack Auth (Google/GitHub)
4. Web generates one-time token, redirects to `launcher://auth/callback?token=xxx`
5. Desktop receives deep link, exchanges token for session
6. Session stored in system keyring, user shown as logged in

**Next Session:**
- [ ] Set up Stripe products/prices in Stripe Dashboard
- [ ] Test full auth flow end-to-end
- [ ] Implement cloud sync (settings, plugins, frecency)
- [ ] Plugin verification workflow

---

## Phase 1 Checklist

### Window & Hotkey Foundation
- [x] Configure `tauri.conf.json`: transparent, borderless, always-on-top
- [x] Global hotkey registration (default `Alt+Space`)
- [x] Window toggle: show/hide with hotkey
- [x] Auto-focus input on window show
- [x] Click-outside or Escape to dismiss

### Theme Engine (Chameleon)
- [x] Rust: `get_system_theme` command (Linux GTK/KDE)
- [x] React: Theme loading on mount
- [x] CSS variables injection
- [ ] Window blur/vibrancy (compositor-dependent, partial)

### Search UI
- [x] Centered search bar
- [x] Results list
- [x] Keyboard navigation (arrows, Enter)
- [x] Result item component

### Inline Calculator
- [x] Math expression detection
- [x] Instant evaluation display
- [x] Copy result on click

### Basic Providers
- [x] `CalculatorProvider` - Math evaluation (meval crate)
- [x] `AppProvider` - Linux .desktop file discovery
- [x] Provider trait foundation

---

## Architecture Notes

### Frontend Stack
- React 18+ (TypeScript)
- Vite
- Tailwind CSS v4
- Shadcn/UI (Radix)
- Zustand (state)
- Framer Motion (animations)
- Lucide React (icons)

### Backend Stack
- Rust (Edition 2021)
- Tauri v2
- Tokio (async)
- meval (math eval)
- freedesktop-desktop-entry (Linux apps)

### IPC Pattern
React sends query â†’ Rust processes â†’ Returns `Vec<ResultItem>` â†’ React renders
</file>

<file path="apps/launcher/README.md">
# Tauri + React + Typescript

This template should help get you started developing with Tauri, React and Typescript in Vite.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)
</file>

<file path="apps/launcher/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="apps/launcher/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "types": ["node"]
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="apps/launcher/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "path";


const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));
</file>

<file path="apps/server/src/index.ts">
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";

const app = new Hono();

app.use("*", logger());
app.use("*", cors());

// Plugin registry data (in production, this would be in a database)
interface RegistryPlugin {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  homepage: string | null;
  repository: string | null;
  download_url: string;
  checksum: string | null;
  permissions: string[];
  categories: string[];
  downloads: number;
  rating: number | null;
}

const plugins: Map<string, RegistryPlugin> = new Map([
  ["hello-plugin", {
    id: "hello-plugin",
    name: "Hello Plugin",
    version: "1.0.0",
    author: "Launcher Team",
    description: "A simple example plugin that demonstrates the plugin API",
    homepage: null,
    repository: "https://github.com/launcher/hello-plugin",
    download_url: "https://plugins.launcher.dev/hello-plugin/1.0.0.zip",
    checksum: null,
    permissions: ["logging"],
    categories: ["Examples", "Development"],
    downloads: 0,
    rating: null,
  }],
  ["clipboard-history", {
    id: "clipboard-history",
    name: "Clipboard History",
    version: "1.0.0",
    author: "Launcher Team",
    description: "Track and search your clipboard history. Access past copies with a simple search.",
    homepage: null,
    repository: null,
    download_url: "https://plugins.launcher.dev/clipboard-history/1.0.0.zip",
    checksum: null,
    permissions: ["clipboard"],
    categories: ["Productivity", "Utilities"],
    downloads: 1250,
    rating: 4.5,
  }],
  ["linear", {
    id: "linear",
    name: "Linear",
    version: "1.0.0",
    author: "Community",
    description: "Search and create Linear issues. View assigned tasks and project status.",
    homepage: "https://linear.app",
    repository: null,
    download_url: "https://plugins.launcher.dev/linear/1.0.0.zip",
    checksum: null,
    permissions: ["network", "oauth:linear"],
    categories: ["Productivity", "Development", "Project Management"],
    downloads: 3200,
    rating: 4.7,
  }],
  ["todoist", {
    id: "todoist",
    name: "Todoist",
    version: "1.0.0",
    author: "Community",
    description: "Manage Todoist tasks. Add, complete, and search your to-dos.",
    homepage: "https://todoist.com",
    repository: null,
    download_url: "https://plugins.launcher.dev/todoist/1.0.0.zip",
    checksum: null,
    permissions: ["network", "oauth:todoist"],
    categories: ["Productivity", "Tasks"],
    downloads: 2800,
    rating: 4.6,
  }],
  ["1password", {
    id: "1password",
    name: "1Password",
    version: "1.0.0",
    author: "Community",
    description: "Search and copy passwords from 1Password. Requires 1Password CLI.",
    homepage: "https://1password.com",
    repository: null,
    download_url: "https://plugins.launcher.dev/1password/1.0.0.zip",
    checksum: null,
    permissions: ["clipboard", "shell:op"],
    categories: ["Security", "Utilities"],
    downloads: 5600,
    rating: 4.9,
  }],
  ["spotify", {
    id: "spotify",
    name: "Spotify",
    version: "1.0.0",
    author: "Community",
    description: "Control Spotify playback. Search tracks, albums, and playlists.",
    homepage: "https://spotify.com",
    repository: null,
    download_url: "https://plugins.launcher.dev/spotify/1.0.0.zip",
    checksum: null,
    permissions: ["network", "oauth:spotify"],
    categories: ["Media", "Music"],
    downloads: 6200,
    rating: 4.7,
  }],
  ["github-repos", {
    id: "github-repos",
    name: "GitHub Repositories",
    version: "1.2.0",
    author: "Launcher Team",
    description: "Search and open your GitHub repositories. Clone repos, view issues, and manage pull requests directly from the launcher.",
    homepage: "https://github.com",
    repository: "https://github.com/launcher/github-repos-plugin",
    download_url: "https://plugins.launcher.dev/github-repos/1.2.0.zip",
    checksum: null,
    permissions: ["network", "oauth:github"],
    categories: ["Development", "Productivity"],
    downloads: 8400,
    rating: 4.8,
  }],
  ["calculator-advanced", {
    id: "calculator-advanced",
    name: "Advanced Calculator",
    version: "2.0.0",
    author: "Community",
    description: "Scientific calculator with unit conversions, currency exchange rates, and equation solving. Supports variables and history.",
    homepage: null,
    repository: "https://github.com/launcher/calc-advanced",
    download_url: "https://plugins.launcher.dev/calculator-advanced/2.0.0.zip",
    checksum: null,
    permissions: ["network"],
    categories: ["Utilities", "Productivity"],
    downloads: 4100,
    rating: 4.6,
  }],
  ["snippets", {
    id: "snippets",
    name: "Code Snippets",
    version: "1.0.0",
    author: "Community",
    description: "Store and quickly access code snippets. Supports syntax highlighting and clipboard integration.",
    homepage: null,
    repository: "https://github.com/launcher/snippets-plugin",
    download_url: "https://plugins.launcher.dev/snippets/1.0.0.zip",
    checksum: null,
    permissions: ["clipboard", "filesystem"],
    categories: ["Development", "Productivity"],
    downloads: 2900,
    rating: 4.4,
  }],
  ["emoji-picker", {
    id: "emoji-picker",
    name: "Emoji Picker",
    version: "1.1.0",
    author: "Community",
    description: "Search and copy emojis to clipboard. Includes recent emojis and favorites.",
    homepage: null,
    repository: null,
    download_url: "https://plugins.launcher.dev/emoji-picker/1.1.0.zip",
    checksum: null,
    permissions: ["clipboard"],
    categories: ["Utilities"],
    downloads: 7800,
    rating: 4.5,
  }],
  ["docker", {
    id: "docker",
    name: "Docker Manager",
    version: "1.0.0",
    author: "Community",
    description: "Manage Docker containers, images, and volumes. Start, stop, and inspect containers from the launcher.",
    homepage: "https://docker.com",
    repository: "https://github.com/launcher/docker-plugin",
    download_url: "https://plugins.launcher.dev/docker/1.0.0.zip",
    checksum: null,
    permissions: ["shell:docker"],
    categories: ["Development", "DevOps"],
    downloads: 3500,
    rating: 4.3,
  }],
  ["window-manager", {
    id: "window-manager",
    name: "Window Manager",
    version: "1.0.0",
    author: "Launcher Team",
    description: "Quickly switch between windows, move windows to different workspaces, and resize with keyboard shortcuts.",
    homepage: null,
    repository: null,
    download_url: "https://plugins.launcher.dev/window-manager/1.0.0.zip",
    checksum: null,
    permissions: ["system:windows"],
    categories: ["Utilities", "Productivity"],
    downloads: 5200,
    rating: 4.7,
  }],
  ["bitwarden", {
    id: "bitwarden",
    name: "Bitwarden",
    version: "1.0.0",
    author: "Community",
    description: "Search and copy passwords from Bitwarden. Requires Bitwarden CLI to be installed.",
    homepage: "https://bitwarden.com",
    repository: null,
    download_url: "https://plugins.launcher.dev/bitwarden/1.0.0.zip",
    checksum: null,
    permissions: ["clipboard", "shell:bw"],
    categories: ["Security", "Utilities"],
    downloads: 4800,
    rating: 4.8,
  }],
]);

// Routes
app.get("/", (c) => {
  return c.json({
    name: "Launcher Plugin Registry",
    version: "1.0.0",
    endpoints: {
      plugins: "/api/plugins",
      plugin: "/api/plugins/:id",
      categories: "/api/categories",
      search: "/api/search?q=query",
    },
  });
});

// List all plugins
app.get("/api/plugins", (c) => {
  const allPlugins = Array.from(plugins.values());
  return c.json({
    plugins: allPlugins,
    total: allPlugins.length,
  });
});

// Get plugin by ID
app.get("/api/plugins/:id", (c) => {
  const id = c.req.param("id");
  const plugin = plugins.get(id);
  
  if (!plugin) {
    return c.json({ error: "Plugin not found" }, 404);
  }
  
  return c.json(plugin);
});

// Get all categories
app.get("/api/categories", (c) => {
  const categories = new Set<string>();
  for (const plugin of plugins.values()) {
    for (const category of plugin.categories) {
      categories.add(category);
    }
  }
  return c.json({
    categories: Array.from(categories).sort(),
  });
});

// Search plugins
app.get("/api/search", (c) => {
  const query = c.req.query("q")?.toLowerCase() || "";
  const category = c.req.query("category");
  
  let results = Array.from(plugins.values());
  
  if (query) {
    results = results.filter(
      (p) =>
        p.name.toLowerCase().includes(query) ||
        p.description?.toLowerCase().includes(query) ||
        p.id.toLowerCase().includes(query)
    );
  }
  
  if (category) {
    results = results.filter((p) => p.categories.includes(category));
  }
  
  // Sort by downloads
  results.sort((a, b) => b.downloads - a.downloads);
  
  return c.json({
    plugins: results,
    total: results.length,
    query,
    category: category || null,
  });
});

// Download tracking (increment download count)
app.post("/api/plugins/:id/download", (c) => {
  const id = c.req.param("id");
  const plugin = plugins.get(id);
  
  if (!plugin) {
    return c.json({ error: "Plugin not found" }, 404);
  }
  
  plugin.downloads++;
  return c.json({ success: true, downloads: plugin.downloads });
});

const port = process.env.PORT || 3001;
console.log(`ðŸš€ Plugin Registry API running on http://localhost:${port}`);

export default {
  port,
  fetch: app.fetch,
};
</file>

<file path="apps/server/package.json">
{
  "name": "@launcher/server",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch src/index.ts",
    "build": "bun build src/index.ts --outdir dist --target bun",
    "start": "bun run dist/index.js",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "hono": "^4.6.0"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "@types/node": "^25.0.3"
  }
}
</file>

<file path="apps/server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "outDir": "dist",
    "types": ["@types/bun"]
  },
  "include": ["src/**/*"]
}
</file>

<file path="apps/web/.git/hooks/applypatch-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
</file>

<file path="apps/web/.git/hooks/commit-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
</file>

<file path="apps/web/.git/hooks/fsmonitor-watchman.sample">
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
</file>

<file path="apps/web/.git/hooks/post-update.sample">
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
</file>

<file path="apps/web/.git/hooks/pre-applypatch.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
</file>

<file path="apps/web/.git/hooks/pre-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
</file>

<file path="apps/web/.git/hooks/pre-merge-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
</file>

<file path="apps/web/.git/hooks/pre-push.sample">
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
</file>

<file path="apps/web/.git/hooks/pre-rebase.sample">
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
</file>

<file path="apps/web/.git/hooks/pre-receive.sample">
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
</file>

<file path="apps/web/.git/hooks/prepare-commit-msg.sample">
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
</file>

<file path="apps/web/.git/hooks/push-to-checkout.sample">
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
</file>

<file path="apps/web/.git/hooks/sendemail-validate.sample">
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi
</file>

<file path="apps/web/.git/hooks/update.sample">
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
</file>

<file path="apps/web/.git/info/exclude">
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</file>

<file path="apps/web/.git/refs/heads/main">
57939ae9a24dc072b682ef7b2cdbee3009f9a216
</file>

<file path="apps/web/.git/COMMIT_EDITMSG">
test
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch main
# Changes to be committed:
#	new file:   .env.example
#	modified:   .gitignore
#	modified:   package.json
#	new file:   src/app/dashboard/page.tsx
#	new file:   src/app/handler/[...stack]/page.tsx
#	modified:   src/app/layout.tsx
#	modified:   src/app/page.tsx
#	new file:   src/app/plugins/[id]/page.tsx
#	new file:   src/app/search/page.tsx
#	new file:   src/components/auth-provider.tsx
#	new file:   src/components/category-filter.tsx
#	new file:   src/components/header.tsx
#	new file:   src/components/plugin-grid.tsx
#	new file:   src/components/search-bar.tsx
#	new file:   src/lib/auth/client.ts
#	new file:   src/lib/db/index.ts
#	new file:   src/lib/db/schema.ts
#	new file:   src/stack-client.ts
#	new file:   src/stack.ts
#
</file>

<file path="apps/web/.git/config">
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
</file>

<file path="apps/web/.git/description">
Unnamed repository; edit this file 'description' to name the repository.
</file>

<file path="apps/web/.git/FETCH_HEAD">

</file>

<file path="apps/web/.git/HEAD">
ref: refs/heads/main
</file>

<file path="apps/web/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="apps/web/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="apps/web/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="apps/web/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="apps/web/src/app/api/auth/desktop/exchange/route.ts">
import { NextRequest, NextResponse } from "next/server";
import {
  validateAndConsumePendingToken,
  generateTokenPair,
} from "@/lib/desktop-auth";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { token } = body;

    if (!token) {
      return NextResponse.json({ error: "Token is required" }, { status: 400 });
    }

    // Validate and consume the pending token
    const pending = validateAndConsumePendingToken(token);

    if (!pending) {
      return NextResponse.json({ error: "Invalid or expired token" }, { status: 401 });
    }

    // Generate access and refresh tokens
    const { accessToken, refreshToken, expiresAt } = generateTokenPair({
      userId: pending.userId,
      email: pending.email,
      name: pending.name,
      avatar: pending.avatar,
    });

    // Return session data
    return NextResponse.json({
      user_id: pending.userId,
      email: pending.email,
      name: pending.name,
      avatar: pending.avatar,
      access_token: accessToken,
      refresh_token: refreshToken,
      expires_at: expiresAt,
    });
  } catch (error) {
    console.error("Token exchange error:", error);
    return NextResponse.json(
      { error: "Failed to exchange token" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/auth/desktop/refresh/route.ts">
import { NextRequest, NextResponse } from "next/server";
import {
  validateRefreshToken,
  generateTokenPair,
  revokeRefreshToken,
} from "@/lib/desktop-auth";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { refresh_token } = body;

    if (!refresh_token) {
      return NextResponse.json({ error: "Refresh token is required" }, { status: 400 });
    }

    // Validate the refresh token
    const tokenData = validateRefreshToken(refresh_token);

    if (!tokenData) {
      return NextResponse.json({ error: "Invalid or expired refresh token" }, { status: 401 });
    }

    // Revoke the old refresh token
    revokeRefreshToken(refresh_token);

    // Generate new token pair
    const { accessToken, refreshToken, expiresAt } = generateTokenPair({
      userId: tokenData.userId,
      email: tokenData.email,
      name: tokenData.name,
      avatar: tokenData.avatar,
    });

    // Return new session data
    return NextResponse.json({
      user_id: tokenData.userId,
      email: tokenData.email,
      name: tokenData.name,
      avatar: tokenData.avatar,
      access_token: accessToken,
      refresh_token: refreshToken,
      expires_at: expiresAt,
    });
  } catch (error) {
    console.error("Token refresh error:", error);
    return NextResponse.json(
      { error: "Failed to refresh token" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/keys/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { createDb, apiKeys, sql } from "@launcher/db";

const db = createDb(process.env.DATABASE_URL!);

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;

    // Verify the key belongs to the user before deleting
    const existingKey = await db.query.apiKeys.findFirst({
      where: (key, { eq, and }) => and(eq(key.id, id), eq(key.userId, user.id)),
    });

    if (!existingKey) {
      return NextResponse.json({ error: "API key not found" }, { status: 404 });
    }

    // Delete the key
    await db.delete(apiKeys).where(sql`${apiKeys.id} = ${id}`);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting API key:", error);
    return NextResponse.json(
      { error: "Failed to delete API key" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/keys/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { createDb, apiKeys } from "@launcher/db";
import { randomBytes, createHash } from "crypto";

const db = createDb(process.env.DATABASE_URL!);

export async function GET() {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userKeys = await db.query.apiKeys.findMany({
      where: (key, { eq }) => eq(key.userId, user.id),
      orderBy: (key, { desc }) => [desc(key.createdAt)],
    });

    return NextResponse.json({ keys: userKeys });
  } catch (error) {
    console.error("Error fetching API keys:", error);
    return NextResponse.json(
      { error: "Failed to fetch API keys" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { name } = body;

    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return NextResponse.json(
        { error: "Name is required" },
        { status: 400 }
      );
    }

    // Generate a secure API key
    const keyBytes = randomBytes(32);
    const key = `lnch_${keyBytes.toString("base64url")}`;
    const keyPrefix = key.substring(0, 12);
    const keyHash = createHash("sha256").update(key).digest("hex");

    // Insert the API key
    const [newKey] = await db
      .insert(apiKeys)
      .values({
        userId: user.id,
        name: name.trim(),
        keyHash,
        keyPrefix,
      })
      .returning();

    return NextResponse.json({
      key, // Only returned once, never stored in plain text
      apiKey: {
        id: newKey.id,
        name: newKey.name,
        keyPrefix: newKey.keyPrefix,
        lastUsedAt: newKey.lastUsedAt,
        expiresAt: newKey.expiresAt,
        createdAt: newKey.createdAt,
      },
    });
  } catch (error) {
    console.error("Error creating API key:", error);
    return NextResponse.json(
      { error: "Failed to create API key" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/plugins/submit/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { createDb, plugins, sql } from "@launcher/db";

const db = createDb(process.env.DATABASE_URL!);

export async function POST(request: NextRequest) {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const {
      id,
      name,
      version,
      description,
      longDescription,
      homepage,
      repository,
      downloadUrl,
      categories,
      permissions,
    } = body;

    // Validation
    if (!id || !name || !version || !description || !downloadUrl) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Validate ID format
    if (!/^[a-z0-9-]+$/.test(id)) {
      return NextResponse.json(
        { error: "Invalid plugin ID format" },
        { status: 400 }
      );
    }

    // Validate version format
    if (!/^\d+\.\d+\.\d+$/.test(version)) {
      return NextResponse.json(
        { error: "Invalid version format (use semver: x.y.z)" },
        { status: 400 }
      );
    }

    // Check if plugin ID already exists
    const existing = await db.query.plugins.findFirst({
      where: (p, { eq }) => eq(p.id, id),
    });

    if (existing) {
      return NextResponse.json(
        { error: "A plugin with this ID already exists" },
        { status: 409 }
      );
    }

    // Insert the plugin
    await db.insert(plugins).values({
      id,
      name,
      version,
      authorId: user.id,
      authorName: user.displayName || user.primaryEmail || "Anonymous",
      description,
      longDescription: longDescription || null,
      homepage: homepage || null,
      repository: repository || null,
      downloadUrl,
      categories: categories || [],
      permissions: permissions || [],
      downloads: 0,
      ratingCount: 0,
      verified: false,
      featured: false,
      publishedAt: new Date(),
    });

    return NextResponse.json({ id, success: true });
  } catch (error) {
    console.error("Plugin submission error:", error);
    return NextResponse.json(
      { error: "Failed to submit plugin" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/stripe/checkout/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { stripe, PRICING_TIERS, type PricingTier, type BillingInterval } from "@/lib/stripe";

export async function POST(request: NextRequest) {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { tier, interval } = body as { tier: PricingTier; interval: BillingInterval };

    if (!tier || !interval) {
      return NextResponse.json({ error: "Missing tier or interval" }, { status: 400 });
    }

    const tierConfig = PRICING_TIERS[tier];
    if (!tierConfig || tier === "free") {
      return NextResponse.json({ error: "Invalid tier" }, { status: 400 });
    }

    if (!("priceId" in tierConfig)) {
      return NextResponse.json({ error: "Tier has no price" }, { status: 400 });
    }

    const priceId = tierConfig.priceId[interval];

    // Check if user already has a Stripe customer ID
    // For now, we'll create a new customer each time (in production, store and reuse)
    const customer = await stripe.customers.create({
      email: user.primaryEmail || undefined,
      name: user.displayName || undefined,
      metadata: {
        userId: user.id,
      },
    });

    // Create checkout session
    const session = await stripe.checkout.sessions.create({
      customer: customer.id,
      mode: "subscription",
      payment_method_types: ["card"],
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      success_url: `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/dashboard/subscription?success=true`,
      cancel_url: `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/pricing?canceled=true`,
      subscription_data: {
        trial_period_days: 14,
        metadata: {
          userId: user.id,
          tier,
        },
      },
      metadata: {
        userId: user.id,
        tier,
      },
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("Stripe checkout error:", error);
    return NextResponse.json(
      { error: "Failed to create checkout session" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/stripe/portal/route.ts">
import { NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { stripe } from "@/lib/stripe";
import { createDb, subscriptions, sql } from "@launcher/db";

const db = createDb(process.env.DATABASE_URL!);

export async function GET() {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.redirect(new URL("/handler/sign-in", process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"));
    }

    // Get user's subscription to find Stripe customer ID
    const userSubscription = await db.query.subscriptions.findFirst({
      where: (sub, { eq }) => eq(sub.userId, user.id),
    });

    if (!userSubscription?.stripeCustomerId) {
      return NextResponse.redirect(new URL("/pricing", process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"));
    }

    // Create Stripe billing portal session
    const session = await stripe.billingPortal.sessions.create({
      customer: userSubscription.stripeCustomerId,
      return_url: `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/dashboard/subscription`,
    });

    return NextResponse.redirect(session.url);
  } catch (error) {
    console.error("Portal error:", error);
    return NextResponse.redirect(new URL("/dashboard/subscription?error=portal", process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"));
  }
}
</file>

<file path="apps/web/src/app/api/stripe/webhook/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stripe } from "@/lib/stripe";
import { createDb, subscriptions, sql } from "@launcher/db";
import type Stripe from "stripe";

const db = createDb(process.env.DATABASE_URL!);

// Type helper for Stripe subscription with period dates
interface SubscriptionWithPeriod extends Stripe.Subscription {
  current_period_start: number;
  current_period_end: number;
}

export async function POST(request: NextRequest) {
  const body = await request.text();
  const signature = request.headers.get("stripe-signature");

  if (!signature) {
    return NextResponse.json({ error: "Missing signature" }, { status: 400 });
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error("Webhook signature verification failed:", err);
    return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as Stripe.Checkout.Session;
        await handleCheckoutCompleted(session);
        break;
      }

      case "customer.subscription.updated": {
        const subscription = event.data.object as Stripe.Subscription;
        await handleSubscriptionUpdated(subscription);
        break;
      }

      case "customer.subscription.deleted": {
        const subscription = event.data.object as Stripe.Subscription;
        await handleSubscriptionDeleted(subscription);
        break;
      }

      case "invoice.payment_failed": {
        const invoice = event.data.object as Stripe.Invoice;
        await handlePaymentFailed(invoice);
        break;
      }

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("Webhook handler error:", error);
    return NextResponse.json({ error: "Webhook handler failed" }, { status: 500 });
  }
}

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.userId;
  const tier = session.metadata?.tier as "pro" | "team" | "enterprise";

  if (!userId || !tier) {
    console.error("Missing userId or tier in session metadata");
    return;
  }

  const subscriptionId = session.subscription as string;
  const customerId = session.customer as string;

  // Fetch the subscription to get period dates
  const stripeSubscription = await stripe.subscriptions.retrieve(subscriptionId);
  const subData = stripeSubscription as unknown as SubscriptionWithPeriod;

  // Upsert subscription record
  await db
    .insert(subscriptions)
    .values({
      userId,
      tier,
      status: subData.status === "trialing" ? "trialing" : "active",
      stripeCustomerId: customerId,
      stripeSubscriptionId: subscriptionId,
      currentPeriodStart: new Date(subData.current_period_start * 1000),
      currentPeriodEnd: new Date(subData.current_period_end * 1000),
      cancelAtPeriodEnd: subData.cancel_at_period_end,
    })
    .onConflictDoUpdate({
      target: subscriptions.userId,
      set: {
        tier,
        status: subData.status === "trialing" ? "trialing" : "active",
        stripeCustomerId: customerId,
        stripeSubscriptionId: subscriptionId,
        currentPeriodStart: new Date(subData.current_period_start * 1000),
        currentPeriodEnd: new Date(subData.current_period_end * 1000),
        cancelAtPeriodEnd: subData.cancel_at_period_end,
        updatedAt: new Date(),
      },
    });

  console.log(`Subscription created for user ${userId}: ${tier}`);
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;
  if (!userId) {
    console.error("Missing userId in subscription metadata");
    return;
  }

  const tier = subscription.metadata?.tier as "pro" | "team" | "enterprise" | undefined;
  const subWithPeriod = subscription as unknown as SubscriptionWithPeriod;

  await db
    .update(subscriptions)
    .set({
      status: mapStripeStatus(subscription.status),
      tier: tier || undefined,
      currentPeriodStart: new Date(subWithPeriod.current_period_start * 1000),
      currentPeriodEnd: new Date(subWithPeriod.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      updatedAt: new Date(),
    })
    .where(sql`${subscriptions.stripeSubscriptionId} = ${subscription.id}`);

  console.log(`Subscription updated for user ${userId}`);
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;
  if (!userId) {
    console.error("Missing userId in subscription metadata");
    return;
  }

  // Downgrade to free tier
  await db
    .update(subscriptions)
    .set({
      tier: "free",
      status: "canceled",
      cancelAtPeriodEnd: false,
      updatedAt: new Date(),
    })
    .where(sql`${subscriptions.stripeSubscriptionId} = ${subscription.id}`);

  console.log(`Subscription canceled for user ${userId}`);
}

async function handlePaymentFailed(invoice: Stripe.Invoice) {
  const customerId = invoice.customer as string;

  await db
    .update(subscriptions)
    .set({
      status: "past_due",
      updatedAt: new Date(),
    })
    .where(sql`${subscriptions.stripeCustomerId} = ${customerId}`);

  console.log(`Payment failed for customer ${customerId}`);
}

function mapStripeStatus(
  status: Stripe.Subscription.Status
): "active" | "canceled" | "past_due" | "trialing" {
  switch (status) {
    case "active":
      return "active";
    case "canceled":
    case "unpaid":
    case "incomplete_expired":
      return "canceled";
    case "past_due":
    case "incomplete":
      return "past_due";
    case "trialing":
      return "trialing";
    default:
      return "active";
  }
}
</file>

<file path="apps/web/src/app/api/usage/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { trackUsage, getMonthlyUsage, checkUsageLimit, type UsageType } from "@/lib/usage";
import { createDb, subscriptions } from "@launcher/db";
import { PRICING_TIERS } from "@/lib/stripe";

const db = createDb(process.env.DATABASE_URL!);

export async function GET() {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const usage = await getMonthlyUsage(user.id);
    
    // Get user's subscription tier
    const subscription = await db.query.subscriptions.findFirst({
      where: (sub, { eq }) => eq(sub.userId, user.id),
    });
    
    const tier = subscription?.tier || "free";
    const tierConfig = PRICING_TIERS[tier as keyof typeof PRICING_TIERS];

    return NextResponse.json({
      usage,
      limits: tierConfig.limits,
      tier,
    });
  } catch (error) {
    console.error("Error fetching usage:", error);
    return NextResponse.json(
      { error: "Failed to fetch usage" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const user = await stackServerApp.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { type, count = 1, metadata } = body as {
      type: UsageType;
      count?: number;
      metadata?: Record<string, unknown>;
    };

    if (!type || !["ai_query", "ai_embedding", "plugin_install", "search"].includes(type)) {
      return NextResponse.json(
        { error: "Invalid usage type" },
        { status: 400 }
      );
    }

    // Get user's subscription tier
    const subscription = await db.query.subscriptions.findFirst({
      where: (sub, { eq }) => eq(sub.userId, user.id),
    });
    
    const tier = subscription?.tier || "free";
    const tierConfig = PRICING_TIERS[tier as keyof typeof PRICING_TIERS];

    // Check if user has remaining quota
    const limitCheck = await checkUsageLimit(user.id, type, tierConfig.limits);
    
    if (!limitCheck.allowed) {
      return NextResponse.json(
        { 
          error: "Usage limit exceeded",
          remaining: 0,
          limit: tierConfig.limits,
        },
        { status: 429 }
      );
    }

    // Track the usage
    await trackUsage(user.id, type, count, metadata);

    return NextResponse.json({
      success: true,
      remaining: limitCheck.remaining === -1 ? -1 : limitCheck.remaining - count,
    });
  } catch (error) {
    console.error("Error tracking usage:", error);
    return NextResponse.json(
      { error: "Failed to track usage" },
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/auth/desktop/page.tsx">
import { stackServerApp } from "@/stack";
import { redirect } from "next/navigation";
import { generatePendingToken } from "@/lib/desktop-auth";

export default async function DesktopAuthPage({
  searchParams,
}: {
  searchParams: Promise<{ redirect_uri?: string }>;
}) {
  const user = await stackServerApp.getUser();
  const params = await searchParams;
  const redirectUri = params.redirect_uri || "launcher://auth/callback";

  // If not logged in, redirect to sign-in with return URL
  if (!user) {
    const returnUrl = encodeURIComponent(`/auth/desktop?redirect_uri=${encodeURIComponent(redirectUri)}`);
    redirect(`/handler/sign-in?after_auth_return_to=${returnUrl}`);
  }

  // User is logged in, generate a one-time token
  const token = generatePendingToken({
    id: user.id,
    email: user.primaryEmail,
    name: user.displayName,
    avatar: user.profileImageUrl,
  });

  // Redirect to desktop app with token
  const callbackUrl = `${redirectUri}?token=${token}`;

  return (
    <div className="min-h-screen bg-zinc-950 text-white flex items-center justify-center">
      <div className="text-center max-w-md mx-auto px-6">
        <div className="w-16 h-16 bg-violet-500 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg className="w-8 h-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        </div>
        <h1 className="text-2xl font-bold mb-2">Authentication Successful</h1>
        <p className="text-zinc-400 mb-6">
          You&apos;re signed in as <span className="text-white font-medium">{user.displayName || user.primaryEmail}</span>
        </p>
        <p className="text-zinc-500 text-sm mb-6">
          Redirecting you back to the Launcher app...
        </p>
        <a
          href={callbackUrl}
          className="inline-flex items-center gap-2 bg-violet-500 hover:bg-violet-600 text-white px-6 py-3 rounded-lg font-medium transition-colors"
        >
          Open Launcher
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
          </svg>
        </a>
        <p className="text-zinc-600 text-xs mt-6">
          If the app doesn&apos;t open automatically, click the button above.
        </p>

        {/* Auto-redirect script */}
        <script
          dangerouslySetInnerHTML={{
            __html: `
              setTimeout(function() {
                window.location.href = "${callbackUrl}";
              }, 1500);
            `,
          }}
        />
      </div>
    </div>
  );
}
</file>

<file path="apps/web/src/app/dashboard/api-keys/api-key-manager.tsx">
"use client";

import { useState } from "react";

interface ApiKey {
  id: string;
  name: string;
  keyPrefix: string;
  lastUsedAt: Date | null;
  expiresAt: Date | null;
  createdAt: Date;
}

interface ApiKeyManagerProps {
  initialKeys: ApiKey[];
}

export function ApiKeyManager({ initialKeys }: ApiKeyManagerProps) {
  const [keys, setKeys] = useState<ApiKey[]>(initialKeys);
  const [newKeyName, setNewKeyName] = useState("");
  const [newKey, setNewKey] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreateKey = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newKeyName.trim()) return;

    setLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/keys", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: newKeyName }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Failed to create API key");
      }

      setNewKey(data.key);
      setKeys((prev) => [data.apiKey, ...prev]);
      setNewKeyName("");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteKey = async (keyId: string) => {
    if (!confirm("Are you sure you want to delete this API key? This cannot be undone.")) {
      return;
    }

    try {
      const response = await fetch(`/api/keys/${keyId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete API key");
      }

      setKeys((prev) => prev.filter((k) => k.id !== keyId));
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    }
  };

  const copyToClipboard = async (text: string) => {
    await navigator.clipboard.writeText(text);
  };

  return (
    <div className="space-y-6">
      {/* Create New Key */}
      <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
        <h3 className="text-lg font-semibold mb-4">Create New API Key</h3>
        
        {newKey ? (
          <div className="space-y-4">
            <div className="bg-green-500/10 border border-green-500/20 text-green-400 px-4 py-3 rounded-lg">
              <p className="font-medium mb-2">API key created successfully!</p>
              <p className="text-sm text-green-300/80">
                Copy this key now. You won&apos;t be able to see it again.
              </p>
            </div>
            <div className="flex items-center gap-2">
              <code className="flex-1 bg-zinc-800 px-4 py-3 rounded-lg font-mono text-sm break-all">
                {newKey}
              </code>
              <button
                onClick={() => copyToClipboard(newKey)}
                className="shrink-0 bg-zinc-800 hover:bg-zinc-700 px-4 py-3 rounded-lg transition-colors"
              >
                Copy
              </button>
            </div>
            <button
              onClick={() => setNewKey(null)}
              className="text-sm text-zinc-400 hover:text-white"
            >
              Done
            </button>
          </div>
        ) : (
          <form onSubmit={handleCreateKey} className="flex gap-3">
            <input
              type="text"
              value={newKeyName}
              onChange={(e) => setNewKeyName(e.target.value)}
              placeholder="Key name (e.g., Desktop App)"
              className="flex-1 bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
            />
            <button
              type="submit"
              disabled={loading || !newKeyName.trim()}
              className="bg-violet-500 hover:bg-violet-600 disabled:opacity-50 disabled:cursor-not-allowed text-white px-6 py-2 rounded-lg font-medium transition-colors"
            >
              {loading ? "Creating..." : "Create Key"}
            </button>
          </form>
        )}

        {error && (
          <div className="mt-4 bg-red-500/10 border border-red-500/20 text-red-400 px-4 py-3 rounded-lg">
            {error}
          </div>
        )}
      </div>

      {/* Existing Keys */}
      <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
        <h3 className="text-lg font-semibold mb-4">Your API Keys</h3>
        
        {keys.length === 0 ? (
          <p className="text-zinc-500 text-center py-8">
            No API keys yet. Create one to get started.
          </p>
        ) : (
          <div className="space-y-3">
            {keys.map((key) => (
              <div
                key={key.id}
                className="flex items-center justify-between bg-zinc-800/50 rounded-lg px-4 py-3"
              >
                <div>
                  <p className="font-medium">{key.name}</p>
                  <div className="flex items-center gap-4 text-sm text-zinc-500">
                    <span className="font-mono">{key.keyPrefix}...</span>
                    <span>
                      Created {new Date(key.createdAt).toLocaleDateString()}
                    </span>
                    {key.lastUsedAt && (
                      <span>
                        Last used {new Date(key.lastUsedAt).toLocaleDateString()}
                      </span>
                    )}
                  </div>
                </div>
                <button
                  onClick={() => handleDeleteKey(key.id)}
                  className="text-red-400 hover:text-red-300 text-sm"
                >
                  Delete
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/web/src/app/dashboard/api-keys/page.tsx">
import { stackServerApp } from "@/stack";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Header } from "@/components/header";
import { createDb, apiKeys } from "@launcher/db";
import { ApiKeyManager } from "./api-key-manager";

const db = createDb(process.env.DATABASE_URL!);

export default async function ApiKeysPage() {
  const user = await stackServerApp.getUser();

  if (!user) {
    redirect("/handler/sign-in");
  }

  // Fetch user's API keys
  const userApiKeys = await db.query.apiKeys.findMany({
    where: (key, { eq }) => eq(key.userId, user.id),
    orderBy: (key, { desc }) => [desc(key.createdAt)],
  });

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-4xl mx-auto px-6 py-8">
        <div className="mb-8">
          <Link
            href="/dashboard"
            className="text-zinc-400 hover:text-white text-sm mb-4 inline-block"
          >
            â† Back to Dashboard
          </Link>
          <h2 className="text-3xl font-bold mb-2">API Keys</h2>
          <p className="text-zinc-400">
            Manage API keys for syncing your desktop app with your account
          </p>
        </div>

        {/* Info Box */}
        <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
          <h3 className="font-semibold mb-2">How to use API keys</h3>
          <ol className="text-sm text-zinc-400 space-y-2 list-decimal list-inside">
            <li>Create a new API key below</li>
            <li>Copy the key (it will only be shown once)</li>
            <li>In the Launcher desktop app, go to Settings â†’ Account</li>
            <li>Paste your API key to enable cloud sync</li>
          </ol>
        </div>

        <ApiKeyManager initialKeys={userApiKeys} />
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/dashboard/subscription/page.tsx">
import { stackServerApp } from "@/stack";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Header } from "@/components/header";
import { createDb, subscriptions } from "@launcher/db";
import { PRICING_TIERS } from "@/lib/stripe";

const db = createDb(process.env.DATABASE_URL!);

export default async function SubscriptionPage({
  searchParams,
}: {
  searchParams: Promise<{ success?: string; canceled?: string }>;
}) {
  const user = await stackServerApp.getUser();

  if (!user) {
    redirect("/handler/sign-in");
  }

  const params = await searchParams;

  // Fetch user's subscription
  const userSubscription = await db.query.subscriptions.findFirst({
    where: (sub, { eq }) => eq(sub.userId, user.id),
  });

  const tier = userSubscription?.tier || "free";
  const tierConfig = PRICING_TIERS[tier as keyof typeof PRICING_TIERS];
  const isTrialing = userSubscription?.status === "trialing";
  const isPastDue = userSubscription?.status === "past_due";

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-4xl mx-auto px-6 py-8">
        <div className="mb-8">
          <Link
            href="/dashboard"
            className="text-zinc-400 hover:text-white text-sm mb-4 inline-block"
          >
            â† Back to Dashboard
          </Link>
          <h2 className="text-3xl font-bold mb-2">Subscription</h2>
          <p className="text-zinc-400">Manage your subscription and billing</p>
        </div>

        {/* Success/Cancel Messages */}
        {params.success && (
          <div className="bg-green-500/10 border border-green-500/20 text-green-400 px-4 py-3 rounded-lg mb-6">
            ðŸŽ‰ Your subscription has been activated! Welcome to {tierConfig.name}.
          </div>
        )}
        {params.canceled && (
          <div className="bg-yellow-500/10 border border-yellow-500/20 text-yellow-400 px-4 py-3 rounded-lg mb-6">
            Checkout was canceled. No changes were made to your subscription.
          </div>
        )}

        {/* Current Plan */}
        <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
          <div className="flex items-start justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold mb-1">Current Plan</h3>
              <div className="flex items-center gap-2">
                <span className="text-2xl font-bold text-violet-400">{tierConfig.name}</span>
                {isTrialing && (
                  <span className="text-xs bg-violet-500/20 text-violet-300 px-2 py-1 rounded">
                    Trial
                  </span>
                )}
                {isPastDue && (
                  <span className="text-xs bg-red-500/20 text-red-300 px-2 py-1 rounded">
                    Past Due
                  </span>
                )}
              </div>
            </div>
            {tier !== "free" && (
              <Link
                href="/api/stripe/portal"
                className="text-sm text-zinc-400 hover:text-white"
              >
                Manage Billing â†’
              </Link>
            )}
          </div>

          {userSubscription?.currentPeriodEnd && (
            <p className="text-sm text-zinc-500">
              {userSubscription.cancelAtPeriodEnd
                ? `Your plan will be canceled on ${new Date(userSubscription.currentPeriodEnd).toLocaleDateString()}`
                : `Next billing date: ${new Date(userSubscription.currentPeriodEnd).toLocaleDateString()}`}
            </p>
          )}

          <div className="mt-4 pt-4 border-t border-zinc-800">
            <h4 className="text-sm font-medium text-zinc-400 mb-3">Plan Features</h4>
            <ul className="grid grid-cols-1 md:grid-cols-2 gap-2">
              {tierConfig.features.map((feature, i) => (
                <li key={i} className="flex items-center gap-2 text-sm">
                  <svg
                    className="w-4 h-4 text-green-400 shrink-0"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M5 13l4 4L19 7"
                    />
                  </svg>
                  <span className="text-zinc-300">{feature}</span>
                </li>
              ))}
            </ul>
          </div>
        </div>

        {/* Usage */}
        <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
          <h3 className="text-lg font-semibold mb-4">Usage This Month</h3>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm mb-1">
                <span className="text-zinc-400">AI Queries</span>
                <span>
                  0 / {tierConfig.limits.aiQueriesPerMonth === -1 ? "âˆž" : tierConfig.limits.aiQueriesPerMonth}
                </span>
              </div>
              <div className="h-2 bg-zinc-800 rounded-full overflow-hidden">
                <div
                  className="h-full bg-violet-500 rounded-full"
                  style={{ width: "0%" }}
                />
              </div>
            </div>
            <div>
              <div className="flex justify-between text-sm mb-1">
                <span className="text-zinc-400">Installed Plugins</span>
                <span>
                  0 / {tierConfig.limits.maxPlugins === -1 ? "âˆž" : tierConfig.limits.maxPlugins}
                </span>
              </div>
              <div className="h-2 bg-zinc-800 rounded-full overflow-hidden">
                <div
                  className="h-full bg-violet-500 rounded-full"
                  style={{ width: "0%" }}
                />
              </div>
            </div>
          </div>
        </div>

        {/* Upgrade CTA */}
        {tier === "free" && (
          <div className="bg-linear-to-r from-violet-500/10 to-purple-500/10 border border-violet-500/20 rounded-xl p-6">
            <h3 className="text-lg font-semibold mb-2">Upgrade to Pro</h3>
            <p className="text-zinc-400 text-sm mb-4">
              Get 20x more AI queries, cloud sync, and priority support.
            </p>
            <Link
              href="/pricing"
              className="inline-flex items-center gap-2 bg-violet-500 hover:bg-violet-600 text-white px-4 py-2 rounded-lg font-medium transition-colors"
            >
              View Plans
              <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
              </svg>
            </Link>
          </div>
        )}

        {/* Cancel Subscription */}
        {tier !== "free" && !userSubscription?.cancelAtPeriodEnd && (
          <div className="mt-8 pt-8 border-t border-zinc-800">
            <h3 className="text-sm font-medium text-zinc-400 mb-2">Cancel Subscription</h3>
            <p className="text-sm text-zinc-500 mb-4">
              You can cancel your subscription at any time. You&apos;ll keep access until the end of your billing period.
            </p>
            <Link
              href="/api/stripe/portal"
              className="text-sm text-red-400 hover:text-red-300"
            >
              Cancel subscription â†’
            </Link>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/dashboard/page.tsx">
import { stackServerApp } from "@/stack";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Header } from "@/components/header";
import { getMonthlyUsage } from "@/lib/usage";
import { createDb, subscriptions, userPlugins } from "@launcher/db";
import { PRICING_TIERS } from "@/lib/stripe";

const db = createDb(process.env.DATABASE_URL!);

export default async function DashboardPage() {
  const user = await stackServerApp.getUser();

  if (!user) {
    redirect("/handler/sign-in");
  }

  // Fetch user data in parallel
  const [usage, subscription, installedPlugins] = await Promise.all([
    getMonthlyUsage(user.id),
    db.query.subscriptions.findFirst({
      where: (sub, { eq }) => eq(sub.userId, user.id),
    }),
    db.query.userPlugins.findMany({
      where: (up, { eq }) => eq(up.userId, user.id),
    }),
  ]);

  const tier = subscription?.tier || "free";
  const tierConfig = PRICING_TIERS[tier as keyof typeof PRICING_TIERS];
  const aiQueryLimit = tierConfig.limits.aiQueriesPerMonth;
  const pluginLimit = tierConfig.limits.maxPlugins;

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-6xl mx-auto px-6 py-8">
        <div className="mb-8">
          <h2 className="text-3xl font-bold mb-2">Dashboard</h2>
          <p className="text-zinc-400">
            Welcome back, {user?.displayName || user?.primaryEmail || "User"}
          </p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          {/* Usage Stats */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h3 className="text-sm font-medium text-zinc-400 mb-1">AI Queries</h3>
            <p className="text-3xl font-bold">
              {usage.aiQueries} / {aiQueryLimit === -1 ? "âˆž" : aiQueryLimit}
            </p>
            <p className="text-xs text-zinc-500 mt-1">{tierConfig.name} tier limit</p>
          </div>

          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h3 className="text-sm font-medium text-zinc-400 mb-1">Installed Plugins</h3>
            <p className="text-3xl font-bold">
              {installedPlugins.length}{pluginLimit !== -1 ? ` / ${pluginLimit}` : ""}
            </p>
            <p className="text-xs text-zinc-500 mt-1">
              {pluginLimit === -1 ? "Unlimited" : `${pluginLimit} max on ${tierConfig.name} tier`}
            </p>
          </div>

          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h3 className="text-sm font-medium text-zinc-400 mb-1">Subscription</h3>
            <p className="text-3xl font-bold">{tierConfig.name}</p>
            {tier === "free" ? (
              <Link href="/pricing" className="text-xs text-violet-400 hover:text-violet-300 mt-1 inline-block">
                Upgrade â†’
              </Link>
            ) : (
              <Link href="/dashboard/subscription" className="text-xs text-zinc-500 hover:text-zinc-400 mt-1 inline-block">
                Manage â†’
              </Link>
            )}
          </div>
        </div>

        {/* Quick Actions */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h3 className="text-lg font-semibold mb-4">Quick Actions</h3>
            <div className="space-y-3">
              <Link
                href="/"
                className="flex items-center gap-3 p-3 bg-zinc-800/50 rounded-lg hover:bg-zinc-800 transition-colors"
              >
                <span className="text-xl">ðŸ”Œ</span>
                <div>
                  <p className="font-medium">Browse Plugins</p>
                  <p className="text-sm text-zinc-500">Discover new plugins</p>
                </div>
              </Link>
              <Link
                href="/account/settings"
                className="flex items-center gap-3 p-3 bg-zinc-800/50 rounded-lg hover:bg-zinc-800 transition-colors"
              >
                <span className="text-xl">âš™ï¸</span>
                <div>
                  <p className="font-medium">Account Settings</p>
                  <p className="text-sm text-zinc-500">Manage your profile</p>
                </div>
              </Link>
              <Link
                href="/dashboard/api-keys"
                className="flex items-center gap-3 p-3 bg-zinc-800/50 rounded-lg hover:bg-zinc-800 transition-colors"
              >
                <span className="text-xl">ðŸ”‘</span>
                <div>
                  <p className="font-medium">API Keys</p>
                  <p className="text-sm text-zinc-500">Sync with desktop app</p>
                </div>
              </Link>
            </div>
          </div>

          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h3 className="text-lg font-semibold mb-4">Recent Activity</h3>
            <div className="text-center py-8 text-zinc-500">
              <p>No recent activity</p>
              <p className="text-sm mt-1">Your plugin installs and searches will appear here</p>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/handler/[...stack]/page.tsx">
import { StackHandler } from "@stackframe/stack";
import { stackServerApp } from "@/stack";

export default function Handler(props: { params: Promise<{ stack: string[] }> }) {
  return <StackHandler fullPage app={stackServerApp} routeProps={props} />;
}
</file>

<file path="apps/web/src/app/plugins/[id]/page.tsx">
import Link from "next/link";
import { notFound } from "next/navigation";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";

interface RegistryPlugin {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  homepage: string | null;
  repository: string | null;
  download_url: string;
  checksum: string | null;
  permissions: string[];
  categories: string[];
  downloads: number;
  rating: number | null;
}

async function getPlugin(id: string): Promise<RegistryPlugin | null> {
  const res = await fetch(`${API_URL}/api/plugins/${id}`, {
    cache: "no-store",
  });
  if (!res.ok) return null;
  return res.json();
}

const categoryColors: Record<string, string> = {
  Productivity: "bg-blue-500/20 text-blue-400 border-blue-500/30",
  Security: "bg-red-500/20 text-red-400 border-red-500/30",
  Development: "bg-green-500/20 text-green-400 border-green-500/30",
  Media: "bg-purple-500/20 text-purple-400 border-purple-500/30",
  Utilities: "bg-yellow-500/20 text-yellow-400 border-yellow-500/30",
  Tasks: "bg-orange-500/20 text-orange-400 border-orange-500/30",
  DevOps: "bg-cyan-500/20 text-cyan-400 border-cyan-500/30",
  Examples: "bg-zinc-500/20 text-zinc-400 border-zinc-500/30",
  Music: "bg-pink-500/20 text-pink-400 border-pink-500/30",
  "Project Management": "bg-indigo-500/20 text-indigo-400 border-indigo-500/30",
};

const permissionDescriptions: Record<string, { label: string; description: string; icon: string }> = {
  logging: { label: "Logging", description: "Write to application logs", icon: "ðŸ“" },
  clipboard: { label: "Clipboard", description: "Read and write clipboard contents", icon: "ðŸ“‹" },
  network: { label: "Network", description: "Make HTTP requests to external services", icon: "ðŸŒ" },
  "oauth:linear": { label: "Linear OAuth", description: "Authenticate with Linear", icon: "ðŸ”—" },
  "oauth:todoist": { label: "Todoist OAuth", description: "Authenticate with Todoist", icon: "ðŸ”—" },
  "oauth:spotify": { label: "Spotify OAuth", description: "Authenticate with Spotify", icon: "ðŸ”—" },
  "shell:op": { label: "1Password CLI", description: "Execute 1Password CLI commands", icon: "âš™ï¸" },
};

export default async function PluginDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const plugin = await getPlugin(id);

  if (!plugin) {
    notFound();
  }

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <header className="border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <Link href="/" className="flex items-center gap-3">
              <div className="w-8 h-8 bg-gradient-to-br from-violet-500 to-fuchsia-500 rounded-lg" />
              <h1 className="text-xl font-semibold">Launcher Plugins</h1>
            </Link>
          </div>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-6 py-8">
        <Link
          href="/"
          className="text-sm text-zinc-500 hover:text-white transition-colors mb-6 inline-flex items-center gap-1"
        >
          â† Back to all plugins
        </Link>

        <div className="mt-6">
          {/* Plugin Header */}
          <div className="flex items-start justify-between gap-6 mb-8">
            <div className="flex-1">
              <div className="flex items-center gap-4 mb-3">
                <div className="w-16 h-16 bg-gradient-to-br from-violet-500 to-fuchsia-500 rounded-2xl flex items-center justify-center text-2xl font-bold">
                  {plugin.name.charAt(0)}
                </div>
                <div>
                  <h2 className="text-3xl font-bold">{plugin.name}</h2>
                  <p className="text-zinc-400">
                    v{plugin.version} â€¢ by {plugin.author || "Unknown"}
                  </p>
                </div>
              </div>
            </div>

            <div className="flex flex-col items-end gap-2">
              {plugin.rating && (
                <div className="flex items-center gap-2 text-yellow-500">
                  <span className="text-2xl">â˜…</span>
                  <span className="text-xl font-semibold">{plugin.rating.toFixed(1)}</span>
                </div>
              )}
              <p className="text-sm text-zinc-500">
                {plugin.downloads.toLocaleString()} downloads
              </p>
            </div>
          </div>

          {/* Categories */}
          <div className="flex flex-wrap gap-2 mb-8">
            {plugin.categories.map((cat) => (
              <span
                key={cat}
                className={`text-sm px-3 py-1 rounded-full border ${
                  categoryColors[cat] || "bg-zinc-700/50 text-zinc-400 border-zinc-600"
                }`}
              >
                {cat}
              </span>
            ))}
          </div>

          {/* Description */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
            <h3 className="text-lg font-semibold mb-3">Description</h3>
            <p className="text-zinc-300 leading-relaxed">
              {plugin.description || "No description available."}
            </p>
          </div>

          {/* Install Button */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
            <h3 className="text-lg font-semibold mb-3">Installation</h3>
            <p className="text-zinc-400 text-sm mb-4">
              Install this plugin using the Launcher CLI or directly from the app.
            </p>
            <div className="flex flex-col sm:flex-row gap-3">
              <button className="bg-violet-600 hover:bg-violet-500 text-white px-6 py-2.5 rounded-lg font-medium transition-colors">
                Install Plugin
              </button>
              <code className="bg-zinc-800 border border-zinc-700 px-4 py-2.5 rounded-lg text-sm text-zinc-300 font-mono">
                launcher install {plugin.id}
              </code>
            </div>
          </div>

          {/* Permissions */}
          {plugin.permissions.length > 0 && (
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 mb-6">
              <h3 className="text-lg font-semibold mb-3">Permissions</h3>
              <p className="text-zinc-400 text-sm mb-4">
                This plugin requires the following permissions to function:
              </p>
              <div className="space-y-3">
                {plugin.permissions.map((perm) => {
                  const info = permissionDescriptions[perm] || {
                    label: perm,
                    description: "Custom permission",
                    icon: "ðŸ”’",
                  };
                  return (
                    <div
                      key={perm}
                      className="flex items-start gap-3 bg-zinc-800/50 rounded-lg p-3"
                    >
                      <span className="text-lg">{info.icon}</span>
                      <div>
                        <p className="font-medium text-zinc-200">{info.label}</p>
                        <p className="text-sm text-zinc-500">{info.description}</p>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Links */}
          {(plugin.homepage || plugin.repository) && (
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
              <h3 className="text-lg font-semibold mb-3">Links</h3>
              <div className="flex flex-wrap gap-4">
                {plugin.homepage && (
                  <a
                    href={plugin.homepage}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-violet-400 hover:text-violet-300 transition-colors flex items-center gap-2"
                  >
                    <span>ðŸŒ</span> Homepage
                  </a>
                )}
                {plugin.repository && (
                  <a
                    href={plugin.repository}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-violet-400 hover:text-violet-300 transition-colors flex items-center gap-2"
                  >
                    <span>ðŸ“¦</span> Repository
                  </a>
                )}
              </div>
            </div>
          )}
        </div>
      </main>

      <footer className="border-t border-zinc-800 mt-16">
        <div className="max-w-4xl mx-auto px-6 py-8 text-center text-zinc-500 text-sm">
          <p>Launcher Plugin Marketplace</p>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="apps/web/src/app/plugins/submit/page.tsx">
"use client";

import { useState } from "react";
import { useUser } from "@stackframe/stack";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { Header } from "@/components/header";

const CATEGORIES = [
  "Productivity",
  "Developer Tools",
  "Communication",
  "Finance",
  "Entertainment",
  "Utilities",
  "AI & Machine Learning",
  "Data & Analytics",
];

const PERMISSIONS = [
  { id: "fs:read", label: "Read files", description: "Read files from the filesystem" },
  { id: "fs:write", label: "Write files", description: "Write files to the filesystem" },
  { id: "net:http", label: "HTTP requests", description: "Make HTTP requests to external services" },
  { id: "clipboard", label: "Clipboard access", description: "Read and write to clipboard" },
  { id: "notifications", label: "Notifications", description: "Show system notifications" },
  { id: "config", label: "Configuration", description: "Store and retrieve plugin configuration" },
];

interface FormData {
  id: string;
  name: string;
  version: string;
  description: string;
  longDescription: string;
  homepage: string;
  repository: string;
  downloadUrl: string;
  categories: string[];
  permissions: string[];
}

export default function SubmitPluginPage() {
  const user = useUser();
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [formData, setFormData] = useState<FormData>({
    id: "",
    name: "",
    version: "1.0.0",
    description: "",
    longDescription: "",
    homepage: "",
    repository: "",
    downloadUrl: "",
    categories: [],
    permissions: [],
  });

  if (!user) {
    return (
      <div className="min-h-screen bg-zinc-950 text-white">
        <Header />
        <main className="max-w-2xl mx-auto px-6 py-12 text-center">
          <h1 className="text-2xl font-bold mb-4">Sign in required</h1>
          <p className="text-zinc-400 mb-6">
            You need to sign in to submit a plugin to the marketplace.
          </p>
          <Link
            href="/handler/sign-in?after_auth_return_to=/plugins/submit"
            className="inline-flex items-center gap-2 bg-violet-500 hover:bg-violet-600 text-white px-6 py-3 rounded-lg font-medium transition-colors"
          >
            Sign In
          </Link>
        </main>
      </div>
    );
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/plugins/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Failed to submit plugin");
      }

      router.push(`/plugins/${data.id}?submitted=true`);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handleCategoryToggle = (category: string) => {
    setFormData((prev) => ({
      ...prev,
      categories: prev.categories.includes(category)
        ? prev.categories.filter((c) => c !== category)
        : [...prev.categories, category],
    }));
  };

  const handlePermissionToggle = (permission: string) => {
    setFormData((prev) => ({
      ...prev,
      permissions: prev.permissions.includes(permission)
        ? prev.permissions.filter((p) => p !== permission)
        : [...prev.permissions, permission],
    }));
  };

  const generateId = () => {
    const slug = formData.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");
    setFormData((prev) => ({ ...prev, id: slug }));
  };

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-3xl mx-auto px-6 py-8">
        <div className="mb-8">
          <Link
            href="/"
            className="text-zinc-400 hover:text-white text-sm mb-4 inline-block"
          >
            â† Back to Marketplace
          </Link>
          <h1 className="text-3xl font-bold mb-2">Submit a Plugin</h1>
          <p className="text-zinc-400">
            Share your plugin with the Launcher community
          </p>
        </div>

        {error && (
          <div className="bg-red-500/10 border border-red-500/20 text-red-400 px-4 py-3 rounded-lg mb-6">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Basic Info */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h2 className="text-lg font-semibold mb-4">Basic Information</h2>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Plugin Name *
                </label>
                <input
                  type="text"
                  required
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  onBlur={generateId}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="My Awesome Plugin"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Plugin ID *
                </label>
                <input
                  type="text"
                  required
                  value={formData.id}
                  onChange={(e) => setFormData({ ...formData, id: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="my-awesome-plugin"
                  pattern="[a-z0-9-]+"
                />
                <p className="text-xs text-zinc-500 mt-1">
                  Lowercase letters, numbers, and hyphens only. This cannot be changed later.
                </p>
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Version *
                </label>
                <input
                  type="text"
                  required
                  value={formData.version}
                  onChange={(e) => setFormData({ ...formData, version: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="1.0.0"
                  pattern="\d+\.\d+\.\d+"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Short Description *
                </label>
                <input
                  type="text"
                  required
                  maxLength={160}
                  value={formData.description}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="A brief description of what your plugin does"
                />
                <p className="text-xs text-zinc-500 mt-1">
                  {formData.description.length}/160 characters
                </p>
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Long Description
                </label>
                <textarea
                  rows={5}
                  value={formData.longDescription}
                  onChange={(e) => setFormData({ ...formData, longDescription: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500 resize-none"
                  placeholder="A detailed description of your plugin, its features, and how to use it. Markdown is supported."
                />
              </div>
            </div>
          </div>

          {/* Links */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h2 className="text-lg font-semibold mb-4">Links</h2>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Download URL *
                </label>
                <input
                  type="url"
                  required
                  value={formData.downloadUrl}
                  onChange={(e) => setFormData({ ...formData, downloadUrl: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="https://github.com/user/repo/releases/download/v1.0.0/plugin.wasm"
                />
                <p className="text-xs text-zinc-500 mt-1">
                  Direct URL to the compiled .wasm plugin file
                </p>
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Homepage
                </label>
                <input
                  type="url"
                  value={formData.homepage}
                  onChange={(e) => setFormData({ ...formData, homepage: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="https://my-plugin.com"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-zinc-300 mb-2">
                  Repository
                </label>
                <input
                  type="url"
                  value={formData.repository}
                  onChange={(e) => setFormData({ ...formData, repository: e.target.value })}
                  className="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500"
                  placeholder="https://github.com/user/my-plugin"
                />
              </div>
            </div>
          </div>

          {/* Categories */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h2 className="text-lg font-semibold mb-4">Categories</h2>
            <p className="text-sm text-zinc-400 mb-4">
              Select one or more categories that best describe your plugin.
            </p>
            <div className="flex flex-wrap gap-2">
              {CATEGORIES.map((category) => (
                <button
                  key={category}
                  type="button"
                  onClick={() => handleCategoryToggle(category)}
                  className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                    formData.categories.includes(category)
                      ? "bg-violet-500 text-white"
                      : "bg-zinc-800 text-zinc-300 hover:bg-zinc-700"
                  }`}
                >
                  {category}
                </button>
              ))}
            </div>
          </div>

          {/* Permissions */}
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
            <h2 className="text-lg font-semibold mb-4">Permissions</h2>
            <p className="text-sm text-zinc-400 mb-4">
              Select the permissions your plugin requires. Users will see these before installing.
            </p>
            <div className="space-y-3">
              {PERMISSIONS.map((permission) => (
                <label
                  key={permission.id}
                  className="flex items-start gap-3 cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={formData.permissions.includes(permission.id)}
                    onChange={() => handlePermissionToggle(permission.id)}
                    className="mt-1 w-4 h-4 rounded border-zinc-600 bg-zinc-800 text-violet-500 focus:ring-violet-500 focus:ring-offset-zinc-900"
                  />
                  <div>
                    <span className="text-sm font-medium text-zinc-200">
                      {permission.label}
                    </span>
                    <p className="text-xs text-zinc-500">{permission.description}</p>
                  </div>
                </label>
              ))}
            </div>
          </div>

          {/* Submit */}
          <div className="flex items-center justify-between">
            <p className="text-sm text-zinc-500">
              By submitting, you agree to our plugin guidelines.
            </p>
            <button
              type="submit"
              disabled={loading}
              className="bg-violet-500 hover:bg-violet-600 disabled:opacity-50 disabled:cursor-not-allowed text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center gap-2"
            >
              {loading ? (
                <>
                  <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                      fill="none"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                    />
                  </svg>
                  Submitting...
                </>
              ) : (
                "Submit Plugin"
              )}
            </button>
          </div>
        </form>
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/pricing/page.tsx">
"use client";

import { useState } from "react";
import { useUser } from "@stackframe/stack";
import { Header } from "@/components/header";
import { PRICING_TIERS, type BillingInterval } from "@/lib/stripe";

export default function PricingPage() {
  const user = useUser();
  const [billingInterval, setBillingInterval] = useState<BillingInterval>("monthly");
  const [loading, setLoading] = useState<string | null>(null);

  const handleSubscribe = async (tier: string) => {
    if (!user) {
      window.location.href = "/handler/sign-in?after_auth_return_to=/pricing";
      return;
    }

    if (tier === "free") return;

    setLoading(tier);
    try {
      const response = await fetch("/api/stripe/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tier, interval: billingInterval }),
      });

      const data = await response.json();
      if (data.url) {
        window.location.href = data.url;
      } else {
        console.error("No checkout URL returned");
      }
    } catch (error) {
      console.error("Checkout error:", error);
    } finally {
      setLoading(null);
    }
  };

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-6xl mx-auto px-6 py-12">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold mb-4">Simple, transparent pricing</h1>
          <p className="text-zinc-400 text-lg max-w-2xl mx-auto">
            Choose the plan that fits your needs. Upgrade or downgrade anytime.
          </p>

          {/* Billing Toggle */}
          <div className="flex items-center justify-center gap-4 mt-8">
            <span className={billingInterval === "monthly" ? "text-white" : "text-zinc-500"}>
              Monthly
            </span>
            <button
              onClick={() => setBillingInterval(billingInterval === "monthly" ? "yearly" : "monthly")}
              className="relative w-14 h-7 bg-zinc-800 rounded-full transition-colors"
            >
              <span
                className={`absolute top-1 w-5 h-5 bg-violet-500 rounded-full transition-transform ${
                  billingInterval === "yearly" ? "translate-x-8" : "translate-x-1"
                }`}
              />
            </button>
            <span className={billingInterval === "yearly" ? "text-white" : "text-zinc-500"}>
              Yearly
              <span className="ml-2 text-xs text-green-400 font-medium">Save 17%</span>
            </span>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {(Object.entries(PRICING_TIERS) as [string, typeof PRICING_TIERS.free][]).map(
            ([key, tier]) => {
              const price = billingInterval === "monthly" ? tier.monthlyPrice : tier.yearlyPrice;
              const isPopular = key === "pro";
              const isFree = key === "free";

              return (
                <div
                  key={key}
                  className={`relative bg-zinc-900 border rounded-xl p-6 flex flex-col ${
                    isPopular ? "border-violet-500 ring-1 ring-violet-500" : "border-zinc-800"
                  }`}
                >
                  {isPopular && (
                    <div className="absolute -top-3 left-1/2 -translate-x-1/2 bg-violet-500 text-white text-xs font-medium px-3 py-1 rounded-full">
                      Most Popular
                    </div>
                  )}

                  <h3 className="text-xl font-bold mb-2">{tier.name}</h3>
                  <p className="text-zinc-400 text-sm mb-4">{tier.description}</p>

                  <div className="mb-6">
                    <span className="text-4xl font-bold">${price}</span>
                    {!isFree && (
                      <span className="text-zinc-500">
                        /{billingInterval === "monthly" ? "mo" : "yr"}
                      </span>
                    )}
                  </div>

                  <ul className="space-y-3 mb-6 grow">
                    {tier.features.map((feature, i) => (
                      <li key={i} className="flex items-start gap-2 text-sm">
                        <svg
                          className="w-5 h-5 text-green-400 shrink-0 mt-0.5"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                        <span className="text-zinc-300">{feature}</span>
                      </li>
                    ))}
                  </ul>

                  <button
                    onClick={() => handleSubscribe(key)}
                    disabled={loading === key}
                    className={`w-full py-3 px-4 rounded-lg font-medium transition-colors ${
                      isPopular
                        ? "bg-violet-500 hover:bg-violet-600 text-white"
                        : isFree
                        ? "bg-zinc-800 hover:bg-zinc-700 text-white"
                        : "bg-zinc-800 hover:bg-zinc-700 text-white"
                    } disabled:opacity-50 disabled:cursor-not-allowed`}
                  >
                    {loading === key ? (
                      <span className="flex items-center justify-center gap-2">
                        <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                          <circle
                            className="opacity-25"
                            cx="12"
                            cy="12"
                            r="10"
                            stroke="currentColor"
                            strokeWidth="4"
                            fill="none"
                          />
                          <path
                            className="opacity-75"
                            fill="currentColor"
                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                          />
                        </svg>
                        Processing...
                      </span>
                    ) : isFree ? (
                      "Get Started"
                    ) : (
                      "Subscribe"
                    )}
                  </button>
                </div>
              );
            }
          )}
        </div>

        {/* FAQ Section */}
        <div className="mt-16">
          <h2 className="text-2xl font-bold text-center mb-8">Frequently Asked Questions</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl mx-auto">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
              <h3 className="font-semibold mb-2">Can I change plans later?</h3>
              <p className="text-zinc-400 text-sm">
                Yes! You can upgrade or downgrade your plan at any time. Changes take effect immediately.
              </p>
            </div>
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
              <h3 className="font-semibold mb-2">What happens if I exceed my limits?</h3>
              <p className="text-zinc-400 text-sm">
                You&apos;ll receive a notification when you&apos;re close to your limits. You can upgrade or wait for the next billing cycle.
              </p>
            </div>
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
              <h3 className="font-semibold mb-2">Is there a free trial?</h3>
              <p className="text-zinc-400 text-sm">
                The Free tier is always available. Pro and Team plans include a 14-day free trial.
              </p>
            </div>
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6">
              <h3 className="font-semibold mb-2">How do I cancel?</h3>
              <p className="text-zinc-400 text-sm">
                You can cancel anytime from your dashboard. You&apos;ll keep access until the end of your billing period.
              </p>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/search/page.tsx">
import { PluginGrid } from "@/components/plugin-grid";
import Link from "next/link";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";

async function searchPlugins(query: string) {
  const res = await fetch(
    `${API_URL}/api/search?q=${encodeURIComponent(query)}`,
    { cache: "no-store" }
  );
  if (!res.ok) return { plugins: [], total: 0, query };
  return res.json();
}

export default async function SearchPage({
  searchParams,
}: {
  searchParams: Promise<{ q?: string }>;
}) {
  const { q = "" } = await searchParams;
  const data = await searchPlugins(q);

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <header className="border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm sticky top-0 z-10">
        <div className="max-w-6xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <Link href="/" className="flex items-center gap-3">
              <div className="w-8 h-8 bg-gradient-to-br from-violet-500 to-fuchsia-500 rounded-lg" />
              <h1 className="text-xl font-semibold">Launcher Plugins</h1>
            </Link>
          </div>
        </div>
      </header>

      <main className="max-w-6xl mx-auto px-6 py-8">
        <div className="mb-8">
          <Link
            href="/"
            className="text-sm text-zinc-500 hover:text-white transition-colors mb-2 inline-block"
          >
            â† Back to all plugins
          </Link>
          <h2 className="text-2xl font-bold">
            Search results for &quot;{q}&quot;
          </h2>
          <p className="text-zinc-400 mt-1">
            {data.total} {data.total === 1 ? "plugin" : "plugins"} found
          </p>
        </div>

        {data.plugins.length > 0 ? (
          <PluginGrid plugins={data.plugins} />
        ) : (
          <div className="text-center py-16">
            <p className="text-zinc-500 text-lg">No plugins found</p>
            <p className="text-zinc-600 mt-2">
              Try a different search term
            </p>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="apps/web/src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="apps/web/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/components/auth-provider";
import { Suspense } from "react";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Launcher - Plugin Marketplace",
  description: "Discover and install plugins to extend your launcher",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Suspense>
          <AuthProvider>{children}</AuthProvider>
        </Suspense>
      </body>
    </html>
  );
}
</file>

<file path="apps/web/src/app/page.tsx">
import { PluginGrid } from "@/components/plugin-grid";
import { SearchBar } from "@/components/search-bar";
import { CategoryFilter } from "@/components/category-filter";
import { Header } from "@/components/header";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";

async function getPlugins() {
  const res = await fetch(`${API_URL}/api/plugins`, {
    cache: "no-store",
  });
  if (!res.ok) return { plugins: [], total: 0 };
  return res.json();
}

async function getCategories() {
  const res = await fetch(`${API_URL}/api/categories`, {
    cache: "no-store",
  });
  if (!res.ok) return { categories: [] };
  return res.json();
}

export default async function Home() {
  const [pluginsData, categoriesData] = await Promise.all([
    getPlugins(),
    getCategories(),
  ]);

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      <Header />

      <main className="max-w-6xl mx-auto px-6 py-8">
        <div className="mb-8">
          <h2 className="text-3xl font-bold mb-2">Plugin Marketplace</h2>
          <p className="text-zinc-400">
            Discover and install plugins to extend your launcher
          </p>
        </div>

        <div className="flex flex-col md:flex-row gap-4 mb-8">
          <SearchBar />
          <CategoryFilter categories={categoriesData.categories} />
        </div>

        <div className="mb-4 text-sm text-zinc-500">
          {pluginsData.total} plugins available
        </div>

        <PluginGrid plugins={pluginsData.plugins} />
      </main>

      <footer className="border-t border-zinc-800 mt-16">
        <div className="max-w-6xl mx-auto px-6 py-8 text-center text-zinc-500 text-sm">
          <p>Launcher Plugin Marketplace</p>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="apps/web/src/components/auth-provider.tsx">
"use client";

import { StackProvider, StackTheme } from "@stackframe/stack";
import { stackClientApp } from "@/stack-client";

export function AuthProvider({ children }: { children: React.ReactNode }) {
  return (
    <StackProvider app={stackClientApp}>
      <StackTheme>
        {children}
      </StackTheme>
    </StackProvider>
  );
}
</file>

<file path="apps/web/src/components/category-filter.tsx">
"use client";

import { useRouter, useSearchParams } from "next/navigation";

export function CategoryFilter({ categories }: { categories: string[] }) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const selectedCategory = searchParams.get("category");

  const handleCategoryClick = (category: string | null) => {
    if (category) {
      router.push(`/?category=${encodeURIComponent(category)}`);
    } else {
      router.push("/");
    }
  };

  return (
    <div className="flex gap-2 flex-wrap">
      <button
        onClick={() => handleCategoryClick(null)}
        className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
          !selectedCategory
            ? "bg-violet-500/20 text-violet-400 border border-violet-500/30"
            : "bg-zinc-800 text-zinc-400 border border-zinc-700 hover:bg-zinc-700"
        }`}
      >
        All
      </button>
      {categories.map((cat) => (
        <button
          key={cat}
          onClick={() => handleCategoryClick(cat)}
          className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
            selectedCategory === cat
              ? "bg-violet-500/20 text-violet-400 border border-violet-500/30"
              : "bg-zinc-800 text-zinc-400 border border-zinc-700 hover:bg-zinc-700"
          }`}
        >
          {cat}
        </button>
      ))}
    </div>
  );
}
</file>

<file path="apps/web/src/components/header.tsx">
"use client";

import Link from "next/link";
import { UserButton, useUser } from "@stackframe/stack";

export function Header() {
  const user = useUser();

  return (
    <header className="border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm sticky top-0 z-10">
      <div className="max-w-6xl mx-auto px-6 py-4">
        <div className="flex items-center justify-between">
          <Link href="/" className="flex items-center gap-3">
            <div className="w-8 h-8 bg-gradient-to-br from-violet-500 to-fuchsia-500 rounded-lg" />
            <h1 className="text-xl font-semibold">Launcher</h1>
          </Link>

          <nav className="flex items-center gap-6">
            <Link
              href="/"
              className="text-sm text-zinc-400 hover:text-white transition-colors hidden sm:block"
            >
              Plugins
            </Link>
            {user ? (
              <>
                <Link
                  href="/dashboard"
                  className="text-sm text-zinc-400 hover:text-white transition-colors"
                >
                  Dashboard
                </Link>
                <UserButton />
              </>
            ) : (
              <Link
                href="/handler/sign-in"
                className="text-sm bg-violet-600 hover:bg-violet-500 px-4 py-2 rounded-lg transition-colors"
              >
                Sign In
              </Link>
            )}
          </nav>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="apps/web/src/components/plugin-grid.tsx">
"use client";

import Link from "next/link";

interface RegistryPlugin {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  homepage: string | null;
  categories: string[];
  downloads: number;
  rating: number | null;
}

export function PluginGrid({ plugins }: { plugins: RegistryPlugin[] }) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {plugins.map((plugin) => (
        <PluginCard key={plugin.id} plugin={plugin} />
      ))}
    </div>
  );
}

function PluginCard({ plugin }: { plugin: RegistryPlugin }) {
  const categoryColors: Record<string, string> = {
    Productivity: "bg-blue-500/20 text-blue-400",
    Security: "bg-red-500/20 text-red-400",
    Development: "bg-green-500/20 text-green-400",
    Media: "bg-purple-500/20 text-purple-400",
    Utilities: "bg-yellow-500/20 text-yellow-400",
    Tasks: "bg-orange-500/20 text-orange-400",
    DevOps: "bg-cyan-500/20 text-cyan-400",
    Examples: "bg-zinc-500/20 text-zinc-400",
  };

  return (
    <Link
      href={`/plugins/${plugin.id}`}
      className="bg-zinc-900 border border-zinc-800 rounded-xl p-5 hover:border-zinc-700 transition-colors group block"
    >
      <div className="flex items-start justify-between mb-3">
        <div>
          <h3 className="font-semibold text-lg group-hover:text-violet-400 transition-colors">
            {plugin.name}
          </h3>
          <p className="text-xs text-zinc-500">v{plugin.version}</p>
        </div>
        {plugin.rating && (
          <div className="flex items-center gap-1 text-yellow-500 text-sm">
            <span>â˜…</span>
            <span>{plugin.rating.toFixed(1)}</span>
          </div>
        )}
      </div>

      <p className="text-sm text-zinc-400 mb-4 line-clamp-2">
        {plugin.description || "No description"}
      </p>

      <div className="flex flex-wrap gap-1.5 mb-4">
        {plugin.categories.slice(0, 3).map((cat) => (
          <span
            key={cat}
            className={`text-xs px-2 py-0.5 rounded-full ${
              categoryColors[cat] || "bg-zinc-700/50 text-zinc-400"
            }`}
          >
            {cat}
          </span>
        ))}
      </div>

      <div className="flex items-center justify-between text-xs text-zinc-500">
        <span>{plugin.author || "Unknown"}</span>
        <span>{plugin.downloads.toLocaleString()} downloads</span>
      </div>
    </Link>
  );
}
</file>

<file path="apps/web/src/components/search-bar.tsx">
"use client";

import { useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";

export function SearchBar() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get("q") || "");

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      router.push(`/search?q=${encodeURIComponent(query)}`);
    } else {
      router.push("/");
    }
  };

  return (
    <form onSubmit={handleSearch} className="flex-1">
      <div className="relative">
        <svg
          className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-zinc-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
          />
        </svg>
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search plugins..."
          className="w-full pl-10 pr-4 py-2.5 bg-zinc-900 border border-zinc-800 rounded-lg text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-violet-500/50 focus:border-violet-500"
        />
      </div>
    </form>
  );
}
</file>

<file path="apps/web/src/lib/auth/client.ts">
"use client";

import { useUser, useStackApp } from "@stackframe/stack";

export { useUser, useStackApp };
</file>

<file path="apps/web/src/lib/db/index.ts">

</file>

<file path="apps/web/src/lib/db/schema.ts">

</file>

<file path="apps/web/src/lib/desktop-auth.ts">
import { randomBytes, createHash } from "crypto";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { tmpdir } from "os";
import { join } from "path";

// File-based token store for development (Next.js uses multiple processes)
// In production, use Redis with TTL
const TOKEN_FILE = join(tmpdir(), "launcher-pending-tokens.json");
const REFRESH_TOKEN_FILE = join(tmpdir(), "launcher-refresh-tokens.json");

interface PendingToken {
  userId: string;
  email: string | null;
  name: string | null;
  avatar: string | null;
  expiresAt: number;
}

interface RefreshTokenData {
  userId: string;
  email: string | null;
  name: string | null;
  avatar: string | null;
  expiresAt: number;
}

function loadPendingTokens(): Map<string, PendingToken> {
  try {
    if (existsSync(TOKEN_FILE)) {
      const data = JSON.parse(readFileSync(TOKEN_FILE, "utf-8"));
      return new Map(Object.entries(data));
    }
  } catch (e) {
    console.error("[desktop-auth] Failed to load pending tokens:", e);
  }
  return new Map();
}

function savePendingTokens(tokens: Map<string, PendingToken>): void {
  try {
    writeFileSync(TOKEN_FILE, JSON.stringify(Object.fromEntries(tokens)));
  } catch (e) {
    console.error("[desktop-auth] Failed to save pending tokens:", e);
  }
}

function loadRefreshTokens(): Map<string, RefreshTokenData> {
  try {
    if (existsSync(REFRESH_TOKEN_FILE)) {
      const data = JSON.parse(readFileSync(REFRESH_TOKEN_FILE, "utf-8"));
      return new Map(Object.entries(data));
    }
  } catch (e) {
    console.error("[desktop-auth] Failed to load refresh tokens:", e);
  }
  return new Map();
}

function saveRefreshTokens(tokens: Map<string, RefreshTokenData>): void {
  try {
    writeFileSync(REFRESH_TOKEN_FILE, JSON.stringify(Object.fromEntries(tokens)));
  } catch (e) {
    console.error("[desktop-auth] Failed to save refresh tokens:", e);
  }
}

// Use getter functions to always load fresh from file
function getPendingTokens(): Map<string, PendingToken> {
  return loadPendingTokens();
}

function getRefreshTokens(): Map<string, RefreshTokenData> {
  return loadRefreshTokens();
}

// Legacy exports for compatibility (not used directly anymore)
export const pendingTokens = new Map<string, PendingToken>();
export const refreshTokens = new Map<string, RefreshTokenData>();

export function generatePendingToken(user: {
  id: string;
  email: string | null;
  name: string | null;
  avatar: string | null;
}): string {
  const token = randomBytes(32).toString("base64url");
  const expiresAt = Date.now() + 5 * 60 * 1000; // 5 minutes

  const tokens = getPendingTokens();
  tokens.set(token, {
    userId: user.id,
    email: user.email,
    name: user.name,
    avatar: user.avatar,
    expiresAt,
  });
  savePendingTokens(tokens);

  console.log(`[desktop-auth] Generated token for user ${user.id}, pending tokens count: ${tokens.size}`);

  // Clean up expired tokens
  cleanupExpiredTokens();

  return token;
}

export function validateAndConsumePendingToken(token: string): PendingToken | null {
  const tokens = getPendingTokens();
  console.log(`[desktop-auth] Validating token, pending tokens count: ${tokens.size}`);
  const pending = tokens.get(token);

  if (!pending) {
    console.log(`[desktop-auth] Token not found in pending tokens`);
    return null;
  }

  if (pending.expiresAt < Date.now()) {
    tokens.delete(token);
    savePendingTokens(tokens);
    return null;
  }

  // One-time use - delete after validation
  tokens.delete(token);
  savePendingTokens(tokens);
  return pending;
}

export function generateTokenPair(user: {
  userId: string;
  email: string | null;
  name: string | null;
  avatar: string | null;
}): { accessToken: string; refreshToken: string; expiresAt: number } {
  const accessToken = `lnch_${randomBytes(32).toString("base64url")}`;
  const refreshToken = randomBytes(48).toString("base64url");

  // Access token expires in 1 hour
  const expiresAt = Math.floor(Date.now() / 1000) + 3600;

  // Refresh token expires in 30 days
  const refreshExpiresAt = Date.now() + 30 * 24 * 60 * 60 * 1000;

  // Store refresh token hash
  const tokens = getRefreshTokens();
  const refreshHash = createHash("sha256").update(refreshToken).digest("hex");
  tokens.set(refreshHash, {
    userId: user.userId,
    email: user.email,
    name: user.name,
    avatar: user.avatar,
    expiresAt: refreshExpiresAt,
  });
  saveRefreshTokens(tokens);

  return { accessToken, refreshToken, expiresAt };
}

export function validateRefreshToken(token: string): RefreshTokenData | null {
  const tokens = getRefreshTokens();
  const hash = createHash("sha256").update(token).digest("hex");
  const data = tokens.get(hash);

  if (!data) {
    return null;
  }

  if (data.expiresAt < Date.now()) {
    tokens.delete(hash);
    saveRefreshTokens(tokens);
    return null;
  }

  return data;
}

export function revokeRefreshToken(token: string): void {
  const tokens = getRefreshTokens();
  const hash = createHash("sha256").update(token).digest("hex");
  tokens.delete(hash);
  saveRefreshTokens(tokens);
}

function cleanupExpiredTokens(): void {
  const now = Date.now();

  const pending = getPendingTokens();
  let pendingChanged = false;
  for (const [key, value] of pending.entries()) {
    if (value.expiresAt < now) {
      pending.delete(key);
      pendingChanged = true;
    }
  }
  if (pendingChanged) savePendingTokens(pending);

  const refresh = getRefreshTokens();
  let refreshChanged = false;
  for (const [key, value] of refresh.entries()) {
    if (value.expiresAt < now) {
      refresh.delete(key);
      refreshChanged = true;
    }
  }
  if (refreshChanged) saveRefreshTokens(refresh);
}
</file>

<file path="apps/web/src/lib/stripe.ts">
"use server";
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY is not set");
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-12-15.clover",
  typescript: true,
});

// Price IDs - these should be created in Stripe Dashboard
// For development, we use placeholder IDs that will be replaced with real ones
export const STRIPE_PRICE_IDS = {
  pro_monthly: process.env.STRIPE_PRO_MONTHLY_PRICE_ID || "price_pro_monthly",
  pro_yearly: process.env.STRIPE_PRO_YEARLY_PRICE_ID || "price_pro_yearly",
  team_monthly: process.env.STRIPE_TEAM_MONTHLY_PRICE_ID || "price_team_monthly",
  team_yearly: process.env.STRIPE_TEAM_YEARLY_PRICE_ID || "price_team_yearly",
  enterprise_monthly: process.env.STRIPE_ENTERPRISE_MONTHLY_PRICE_ID || "price_enterprise_monthly",
  enterprise_yearly: process.env.STRIPE_ENTERPRISE_YEARLY_PRICE_ID || "price_enterprise_yearly",
} as const;

// Pricing configuration
export const PRICING_TIERS = {
  free: {
    name: "Free",
    description: "Perfect for trying out Launcher",
    monthlyPrice: 0,
    yearlyPrice: 0,
    features: [
      "50 AI queries/month",
      "5 plugins max",
      "Basic search",
      "Calculator & Apps",
      "Community support",
    ],
    limits: {
      aiQueriesPerMonth: 50,
      aiEmbeddingsPerMonth: 100,
      maxPlugins: 5,
    },
  },
  pro: {
    name: "Pro",
    description: "For power users who need more",
    monthlyPrice: 9,
    yearlyPrice: 90,
    priceId: {
      monthly: STRIPE_PRICE_IDS.pro_monthly,
      yearly: STRIPE_PRICE_IDS.pro_yearly,
    },
    features: [
      "1,000 AI queries/month",
      "50 plugins max",
      "AI-powered search",
      "AI commands",
      "Cloud sync",
      "Priority support",
    ],
    limits: {
      aiQueriesPerMonth: 1000,
      aiEmbeddingsPerMonth: 5000,
      maxPlugins: 50,
    },
  },
  team: {
    name: "Team",
    description: "For teams that work together",
    monthlyPrice: 29,
    yearlyPrice: 290,
    priceId: {
      monthly: STRIPE_PRICE_IDS.team_monthly,
      yearly: STRIPE_PRICE_IDS.team_yearly,
    },
    features: [
      "5,000 AI queries/month",
      "Unlimited plugins",
      "Everything in Pro",
      "Team sharing",
      "Admin dashboard",
      "Priority support",
    ],
    limits: {
      aiQueriesPerMonth: 5000,
      aiEmbeddingsPerMonth: 25000,
      maxPlugins: -1,
    },
  },
  enterprise: {
    name: "Enterprise",
    description: "For large organizations",
    monthlyPrice: 99,
    yearlyPrice: 990,
    priceId: {
      monthly: STRIPE_PRICE_IDS.enterprise_monthly,
      yearly: STRIPE_PRICE_IDS.enterprise_yearly,
    },
    features: [
      "Unlimited AI queries",
      "Unlimited plugins",
      "Everything in Team",
      "SSO/SAML",
      "Custom integrations",
      "Dedicated support",
      "SLA guarantee",
    ],
    limits: {
      aiQueriesPerMonth: -1,
      aiEmbeddingsPerMonth: -1,
      maxPlugins: -1,
    },
  },
} as const;

export type PricingTier = keyof typeof PRICING_TIERS;
export type BillingInterval = "monthly" | "yearly";
</file>

<file path="apps/web/src/lib/usage.ts">
import { createDb, usageRecords, usageAggregates, sql } from "@launcher/db";

const db = createDb(process.env.DATABASE_URL!);

export type UsageType = "ai_query" | "ai_embedding" | "plugin_install" | "search";

export async function trackUsage(
  userId: string,
  type: UsageType,
  count: number = 1,
  metadata?: Record<string, unknown>
) {
  // Insert usage record
  await db.insert(usageRecords).values({
    userId,
    type,
    count,
    metadata: metadata || null,
  });

  // Update monthly aggregate
  const month = new Date().toISOString().slice(0, 7); // YYYY-MM format
  
  const columnMap: Record<UsageType, string> = {
    ai_query: "ai_queries",
    ai_embedding: "ai_embeddings",
    plugin_install: "plugin_installs",
    search: "searches",
  };

  const column = columnMap[type];

  // Upsert the aggregate
  await db
    .insert(usageAggregates)
    .values({
      userId,
      month,
      aiQueries: type === "ai_query" ? count : 0,
      aiEmbeddings: type === "ai_embedding" ? count : 0,
      pluginInstalls: type === "plugin_install" ? count : 0,
      searches: type === "search" ? count : 0,
    })
    .onConflictDoUpdate({
      target: [usageAggregates.userId, usageAggregates.month],
      set: {
        [column]: sql`${usageAggregates[column as keyof typeof usageAggregates]} + ${count}`,
        updatedAt: new Date(),
      },
    });
}

export async function getMonthlyUsage(userId: string) {
  const month = new Date().toISOString().slice(0, 7);
  
  const aggregate = await db.query.usageAggregates.findFirst({
    where: (agg, { eq, and }) => and(eq(agg.userId, userId), eq(agg.month, month)),
  });

  return {
    aiQueries: aggregate?.aiQueries || 0,
    aiEmbeddings: aggregate?.aiEmbeddings || 0,
    pluginInstalls: aggregate?.pluginInstalls || 0,
    searches: aggregate?.searches || 0,
    month,
  };
}

export async function checkUsageLimit(
  userId: string,
  type: UsageType,
  tierLimits: { aiQueriesPerMonth: number; aiEmbeddingsPerMonth: number; maxPlugins: number }
) {
  const usage = await getMonthlyUsage(userId);

  switch (type) {
    case "ai_query":
      if (tierLimits.aiQueriesPerMonth === -1) return { allowed: true, remaining: -1 };
      return {
        allowed: usage.aiQueries < tierLimits.aiQueriesPerMonth,
        remaining: Math.max(0, tierLimits.aiQueriesPerMonth - usage.aiQueries),
      };
    case "ai_embedding":
      if (tierLimits.aiEmbeddingsPerMonth === -1) return { allowed: true, remaining: -1 };
      return {
        allowed: usage.aiEmbeddings < tierLimits.aiEmbeddingsPerMonth,
        remaining: Math.max(0, tierLimits.aiEmbeddingsPerMonth - usage.aiEmbeddings),
      };
    default:
      return { allowed: true, remaining: -1 };
  }
}
</file>

<file path="apps/web/src/stack-client.ts">
"use client";
import { StackClientApp } from "@stackframe/stack";

export const stackClientApp = new StackClientApp({
  tokenStore: "nextjs-cookie",
  urls: {
    home: "/",
    signIn: "/handler/sign-in",
    signUp: "/handler/sign-up",
    afterSignIn: "/dashboard",
    afterSignUp: "/dashboard",
    afterSignOut: "/",
  },
});
</file>

<file path="apps/web/src/stack.ts">
import "server-only";
import { StackServerApp } from "@stackframe/stack";

export const stackServerApp = new StackServerApp({
  tokenStore: "nextjs-cookie",
  urls: {
    home: "/",
    signIn: "/handler/sign-in",
    signUp: "/handler/sign-up",
    afterSignIn: "/dashboard",
    afterSignUp: "/dashboard",
    afterSignOut: "/",
  },
});
</file>

<file path="apps/web/.env.example">
# Database (Neon Postgres)
DATABASE_URL=postgresql://neondb_owner:xxx@ep-xxx-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require

# Neon Auth (Stack Auth)
NEXT_PUBLIC_STACK_PROJECT_ID=your-project-id
NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY=pck_xxx
STACK_SECRET_SERVER_KEY=ssk_xxx

# Upstash Redis
UPSTASH_REDIS_REST_URL=https://your-redis.upstash.io
UPSTASH_REDIS_REST_TOKEN=your-redis-token

# Upstash Vector
UPSTASH_VECTOR_REST_URL=https://your-vector.upstash.io
UPSTASH_VECTOR_REST_TOKEN=your-vector-token

# Stripe (for subscriptions)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...

# App URLs
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3001
</file>

<file path="apps/web/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="apps/web/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="apps/web/package.json">
{
  "name": "@launcher/web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@launcher/cache": "workspace:*",
    "@launcher/db": "workspace:*",
    "@stackframe/stack": "^2",
    "next": "16.0.10",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "stripe": "^20.1.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.10",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="apps/web/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="apps/web/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="apps/web/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/cache/src/index.ts">
export * from "./redis";
export * from "./vector";
</file>

<file path="packages/cache/src/redis.ts">
import { Redis } from "@upstash/redis";

let redisClient: Redis | null = null;

export function createRedis(url: string, token: string): Redis {
  return new Redis({ url, token });
}

export function getRedis(): Redis {
  if (!redisClient) {
    redisClient = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    });
  }
  return redisClient;
}

// Rate limiting helper
export async function checkRateLimit(
  redis: Redis,
  key: string,
  limit: number,
  windowSeconds: number
): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {
  const now = Math.floor(Date.now() / 1000);
  const windowKey = `ratelimit:${key}:${Math.floor(now / windowSeconds)}`;

  const count = await redis.incr(windowKey);

  if (count === 1) {
    await redis.expire(windowKey, windowSeconds);
  }

  const resetAt = (Math.floor(now / windowSeconds) + 1) * windowSeconds;

  return {
    allowed: count <= limit,
    remaining: Math.max(0, limit - count),
    resetAt,
  };
}

// Cache helpers
export async function getCached<T>(redis: Redis, key: string): Promise<T | null> {
  return redis.get<T>(key);
}

export async function setCache<T>(
  redis: Redis,
  key: string,
  value: T,
  expirationSeconds?: number
): Promise<void> {
  if (expirationSeconds) {
    await redis.set(key, value, { ex: expirationSeconds });
  } else {
    await redis.set(key, value);
  }
}

export async function invalidateCache(redis: Redis, pattern: string): Promise<void> {
  const keys = await redis.keys(pattern);
  if (keys.length > 0) {
    await redis.del(...keys);
  }
}

export { Redis };
</file>

<file path="packages/cache/src/vector.ts">
import { Index } from "@upstash/vector";

let vectorIndex: Index | null = null;

export function createVectorIndex(url: string, token: string): Index {
  return new Index({ url, token });
}

export function getVectorIndex(): Index {
  if (!vectorIndex) {
    vectorIndex = new Index({
      url: process.env.UPSTASH_VECTOR_REST_URL!,
      token: process.env.UPSTASH_VECTOR_REST_TOKEN!,
    });
  }
  return vectorIndex;
}

export interface VectorDocument {
  id: string;
  text: string;
  metadata?: Record<string, unknown>;
}

// Upsert document for semantic search
export async function upsertVector(
  index: Index,
  doc: VectorDocument
): Promise<void> {
  await index.upsert({
    id: doc.id,
    data: doc.text,
    metadata: doc.metadata,
  });
}

// Semantic search
export async function searchVectors(
  index: Index,
  query: string,
  topK: number = 10
): Promise<Array<{ id: string; score: number; metadata?: Record<string, unknown> }>> {
  const results = await index.query({
    data: query,
    topK,
    includeMetadata: true,
  });

  return results.map((r) => ({
    id: r.id as string,
    score: r.score,
    metadata: r.metadata as Record<string, unknown> | undefined,
  }));
}

// Delete from vector index
export async function deleteVector(index: Index, id: string): Promise<void> {
  await index.delete(id);
}

export { Index };
</file>

<file path="packages/cache/package.json">
{
  "name": "@launcher/cache",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./redis": {
      "import": "./dist/redis.js",
      "types": "./dist/redis.d.ts"
    },
    "./vector": {
      "import": "./dist/vector.js",
      "types": "./dist/vector.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "@upstash/redis": "^1.35.8",
    "@upstash/vector": "^1.2.2"
  },
  "devDependencies": {
    "@types/node": "^20",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="packages/cache/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/db/src/index.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sql = void 0;
exports.createDb = createDb;
var serverless_1 = require("@neondatabase/serverless");
var neon_http_1 = require("drizzle-orm/neon-http");
var schema = require("./schema");
function createDb(databaseUrl) {
    var sql = (0, serverless_1.neon)(databaseUrl);
    return (0, neon_http_1.drizzle)(sql, { schema: schema });
}
__exportStar(require("./schema"), exports);
var drizzle_orm_1 = require("drizzle-orm");
Object.defineProperty(exports, "sql", { enumerable: true, get: function () { return drizzle_orm_1.sql; } });
</file>

<file path="packages/db/src/index.ts">
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import * as schema from "./schema";

export function createDb(databaseUrl: string) {
  const sql = neon(databaseUrl);
  return drizzle(sql, { schema });
}

export type Database = ReturnType<typeof createDb>;

export * from "./schema";
export { sql } from "drizzle-orm";
</file>

<file path="packages/db/src/schema.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TIER_LIMITS = exports.userPluginsRelations = exports.pluginsRelations = exports.subscriptionsRelations = exports.userProfilesRelations = exports.apiKeys = exports.pluginRatings = exports.userPlugins = exports.plugins = exports.usageAggregates = exports.usageRecords = exports.subscriptions = exports.userProfiles = exports.usageTypeEnum = exports.subscriptionStatusEnum = exports.subscriptionTierEnum = exports.neonAuthUsers = exports.neonAuthSchema = void 0;
var pg_core_1 = require("drizzle-orm/pg-core");
var drizzle_orm_1 = require("drizzle-orm");
// Neon Auth schema - users are managed by Neon Auth
exports.neonAuthSchema = (0, pg_core_1.pgSchema)("neon_auth");
// Reference to Neon Auth users table (read-only, managed by Neon Auth)
exports.neonAuthUsers = exports.neonAuthSchema.table("users_sync", {
    id: (0, pg_core_1.text)("id").primaryKey(),
    email: (0, pg_core_1.text)("email"),
    name: (0, pg_core_1.text)("name"),
    image: (0, pg_core_1.text)("image"),
    createdAt: (0, pg_core_1.timestamp)("created_at"),
    updatedAt: (0, pg_core_1.timestamp)("updated_at"),
    deletedAt: (0, pg_core_1.timestamp)("deleted_at"),
});
// Enums
exports.subscriptionTierEnum = (0, pg_core_1.pgEnum)("subscription_tier", [
    "free",
    "pro",
    "team",
    "enterprise",
]);
exports.subscriptionStatusEnum = (0, pg_core_1.pgEnum)("subscription_status", [
    "active",
    "canceled",
    "past_due",
    "trialing",
]);
exports.usageTypeEnum = (0, pg_core_1.pgEnum)("usage_type", [
    "ai_query",
    "ai_embedding",
    "plugin_install",
    "search",
]);
// User profiles - extends Neon Auth users with app-specific data
exports.userProfiles = (0, pg_core_1.pgTable)("user_profiles", {
    userId: (0, pg_core_1.text)("user_id").primaryKey(), // References neon_auth.users_sync.id
    settings: (0, pg_core_1.jsonb)("settings").$type().default({}),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
});
// Subscriptions table
exports.subscriptions = (0, pg_core_1.pgTable)("subscriptions", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    tier: (0, exports.subscriptionTierEnum)("tier").default("free").notNull(),
    status: (0, exports.subscriptionStatusEnum)("status").default("active").notNull(),
    stripeCustomerId: (0, pg_core_1.varchar)("stripe_customer_id", { length: 255 }),
    stripeSubscriptionId: (0, pg_core_1.varchar)("stripe_subscription_id", { length: 255 }),
    currentPeriodStart: (0, pg_core_1.timestamp)("current_period_start"),
    currentPeriodEnd: (0, pg_core_1.timestamp)("current_period_end"),
    cancelAtPeriodEnd: (0, pg_core_1.boolean)("cancel_at_period_end").default(false),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
});
// Usage tracking table
exports.usageRecords = (0, pg_core_1.pgTable)("usage_records", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    type: (0, exports.usageTypeEnum)("type").notNull(),
    count: (0, pg_core_1.integer)("count").default(1).notNull(),
    metadata: (0, pg_core_1.jsonb)("metadata").$type(),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
});
// Monthly usage aggregates for quick lookups
exports.usageAggregates = (0, pg_core_1.pgTable)("usage_aggregates", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    month: (0, pg_core_1.varchar)("month", { length: 7 }).notNull(), // YYYY-MM format
    aiQueries: (0, pg_core_1.integer)("ai_queries").default(0).notNull(),
    aiEmbeddings: (0, pg_core_1.integer)("ai_embeddings").default(0).notNull(),
    pluginInstalls: (0, pg_core_1.integer)("plugin_installs").default(0).notNull(),
    searches: (0, pg_core_1.integer)("searches").default(0).notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
});
// Plugins table (for marketplace)
exports.plugins = (0, pg_core_1.pgTable)("plugins", {
    id: (0, pg_core_1.varchar)("id", { length: 255 }).primaryKey(),
    name: (0, pg_core_1.varchar)("name", { length: 255 }).notNull(),
    version: (0, pg_core_1.varchar)("version", { length: 50 }).notNull(),
    authorId: (0, pg_core_1.text)("author_id"), // References neon_auth.users_sync.id
    authorName: (0, pg_core_1.varchar)("author_name", { length: 255 }),
    description: (0, pg_core_1.text)("description"),
    longDescription: (0, pg_core_1.text)("long_description"),
    homepage: (0, pg_core_1.text)("homepage"),
    repository: (0, pg_core_1.text)("repository"),
    downloadUrl: (0, pg_core_1.text)("download_url").notNull(),
    checksum: (0, pg_core_1.varchar)("checksum", { length: 128 }),
    permissions: (0, pg_core_1.jsonb)("permissions").$type().default([]),
    categories: (0, pg_core_1.jsonb)("categories").$type().default([]),
    downloads: (0, pg_core_1.integer)("downloads").default(0).notNull(),
    rating: (0, pg_core_1.decimal)("rating", { precision: 2, scale: 1 }),
    ratingCount: (0, pg_core_1.integer)("rating_count").default(0).notNull(),
    verified: (0, pg_core_1.boolean)("verified").default(false),
    featured: (0, pg_core_1.boolean)("featured").default(false),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
    publishedAt: (0, pg_core_1.timestamp)("published_at"),
});
// User installed plugins
exports.userPlugins = (0, pg_core_1.pgTable)("user_plugins", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    pluginId: (0, pg_core_1.varchar)("plugin_id", { length: 255 })
        .references(function () { return exports.plugins.id; }, { onDelete: "cascade" })
        .notNull(),
    installedVersion: (0, pg_core_1.varchar)("installed_version", { length: 50 }).notNull(),
    enabled: (0, pg_core_1.boolean)("enabled").default(true),
    settings: (0, pg_core_1.jsonb)("settings").$type().default({}),
    installedAt: (0, pg_core_1.timestamp)("installed_at").defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
});
// Plugin ratings/reviews
exports.pluginRatings = (0, pg_core_1.pgTable)("plugin_ratings", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    pluginId: (0, pg_core_1.varchar)("plugin_id", { length: 255 })
        .references(function () { return exports.plugins.id; }, { onDelete: "cascade" })
        .notNull(),
    rating: (0, pg_core_1.integer)("rating").notNull(), // 1-5
    review: (0, pg_core_1.text)("review"),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)("updated_at").defaultNow().notNull(),
});
// API keys for desktop app sync
exports.apiKeys = (0, pg_core_1.pgTable)("api_keys", {
    id: (0, pg_core_1.uuid)("id").primaryKey().defaultRandom(),
    userId: (0, pg_core_1.text)("user_id").notNull(), // References neon_auth.users_sync.id
    name: (0, pg_core_1.varchar)("name", { length: 255 }).notNull(),
    keyHash: (0, pg_core_1.varchar)("key_hash", { length: 255 }).notNull(),
    keyPrefix: (0, pg_core_1.varchar)("key_prefix", { length: 12 }).notNull(),
    lastUsedAt: (0, pg_core_1.timestamp)("last_used_at"),
    expiresAt: (0, pg_core_1.timestamp)("expires_at"),
    createdAt: (0, pg_core_1.timestamp)("created_at").defaultNow().notNull(),
});
// Relations - using userProfiles as the main user reference
exports.userProfilesRelations = (0, drizzle_orm_1.relations)(exports.userProfiles, function (_a) {
    var one = _a.one, many = _a.many;
    return ({
        subscription: one(exports.subscriptions, {
            fields: [exports.userProfiles.userId],
            references: [exports.subscriptions.userId],
        }),
        usageRecords: many(exports.usageRecords),
        usageAggregates: many(exports.usageAggregates),
        installedPlugins: many(exports.userPlugins),
        pluginRatings: many(exports.pluginRatings),
        apiKeys: many(exports.apiKeys),
        authoredPlugins: many(exports.plugins),
    });
});
exports.subscriptionsRelations = (0, drizzle_orm_1.relations)(exports.subscriptions, function (_a) {
    var one = _a.one;
    return ({
        userProfile: one(exports.userProfiles, {
            fields: [exports.subscriptions.userId],
            references: [exports.userProfiles.userId],
        }),
    });
});
exports.pluginsRelations = (0, drizzle_orm_1.relations)(exports.plugins, function (_a) {
    var one = _a.one, many = _a.many;
    return ({
        author: one(exports.userProfiles, {
            fields: [exports.plugins.authorId],
            references: [exports.userProfiles.userId],
        }),
        installedBy: many(exports.userPlugins),
        ratings: many(exports.pluginRatings),
    });
});
exports.userPluginsRelations = (0, drizzle_orm_1.relations)(exports.userPlugins, function (_a) {
    var one = _a.one;
    return ({
        userProfile: one(exports.userProfiles, {
            fields: [exports.userPlugins.userId],
            references: [exports.userProfiles.userId],
        }),
        plugin: one(exports.plugins, {
            fields: [exports.userPlugins.pluginId],
            references: [exports.plugins.id],
        }),
    });
});
// Subscription tier limits
exports.TIER_LIMITS = {
    free: {
        aiQueriesPerMonth: 50,
        aiEmbeddingsPerMonth: 100,
        maxPlugins: 5,
        features: ["basic_search", "calculator", "apps"],
    },
    pro: {
        aiQueriesPerMonth: 1000,
        aiEmbeddingsPerMonth: 5000,
        maxPlugins: 50,
        features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync"],
    },
    team: {
        aiQueriesPerMonth: 5000,
        aiEmbeddingsPerMonth: 25000,
        maxPlugins: -1,
        features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync", "team_sharing", "priority_support"],
    },
    enterprise: {
        aiQueriesPerMonth: -1,
        aiEmbeddingsPerMonth: -1,
        maxPlugins: -1,
        features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync", "team_sharing", "priority_support", "sso", "custom_integrations"],
    },
};
</file>

<file path="packages/db/src/schema.ts">
import {
  pgTable,
  pgSchema,
  text,
  timestamp,
  boolean,
  integer,
  jsonb,
  uuid,
  varchar,
  decimal,
  pgEnum,
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// Neon Auth schema - users are managed by Neon Auth
export const neonAuthSchema = pgSchema("neon_auth");

// Reference to Neon Auth users table (read-only, managed by Neon Auth)
export const neonAuthUsers = neonAuthSchema.table("users_sync", {
  id: text("id").primaryKey(),
  email: text("email"),
  name: text("name"),
  image: text("image"),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
  deletedAt: timestamp("deleted_at"),
});

// Enums
export const subscriptionTierEnum = pgEnum("subscription_tier", [
  "free",
  "pro",
  "team",
  "enterprise",
]);

export const subscriptionStatusEnum = pgEnum("subscription_status", [
  "active",
  "canceled",
  "past_due",
  "trialing",
]);

export const usageTypeEnum = pgEnum("usage_type", [
  "ai_query",
  "ai_embedding",
  "plugin_install",
  "search",
]);

// User profiles - extends Neon Auth users with app-specific data
export const userProfiles = pgTable("user_profiles", {
  userId: text("user_id").primaryKey(), // References neon_auth.users_sync.id
  settings: jsonb("settings").$type<UserSettings>().default({}),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export interface UserSettings {
  theme?: "light" | "dark" | "system";
  notifications?: boolean;
  newsletter?: boolean;
  defaultSearchProvider?: string;
}

// Subscriptions table
export const subscriptions = pgTable("subscriptions", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  tier: subscriptionTierEnum("tier").default("free").notNull(),
  status: subscriptionStatusEnum("status").default("active").notNull(),
  stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
  stripeSubscriptionId: varchar("stripe_subscription_id", { length: 255 }),
  currentPeriodStart: timestamp("current_period_start"),
  currentPeriodEnd: timestamp("current_period_end"),
  cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Usage tracking table
export const usageRecords = pgTable("usage_records", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  type: usageTypeEnum("type").notNull(),
  count: integer("count").default(1).notNull(),
  metadata: jsonb("metadata").$type<Record<string, unknown>>(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Monthly usage aggregates for quick lookups
export const usageAggregates = pgTable("usage_aggregates", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  month: varchar("month", { length: 7 }).notNull(), // YYYY-MM format
  aiQueries: integer("ai_queries").default(0).notNull(),
  aiEmbeddings: integer("ai_embeddings").default(0).notNull(),
  pluginInstalls: integer("plugin_installs").default(0).notNull(),
  searches: integer("searches").default(0).notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Plugins table (for marketplace)
export const plugins = pgTable("plugins", {
  id: varchar("id", { length: 255 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  version: varchar("version", { length: 50 }).notNull(),
  authorId: text("author_id"), // References neon_auth.users_sync.id
  authorName: varchar("author_name", { length: 255 }),
  description: text("description"),
  longDescription: text("long_description"),
  homepage: text("homepage"),
  repository: text("repository"),
  downloadUrl: text("download_url").notNull(),
  checksum: varchar("checksum", { length: 128 }),
  permissions: jsonb("permissions").$type<string[]>().default([]),
  categories: jsonb("categories").$type<string[]>().default([]),
  downloads: integer("downloads").default(0).notNull(),
  rating: decimal("rating", { precision: 2, scale: 1 }),
  ratingCount: integer("rating_count").default(0).notNull(),
  verified: boolean("verified").default(false),
  featured: boolean("featured").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  publishedAt: timestamp("published_at"),
});

// User installed plugins
export const userPlugins = pgTable("user_plugins", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  pluginId: varchar("plugin_id", { length: 255 })
    .references(() => plugins.id, { onDelete: "cascade" })
    .notNull(),
  installedVersion: varchar("installed_version", { length: 50 }).notNull(),
  enabled: boolean("enabled").default(true),
  settings: jsonb("settings").$type<Record<string, unknown>>().default({}),
  installedAt: timestamp("installed_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Plugin ratings/reviews
export const pluginRatings = pgTable("plugin_ratings", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  pluginId: varchar("plugin_id", { length: 255 })
    .references(() => plugins.id, { onDelete: "cascade" })
    .notNull(),
  rating: integer("rating").notNull(), // 1-5
  review: text("review"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// API keys for desktop app sync
export const apiKeys = pgTable("api_keys", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(), // References neon_auth.users_sync.id
  name: varchar("name", { length: 255 }).notNull(),
  keyHash: varchar("key_hash", { length: 255 }).notNull(),
  keyPrefix: varchar("key_prefix", { length: 12 }).notNull(),
  lastUsedAt: timestamp("last_used_at"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Relations - using userProfiles as the main user reference
export const userProfilesRelations = relations(userProfiles, ({ one, many }) => ({
  subscription: one(subscriptions, {
    fields: [userProfiles.userId],
    references: [subscriptions.userId],
  }),
  usageRecords: many(usageRecords),
  usageAggregates: many(usageAggregates),
  installedPlugins: many(userPlugins),
  pluginRatings: many(pluginRatings),
  apiKeys: many(apiKeys),
  authoredPlugins: many(plugins),
}));

export const subscriptionsRelations = relations(subscriptions, ({ one }) => ({
  userProfile: one(userProfiles, {
    fields: [subscriptions.userId],
    references: [userProfiles.userId],
  }),
}));

export const pluginsRelations = relations(plugins, ({ one, many }) => ({
  author: one(userProfiles, {
    fields: [plugins.authorId],
    references: [userProfiles.userId],
  }),
  installedBy: many(userPlugins),
  ratings: many(pluginRatings),
}));

export const userPluginsRelations = relations(userPlugins, ({ one }) => ({
  userProfile: one(userProfiles, {
    fields: [userPlugins.userId],
    references: [userProfiles.userId],
  }),
  plugin: one(plugins, {
    fields: [userPlugins.pluginId],
    references: [plugins.id],
  }),
}));

// Subscription tier limits
export const TIER_LIMITS = {
  free: {
    aiQueriesPerMonth: 50,
    aiEmbeddingsPerMonth: 100,
    maxPlugins: 5,
    features: ["basic_search", "calculator", "apps"],
  },
  pro: {
    aiQueriesPerMonth: 1000,
    aiEmbeddingsPerMonth: 5000,
    maxPlugins: 50,
    features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync"],
  },
  team: {
    aiQueriesPerMonth: 5000,
    aiEmbeddingsPerMonth: 25000,
    maxPlugins: -1,
    features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync", "team_sharing", "priority_support"],
  },
  enterprise: {
    aiQueriesPerMonth: -1,
    aiEmbeddingsPerMonth: -1,
    maxPlugins: -1,
    features: ["basic_search", "calculator", "apps", "ai_search", "ai_commands", "cloud_sync", "team_sharing", "priority_support", "sso", "custom_integrations"],
  },
} as const;

export type SubscriptionTier = keyof typeof TIER_LIMITS;
</file>

<file path="packages/db/.env.example">
# Database (Neon Postgres)
DATABASE_URL=postgresql://username:password@host:port/database
</file>

<file path="packages/db/drizzle.config.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var drizzle_kit_1 = require("drizzle-kit");
exports.default = (0, drizzle_kit_1.defineConfig)({
    schema: "./src/schema.ts",
    out: "./drizzle",
    dialect: "postgresql",
    dbCredentials: {
        url: process.env.DATABASE_URL,
    },
});
</file>

<file path="packages/db/drizzle.config.ts">
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
</file>

<file path="packages/db/package.json">
{
  "name": "@launcher/db",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./schema": {
      "import": "./dist/schema.js",
      "types": "./dist/schema.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "drizzle-orm": "^0.45.1",
    "@neondatabase/serverless": "^1.0.2"
  },
  "devDependencies": {
    "@types/node": "^25.0.3",
    "drizzle-kit": "^0.31.8",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="packages/db/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/shared/src/index.ts">
// Plugin types
export interface RegistryPlugin {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  homepage: string | null;
  repository: string | null;
  download_url: string;
  checksum: string | null;
  permissions: string[];
  categories: string[];
  downloads: number;
  rating: number | null;
}

export interface PluginUpdate {
  id: string;
  name: string;
  current_version: string;
  latest_version: string;
}

export interface PluginManifest {
  id: string;
  name: string;
  version: string;
  author: string | null;
  description: string | null;
  permissions: string[];
  entry: string;
  enabled: boolean;
}

// OAuth types
export interface OAuthProviderInfo {
  id: string;
  name: string;
  connected: boolean;
  scopes: string[];
}

export interface OAuthCredentials {
  client_id: string | null;
  client_secret: string | null;
}

// Index config types
export interface IndexConfig {
  index_paths: string[];
  exclude_patterns: string[];
  exclude_hidden: boolean;
  max_file_size_mb: number;
  index_content: boolean;
  content_extensions: string[];
}

// Search result types
export interface SearchResult {
  id: string;
  title: string;
  subtitle: string | null;
  icon: ResultIcon;
  category: ResultCategory;
  score: number;
}

export type ResultIcon =
  | { type: "Text"; value: string }
  | { type: "Path"; value: string }
  | { type: "Emoji"; value: string };

export type ResultCategory =
  | "Calculator"
  | "Application"
  | "File"
  | "Command"
  | "Plugin"
  | "GitHub";

// API response types
export interface PluginListResponse {
  plugins: RegistryPlugin[];
  total: number;
}

export interface PluginSearchResponse {
  plugins: RegistryPlugin[];
  total: number;
  query: string;
  category: string | null;
}

export interface CategoriesResponse {
  categories: string[];
}
</file>

<file path="packages/shared/package.json">
{
  "name": "@launcher/shared",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "devDependencies": {
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "@neondatabase/serverless": "^1.0.2",
    "drizzle-orm": "^0.45.1"
  }
}
</file>

<file path="packages/shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*"]
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Turborepo
.turbo

# Tauri
apps/launcher/src-tauri/target/
</file>

<file path="package.json">
{
  "name": "launcher-monorepo",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "lint": "turbo lint",
    "test": "turbo test",
    "typecheck": "turbo typecheck",
    "clean": "turbo clean && rm -rf node_modules",
    "dev:desktop": "turbo dev --filter=@launcher/desktop",
    "dev:web": "turbo dev --filter=@launcher/web",
    "dev:server": "turbo dev --filter=@launcher/server",
    "dev:services": "turbo dev --filter=@launcher/web --filter=@launcher/server",
    "build:desktop": "turbo build --filter=@launcher/desktop",
    "build:web": "turbo build --filter=@launcher/web",
    "build:server": "turbo build --filter=@launcher/server",
    "build:packages": "turbo build --filter=./packages/*",
    "db:push": "turbo db:push --filter=@launcher/db",
    "db:generate": "turbo db:generate --filter=@launcher/db",
    "db:migrate": "turbo db:migrate --filter=@launcher/db",
    "db:studio": "turbo db:studio --filter=@launcher/db",
    "tauri": "bun run --filter @launcher/desktop tauri",
    "tauri:dev": "bun run --filter @launcher/desktop tauri dev",
    "tauri:build": "bun run --filter @launcher/desktop tauri build"
  },
  "devDependencies": {
    "turbo": "^2.3.0"
  },
  "packageManager": "bun@1.1.0"
}
</file>

<file path="README.md">
# Launcher

A cross-platform launcher (Raycast alternative) with plugin marketplace.

## Tech Stack

- **Desktop App**: Tauri v2, React 19, TypeScript, Tailwind v4
- **Web Dashboard**: Next.js 16, React 19, Tailwind v4
- **API Server**: Hono, TypeScript
- **Database**: Neon Postgres (Drizzle ORM)
- **Auth**: Stack Auth (Neon Auth)
- **Payments**: Stripe
- **Cache**: Upstash Redis/Vector

## Project Structure

```
launcher/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ launcher/     # Desktop app (Tauri + React)
â”‚   â”œâ”€â”€ web/          # Web dashboard (Next.js)
â”‚   â””â”€â”€ server/       # Plugin registry API (Hono)
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ db/           # Drizzle ORM schema + Neon client
â”‚   â”œâ”€â”€ cache/        # Upstash Redis/Vector clients
â”‚   â””â”€â”€ shared/       # Shared TypeScript types
â”œâ”€â”€ package.json      # Workspace root (Bun)
â””â”€â”€ turbo.json        # Turborepo config
```

## Prerequisites

- [Bun](https://bun.sh) v1.0+
- [Rust](https://rustup.rs) (for Tauri)
- Node.js 18+ (for some tooling)

## Quick Start (Development)

```bash
# Install dependencies
bun install

# Start all services
bun run dev          # Runs all apps via Turborepo

# Or start individually:
cd apps/server && bun run dev    # API at http://localhost:3001
cd apps/web && bun run dev       # Web at http://localhost:3000
cd apps/launcher && bun tauri dev # Desktop app
```

## Environment Variables

### Web App (`apps/web/.env`)

```bash
# Database (Neon Postgres)
DATABASE_URL=postgresql://...

# Auth (Stack Auth / Neon Auth)
NEXT_PUBLIC_STACK_PROJECT_ID=your-project-id
NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY=pck_xxx
STACK_SECRET_SERVER_KEY=ssk_xxx

# Stripe
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_...

# App URLs
NEXT_PUBLIC_APP_URL=https://your-domain.com
NEXT_PUBLIC_API_URL=https://api.your-domain.com

# Optional: Upstash
UPSTASH_REDIS_REST_URL=https://...
UPSTASH_REDIS_REST_TOKEN=...
```

### Desktop App (`apps/launcher/.env`)

```bash
LAUNCHER_WEB_URL=https://your-domain.com
LAUNCHER_API_URL=https://api.your-domain.com
```

### Database (`packages/db/.env`)

```bash
DATABASE_URL=postgresql://...
```

## Database Setup

```bash
cd packages/db

# Push schema to database
bun run db:push

# Or generate migrations
bun run db:generate
bun run db:migrate

# Open Drizzle Studio
bun run db:studio
```

## Apps

### Desktop App (`apps/launcher`)

The main launcher application built with Tauri v2:

- **Global hotkey** (Alt+Space) to show/hide
- **File indexing** with Tantivy (~40k files)
- **Plugin system** (WASM via wasmtime)
- **OAuth integrations** (GitHub, Google, Notion, Slack)
- **Search providers** with prefixes (gh:, nt:, sl:, gd:, gc:)
- **Web authentication** via deep links (launcher://)

```bash
cd apps/launcher

# Development
bun tauri dev

# Build for production
bun tauri build
```

### Web Dashboard (`apps/web`)

Next.js 16 web application:

- **Plugin marketplace** - Browse, search, install plugins
- **User authentication** - Google/GitHub OAuth via Stack Auth
- **Subscription management** - Stripe integration (Free/Pro/Team/Enterprise)
- **Developer portal** - Submit and manage plugins
- **API key management** - Generate keys for desktop sync

```bash
cd apps/web

# Development
bun run dev

# Build
bun run build

# Production
bun run start
```

### API Server (`apps/server`)

Hono API server for plugin registry:

- `GET /api/plugins` - List all plugins
- `GET /api/plugins/:id` - Get plugin details
- `GET /api/categories` - List categories
- `GET /api/search?q=` - Search plugins

```bash
cd apps/server

# Development
bun run dev

# Production
bun run start
```

## Authentication Flow

The desktop app authenticates via the web dashboard:

1. User clicks "Sign In" in desktop Settings
2. Browser opens to `{WEB_URL}/auth/desktop`
3. User authenticates via Stack Auth (Google/GitHub)
4. Web redirects to `launcher://auth/callback?token=xxx`
5. Desktop exchanges token for session
6. Session stored securely in system keyring

## Subscription Tiers

| Feature | Free | Pro ($9/mo) | Team ($29/mo) | Enterprise |
|---------|------|-------------|---------------|------------|
| AI Queries | 50/mo | 1,000/mo | 5,000/mo | Unlimited |
| Plugins | 5 max | 50 max | Unlimited | Unlimited |
| Cloud Sync | âŒ | âœ… | âœ… | âœ… |
| Team Sharing | âŒ | âŒ | âœ… | âœ… |
| SSO/SAML | âŒ | âŒ | âŒ | âœ… |

## Production Deployment

### Web App (Vercel/Netlify)

1. Connect your Git repository
2. Set environment variables
3. Deploy

### API Server

Deploy to any Node.js hosting (Railway, Render, Fly.io):

```bash
cd apps/server
bun run build
bun run start
```

### Desktop App

Build installers for distribution:

```bash
cd apps/launcher
bun tauri build
# Outputs to src-tauri/target/release/bundle/
```

## Development

### Adding a new plugin provider

1. Create provider in `apps/launcher/src-tauri/src/providers/`
2. Implement `SearchProvider` trait
3. Register in `lib.rs`

### Database schema changes

```bash
cd packages/db
# Edit src/schema.ts
bun run db:generate  # Generate migration
bun run db:push      # Apply to database
```

## License

MIT
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"],
      "env": ["NODE_ENV"]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "env": [
        "DATABASE_URL",
        "NEXT_PUBLIC_*",
        "STRIPE_*",
        "STACK_*",
        "UPSTASH_*",
        "LAUNCHER_*"
      ]
    },
    "lint": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "typecheck": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "clean": {
      "cache": false
    },
    "db:push": {
      "cache": false,
      "env": ["DATABASE_URL"]
    },
    "db:generate": {
      "cache": false,
      "env": ["DATABASE_URL"]
    },
    "db:migrate": {
      "cache": false,
      "env": ["DATABASE_URL"]
    },
    "db:studio": {
      "cache": false,
      "persistent": true,
      "env": ["DATABASE_URL"]
    }
  }
}
</file>

</files>
